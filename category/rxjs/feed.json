{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"rxjs\" category",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/replacing-an-element-in-an-array-with-rxjs/",
            "url": "http://davembush.github.com/replacing-an-element-in-an-array-with-rxjs/",
            "title": "Replacing an Element in an Array with RxJS",
            "date_published": "2017-11-21T11:30:34.000Z",
            "content_html": "<p>It is not uncommon in our programming endeavors to need to replace one element in an array.  Using old school procedural programming, this would be relatively easy.  Loop through the elements, when we find the one we want to replace, change the value.  Basic for&#x2F;next loop with a conditional statement. </p>\n<p>But when you move to a more functional way of programming as we need to do for NgRX, or are encouraged to do to make our code more testable, the problem becomes less straight forward. </p>\n<p>The initial solution you might try would be to just run <code>reduce()</code> against the array.  But if we do this, we still need to put that nasty conditional within our reducer function.  This is something we’d prefer to avoid.  Yes, it will work.  But it isn’t Functional.  This problem has bothered me for months.  I’ve finally spent the time to figure out the solution. <figure><img src=\"/uploads/2017/11/2017-11-21.jpg\" title=\"Replacing an Element in an Array with RxJS\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/manchesterlibrary/2034771121/\">Manchester Library</a> via <a href=\"//visualhunt.com/re/1b8ae8\">Visualhunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\"> CC BY-SA</a></figcaption></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Simple-Problem\"><a href=\"#Simple-Problem\" class=\"headerlink\" title=\"Simple Problem\"></a>Simple Problem</h2><p>For the purposes of our discussion, we are going to assume that we have an array of integers, 1 through 5.  We want to change the value of 3 to 33.  If we were going to just extract the value and change it, we would use a filter.  But what we want to do here instead is split the array into two streams.  Elements that are 3 and elements that are not three.  You might reach for the filter function to do this. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]; </span><br><span class=\"line\"><span class=\"keyword\">const</span> item = array.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x === <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> notItem = array.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x !== <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Merging-Arrays\"><a href=\"#Merging-Arrays\" class=\"headerlink\" title=\"Merging Arrays?\"></a>Merging Arrays?</h2><p>But the problem you’ll run into almost immediately is that now that we have the array split in two, how are we going to merge them back together again?  For this, we would need the <code>Observable.merge()</code> method.  But, arrays are not <code>Observables</code>. </p>\n<p>Now, let’s rethink this problem.  What if we turn the array into an observable?</p>\n<h2 id=\"Observable-Arrays\"><a href=\"#Observable-Arrays\" class=\"headerlink\" title=\"Observable Arrays\"></a>Observable Arrays</h2><p>We can still use the <code>filter()</code> but now we can merge the results. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = <span class=\"title class_\">Observable</span>.<span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> item = array.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x === <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> notItem = array.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x !== <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mergedList = <span class=\"title class_\">Observable</span>.<span class=\"title function_\">merge</span>(notItem, item.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">33</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reconstitution\"><a href=\"#Reconstitution\" class=\"headerlink\" title=\"Reconstitution\"></a>Reconstitution</h2><p>And now that our array, that is now an observable, is merged back together again, we can use <code>reduce()</code> to turn it back into an array. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduced = </span><br><span class=\"line\">  mergedList.<span class=\"title function_\">reduce</span>((<span class=\"attr\">acc</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;, <span class=\"attr\">element</span>: <span class=\"built_in\">number</span>): <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...acc, element], []);</span><br></pre></td></tr></table></figure>\n<p>And subscribe() to get the return valued. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduced.<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;</span>) =&gt;</span> <span class=\"comment\">/* do something with the array here */</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Out-of-Order\"><a href=\"#Out-of-Order\" class=\"headerlink\" title=\"Out of Order\"></a>Out of Order</h2><p>But, we still have a problem.  Because we are working with an array, there is no timing to make sure the 33 is where the 3 was.  So, we end up with an array that has 33 at the end.  Maybe that’s OK.  But there are times when we need to change the array without changing the order of the elements.  What do we do now?</p>\n<h2 id=\"Async-to-the-Rescue\"><a href=\"#Async-to-the-Rescue\" class=\"headerlink\" title=\"Async to the Rescue\"></a>Async to the Rescue</h2><p>It turns out that <code>Observable.from()</code> takes a second parameter that controls how the elements are handled.  If we pass in <code>async</code> for that parameter, the elements stay in order.</p>\n<h2 id=\"One-pass-Filter\"><a href=\"#One-pass-Filter\" class=\"headerlink\" title=\"One pass Filter\"></a>One pass Filter</h2><p>Now that we have this all working, there is one final tweak we can make.  Rather than creating two different, but very similar filters, we can use the partition() method to achieve the same result in one pass. </p>\n<p>This, combined with array destructuring, allows us to simplify the code where our filter is, to </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [item, notItem] = array.<span class=\"title function_\">partition</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x === <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>And now you have a Functional replacement of an element using RxJS.</p>\n<h2 id=\"Final-Code\"><a href=\"#Final-Code\" class=\"headerlink\" title=\"Final Code\"></a>Final Code</h2><p>Imports you’ll need:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">async</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/scheduler/async&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">IntervalObservable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/observable/IntervalObservable&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">TimerObservable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/observable/TimerObservable&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Scheduler</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/Scheduler&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/Observable&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/observable/interval&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/observable/from&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/operator/partition&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/operator/map&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/operator/reduce&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;rxjs/add/observable/merge&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Code:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = <span class=\"title class_\">Observable</span>.<span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"keyword\">async</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [item, notItem] = array.<span class=\"title function_\">partition</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> x ===<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"title function_\">merge</span>(notItem, item.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">33</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">reduce</span>((<span class=\"attr\">acc</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;, <span class=\"attr\">element</span>: <span class=\"built_in\">number</span>): <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; =&gt;</span><br><span class=\"line\">    acc = [...acc, element]</span><br><span class=\"line\">  , [])</span><br><span class=\"line\">  .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;</span>) =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> += <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(x));</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "RxJS"
            ]
        },
        {
            "id": "http://davembush.github.com/angular-observable-secrets-revealed/",
            "url": "http://davembush.github.com/angular-observable-secrets-revealed/",
            "title": "Angular Observable Secrets Revealed",
            "date_published": "2017-08-08T10:30:11.000Z",
            "content_html": "<p>If you’ve been programming JavaScript based applications for any length of time, you’ve probably already made the progression from callback hell to promises, but just to recap.  Whenever we make any kind of asynchronous call in JavaScript, we need to provide a callback function to the call so that, when the call completes, the function can be called with any resulting data.  Function calls you may typically make that need this kind of feature are <code>setTimeout()</code>, <code>setInterval(),</code> and AJAX calls using the various libraries that support this. </p>\n<p>The problem with using callbacks is that you can end up with “Callback Hell” where you have callbacks inside of other callbacks.  Our code becomes messy and difficult to reason about. </p>\n<p>To try to flatten this situation out, promises were created.  Instead of creating a callback function and passing it into the asynchronous function, the asynchronous function returns a promise that has a function we can pass our function into.  This function can return yet another promise.  The result is that instead of having nested callbacks, all of our callbacks live at the same level. </p>\n<p>However, in the process, we lost the ability to cancel an asynchronous function using callbacks.  Most of the time, this was not a huge concern, but in the case of AJAX calls, we did end up making more request than we really needed to.  Most people never even recognized this as an issue.  But if you go and take a look at some of your older code, you will see that you have several places where the code would work more efficiently if you were able to cancel a call that was being superseded by a new call. </p>\n<p>Meanwhile, some additional functions were added to JavaScript Arrays.  Maybe you’ve seen some of them?  map(), reduce(), and filter() are three of the more common functions. </p>\n<p>What?  You haven’t seen these?  If you have and you know how they work, you can skip this next section.  But, if you haven’t, pay careful attention because this next section is critical to understanding how Observables work. <figure><img src=\"/uploads/2017/08/2017-08-08.jpg\" title=\"Angular Observable Secrets Revealed\"> Photo via <a href=\"//visualhunt.com/re/4ba464\">VisualHunt.com</a></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Array-Functions\"><a href=\"#Array-Functions\" class=\"headerlink\" title=\"Array Functions\"></a>Array Functions</h2><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>Let’s say you have a list of objects that you need to transform into another form.  In the example below, we want to transform our list of objects into a list that can be used in a dropdown list using fullName for the display and id for the value. </p>\n<p>Without using <code>map()</code>, your code might look something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = []; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; someList.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> item = someList[i];</span><br><span class=\"line\">   newArray.<span class=\"title function_\">push</span>(&#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The thing is, we do most of the code from <code>newArray = []</code> on down over and over again.  It is only the code in the <code>push()</code> that changes. </p>\n<p>What if we were to make the code into a function?  That’s what <code>map()</code> does.  It takes a function as a parameter that takes an item as a parameter.  Inside the function, we use that item to specify how we want to transform the item and the whole map() function returns the new array. </p>\n<p>The code above, turns into this.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = someList.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>Now, let’s say that for some reason, you only want to include items in the new array that include a last name that starts with ‘B’. Our old style code would look something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = []; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; someList.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> item = someList[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(<span class=\"params\">‘B’</span>) &#123;</span><br><span class=\"line\">       newArray.<span class=\"title function_\">push</span>(item);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And once again, this is code we tend to write quite a bit.  So, what if we had a function that did this for us? </p>\n<p>This is exactly what the <code>filter()</code> function is for.  So, rewriting the code above using <code>filter()</code> would look like this.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\">newArray = someList.<span class=\"title function_\">filter</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Chaining\"><a href=\"#Chaining\" class=\"headerlink\" title=\"Chaining\"></a>Chaining</h3><p>Once again, you can see that we passed in a function that takes the current item as a parameter.  The function returns true or false.  If it returns true, the item gets included in the new array. </p>\n<p>What if we want to filter AND transform the data? </p>\n<p>The temptation for programmers new to this model is to use the map and push the item into an array that was declared outside of the map. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = [];</span><br><span class=\"line\">someList.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’)) &#123;</span><br><span class=\"line\">       newArray.<span class=\"title function_\">push</span>(&#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">           item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>But that really isn’t all that much better than if we were just using a for&#x2F;next loop like we’ve been doing.  Old habits die hard. </p>\n<p>Instead, we can take advantage of function chaining. What this allows us to do is to filter and then map. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\">newArray = someList.<span class=\"title function_\">filter</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’);</span><br><span class=\"line\">&#125;.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>So much cleaner.</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>The final useful function we have available to us for dealing with common array loops is reduce().  reduce() allows to loop through an array and accumulate the items in an array into another array, an object, or a value. </p>\n<p>The reduce() function take two parameters.  The first parameter is a function.  The second parameter is the starting value for the accumulator. </p>\n<p>The function that we pass in takes three parameters.  The current value of the accumulator, the current item, and the current item index.  Most people only use the first two parameters in their function.  The function returns the new accumulator value that then gets passed into the next call to the function. </p>\n<p>So, a really simple example would be, given an array of numbers, add them all up. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = numbers.<span class=\"title function_\">reduce</span>(<span class=\"keyword\">function</span>(<span class=\"params\">sum, item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> sum + item;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>I’ve also used this to turn an array of name&#x2F;value pairs into an object where the properties are the name and the values are the values that were paired with the names.</p>\n<h2 id=\"Events-as-Arrays\"><a href=\"#Events-as-Arrays\" class=\"headerlink\" title=\"Events as Arrays\"></a>Events as Arrays</h2><p>Now, imagine that events that fire are part of one long continuous array.  An array that never ends. If this were true listening to events would be as familiar as processing an array. </p>\n<p>This is all an observable is.  It treats everything as though it were an array, adds several other functions that give us even greater functionality, and several functions that allow us to deal with the fact that events are not only sequential, but also time based. </p>\n<p>And because events aren’t really arrays, we call this series of items a “stream.”  So, when you read about “streams” while working with Observables think, “list of items.”</p>\n<h3 id=\"Button-Click\"><a href=\"#Button-Click\" class=\"headerlink\" title=\"Button Click\"></a>Button Click</h3><p>For example, let’s say you have a button on your screen and you want to know when it is pressed.  Let’s say your button is represented by a member variable name “myButton”.  In your code, you would listen to a button click by writing code that looks something like: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"title function_\">fromEvent</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">myButton</span>,<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> </span><br><span class=\"line\">   <span class=\"comment\">/* do something in response to the click here */</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>You will notice that we used the <code>subscribe()</code> function instead of <code>map()</code>.  We still have a <code>map()</code> function.  But, <code>subscribe()</code> is how we tell the application, “we want to start listening to the stream now.”  Otherwise, <code>subscribe()</code> works just like map() does. </p>\n<p>Yes, I know what you’re thinking.  “How is that better than just having the template call an event handler?” </p>\n<p>Well, the fact of the matter is, it really isn’t all that much better.  But, here is where it does make more sense.</p>\n<h3 id=\"Debouncing-Keystrokes\"><a href=\"#Debouncing-Keystrokes\" class=\"headerlink\" title=\"Debouncing Keystrokes\"></a>Debouncing Keystrokes</h3><p>If you’ve been writing application in JavaScript for a while, I’m sure you’ve written classic debounce handlers.  You know.  Don’t actually fire this event until you are no longer receiving change events from the input field. </p>\n<p>I won’t write out the old code here.  It is relatively long, hard to follow, and therefore somewhat complicated. </p>\n<p>But here is how we handle it using Observables. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"title function_\">fromEvent</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">myInput</span>,<span class=\"string\">&#x27;change&#x27;</span>).<span class=\"title function_\">debounceTime</span>(<span class=\"number\">250</span>).<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">/* do something in response to the input field change here */</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>debounceTime(250)</code> tells the Observable to wait for 250 milliseconds to see if there is some other event that comes in and use that event instead.  That is much easier than the old way.</p>\n<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><p>While you could handle button clicks and debounce logic using old school JavaScript tricks, in Angular, it is practically impossible to make an AJAX call without using Observables.  This is because the <code>Http</code> service and the <code>HttpClient</code> that was introduced in Angular 4.3 use Observables instead of callbacks or promises to manage dealing with the data that eventually is returned from the AJAX call. </p>\n<p>Since <code>Http</code> and <code>HttpClient</code> are similar, we will continue our discussion of handling AJAX calls using <code>HttpClient</code>.  The main advantage to using <code>HttpClient</code> is that it handles parsing the response into a JavaScript object we can use.  <code>Http</code> just returns the raw Response object and parsing it out is up to us. </p>\n<p><code>HttpClient</code>, on the other hand, returns the object we would have parsed out with <code>Http</code>. </p>\n<p>NOw, assuming you’ve injected HttpClient into the class that is going to use it, a typical get might looks something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(<span class=\"string\">&#x27;/api/get-data&#x27;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span> );</span><br></pre></td></tr></table></figure>\n\n<p>So, walking through this, you may notice that some things look very similar to Promises and then, there are some other things that aren’t so much.  But trust me this gets much better.  We are just starting out small. </p>\n<p>First, what is that <code>TypeInfo</code> thing? </p>\n<p>You see, our get call is what is normally referred to as a “templated method.”  In simple terms, get doesn’t know what type it returns until you tell it.  So, we are telling it that it returns a <code>TypeInfo</code> type.  <code>TypeInfo</code> is just a name I made up.  You would create an interface that is relevant to the type of information that your AJAX code is returning. </p>\n<p>Other than that, we subscribe to the observable that get() returns and process the data. </p>\n<p>Noq, what if our get call fails? </p>\n<p>Oh! We have methods for that. </p>\n<p>First, we can trap failures with a <code>catch()</code> call. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(‘/api/get-data’)</span><br><span class=\"line\">   .<span class=\"title function_\">catch</span>(<span class=\"attr\">err</span>: <span class=\"function\"><span class=\"params\">Error</span> =&gt;</span> <span class=\"comment\">/* do something with the error */</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Next, maybe you want to <code>retry</code> the failed call before you give up. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(‘/api/get-data’)</span><br><span class=\"line\">   .<span class=\"title function_\">retry</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">catch</span>(<span class=\"attr\">err</span>: <span class=\"function\"><span class=\"params\">Error</span> =&gt;</span> <span class=\"comment\">/* do something with the error */</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span>);</span><br></pre></td></tr></table></figure>\n\n<p>And because we have a <code>catch()</code>, with must have a <code>finally</code> too, right? </p>\n<p>Try doing all of that with a Promise or a Callback. </p>\n<p>Oh, and did I mention you can cancel AJAX calls using Observables?  Yep.  It’s true.  In fact, my experience has been that if you make the same call from the same service two times in a row, it will cancel the first call before it makes the second.  Pretty cool. </p>\n<p>The final thing that tends to trip people up who are learning about Observables is that nothing in the observable chain executes until you subscribe to the observable and an event happens. </p>\n<p>Once you start getting comfortable with all of the methods you have available to you, you’ll begin to see the power of using Observables over using Promises or Callbacks, even if there are similarities.</p>\n",
            "tags": [
                "angular",
                "observables",
                "RxJS"
            ]
        },
        {
            "id": "http://davembush.github.com/real-world-rxjs-marble-testing-revealed/",
            "url": "http://davembush.github.com/real-world-rxjs-marble-testing-revealed/",
            "title": "Real World RxJS Marble Testing Revealed",
            "date_published": "2017-06-13T10:30:25.000Z",
            "content_html": "<p>There must be some evil plot to keep this information a secret because whenever I search for how to use RxJS Marble Testing all I see is how to use it to write tests for RxJS.  Well I’ve finally “cracked the code.” </p>\n<p>In this article you’ll learn the basics of RxJS Marble Testing and how to apply Marble Testing to your own code.</p>\n<figure>![](/uploads/2017/06/2017-06-13.jpg \"Real World RxJS Marble Testing Revealed\") Photo via [Visualhunt](//visualhunt.com/re/9662e0)</figure>\n\n<span id=\"more\"></span> \n\n<h2 id=\"It-All-Started-When-…\"><a href=\"#It-All-Started-When-…\" class=\"headerlink\" title=\"It All Started When …\"></a>It All Started When …</h2><p>It all started about a month ago when I needed to write a unit test for code that updated the screen once every 15 seconds. Writing a test that would simulate the clock moving forward 15 seconds in old school JavaScript would have been pretty easy.  But I had written my code using RxJS instead of the old school <code>setTimeout()</code> method we’ve been using for this kind of feature in the past. </p>\n<p>Specifically, I had used <code>Observable.timer(0, 15000);</code> </p>\n<p>My first attempt to write tests for this were based on the assumption that, under the hood, <code>setTimeout()</code> was still being used. Just a simple matter of mocking the clock and advancing the timer. Right?</p>\n<p>Wrong!</p>\n<p>Then my initial search brought me to the NgRX 4 way of writing tests for Observables. Only, I didn’t find that out until I had written some code that didn’t work. </p>\n<p>Eventually, I found this thing called Marble Testing. But, as I’ve already mentioned, all the examples I’ve found for how to write test are for written test for the various methods available in the RxJS library. </p>\n<p>I’m guess, if you are still reading, I’ve described your journey as well.</p>\n<h2 id=\"Assumptions\"><a href=\"#Assumptions\" class=\"headerlink\" title=\"Assumptions\"></a>Assumptions</h2><p>For the remainder of this article, I’m going to assume you know how to use RxJS. If you don’t there is already a lot of good information available on that topic that you should easily be able to find by using one of the search engines.</p>\n<p>I’m also going to describe how to use marbles in your tests using Jasmine. I use Jasmine because that is the engine all the frameworks that I use end up using. There are other tools that may or may not be better. But I have no reason to leave what everyone else has already picked as a defacto standard.</p>\n<h2 id=\"Marble-Basics\"><a href=\"#Marble-Basics\" class=\"headerlink\" title=\"Marble Basics\"></a>Marble Basics</h2><p>Since there is a lot of detail on the basics of using Marbles, I only plan on summarizing what you need to know here.  For more details, check out <a href=\"//github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">the documentation</a>.</p>\n<h3 id=\"Create-Observables\"><a href=\"#Create-Observables\" class=\"headerlink\" title=\"Create Observables\"></a>Create Observables</h3><p>First, you can create either hot observables or cold observables. To do this, you’ll need to create an instance of <code>TestScheduler</code> and then you call either <code>createHotObservable()</code> or <code>createColdObservable()</code> passing a string that defines what you want your observables to do. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> testScheduler = <span class=\"keyword\">new</span> <span class=\"title class_\">TestScheduler</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> hotObservable = testScheduler.<span class=\"title function_\">createHotObservable</span>(hotMarbleString);</span><br><span class=\"line\"><span class=\"keyword\">const</span> coldObservable = testScheduler.<span class=\"title function_\">createColdObservable</span>(coldMarbleString);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Marble-Syntax\"><a href=\"#Marble-Syntax\" class=\"headerlink\" title=\"Marble Syntax\"></a>Marble Syntax</h3><ul>\n<li><code>&quot;-&quot;</code> time: 10 “frames” of time passage.</li>\n<li><code>&quot;|&quot;</code> complete: The successful completion of an observable. This is the observable producer signaling <code>complete()</code></li>\n<li><code>&quot;#&quot;</code> error: An error terminating the observable. This is the observable producer signaling <code>error()</code></li>\n<li><code>&quot;a&quot;</code> any character: All other characters represent a value being emitted by the producer signaling <code>next()</code></li>\n<li><code>&quot;()&quot;</code> sync groupings: When multiple events need to single in the same frame synchronously, parenthesis are used to group those events. You can group next values, a completion or an error in this manner. The position of the initial <code>(</code>determines the time at which its values are emitted.</li>\n<li><code>&quot;^&quot;</code> subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the “zero frame” for that observable, every frame before the <code>^</code> will be negative.</li>\n</ul>\n<p>The most simple of observables using marbles would look like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;a|&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>This would cause an observable event to fire right away and it would pass “a” as the data for the observable.  The observable would then end because the | comes next. </p>\n<p>In the case of the timer I was testing, I don’t need the data, I just need the “event” to fire so my code runs.</p>\n<h2 id=\"Marbles-as-Mocks\"><a href=\"#Marbles-as-Mocks\" class=\"headerlink\" title=\"Marbles as Mocks\"></a>Marbles as Mocks</h2><p>So far, I probably haven’t told you anything that you couldn’t already figure out by doing a basic search.  But, the question remains, how do we use this marble stuff in our own test? </p>\n<p>And the answer that no one seems to be talking about is that you use marbles to mock out the real observable just like you might create a mock object to replace a real object in any other test. </p>\n<p>In the case of the timer problem above, what I needed to do was to make sure that <code>Observable.timer(0, 15000);</code> returns an observable that was created with a marble instead of an observable created with the timer.  In Jasmine, we do that with <code>spyOn()</code> </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testScheduler = <span class=\"keyword\">new</span> <span class=\"title class_\">TestScheduler</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"title function_\">spyOn</span>(<span class=\"title class_\">Observable</span>, <span class=\"string\">&#x27;timer&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"property\">and</span></span><br><span class=\"line\">  .<span class=\"title function_\">returnValue</span>(testScheduler.<span class=\"title function_\">createHotObservable</span>(<span class=\"string\">&#x27;---a|&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>The rest of your code really doesn’t care what kind of observable it is, it will do whatever it is it has been coded to do. </p>\n<p>The only thing you need to do to make sure the observable and subscribes do their thing is to make sure you call <code>flush()</code> on the <code>TestScheduler</code> instance prior to running an <code>expect()</code> in your Jasmine test.</p>\n<h2 id=\"Other-Uses\"><a href=\"#Other-Uses\" class=\"headerlink\" title=\"Other Uses\"></a>Other Uses</h2><p>What I’ve shown so far takes care of my 15 second refresh issue. But now, what if I have an observable that expects data? For example, how would I write a test that uses an observable based on an AJAX request as a dependency? In Angular, this would be Http. </p>\n<p>This is actually very simple. The second parameter to either <code>createHotObservable()</code> or <code>createColdObservable()</code> is the data you want to send on to the subscribe when it hits the associated marble. You pass this in as an object literal. So, just to keep things simple. Say that when you hit the “a” marble, you want to pass the subscribe an object that has a first name and a last name. Your code might look something like this:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testScheduler</span><br><span class=\"line\">  .<span class=\"title function_\">createHotObservable</span>(</span><br><span class=\"line\">    <span class=\"string\">&#x27;-a|&#x27;</span>,</span><br><span class=\"line\">    &#123;<span class=\"attr\">a</span>: &#123;<span class=\"attr\">firstName</span>: <span class=\"string\">&#x27;Dave&#x27;</span>, <span class=\"attr\">lastName</span>: <span class=\"string\">&#x27;Bush&#x27;</span>&#125;&#125;</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p>By using this type of marble mocking, you could not just create unit tests, but you could also create End to End tests that use marbles to return consistent data rather than hitting the back end. Obviously, you would still need to write tests that ensure your back end is going to return the same type of data, but I see that as a separate issue from ensuring that the front end does everything it should do as a system. Anyhow, it is an option.</p>\n",
            "tags": [
                "angular",
                "RxJS",
                "Marble Testing"
            ]
        }
    ]
}