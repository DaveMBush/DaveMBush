{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"continuous integration\" category",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/selenium-performance-improvements/",
            "url": "http://davembush.github.com/selenium-performance-improvements/",
            "title": "Selenium Performance Improvements",
            "date_published": "2014-10-02T10:00:00.000Z",
            "content_html": "<p>As many of you know, I’ve been using <a href=\"//www.seleniumhq.org/\">Selenium</a> to do my website testing.  And, if you’ve done any testing with Selenium yourself, you know that Selenium can be even slower if you are using Selenium Grid. There are several things you might do today to achieve Selenium Performance improvements in order to increase the speed that your of your test run.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"CacheLookup-attribute-or-Annotation-if-you-are-using-Java\"><a href=\"#CacheLookup-attribute-or-Annotation-if-you-are-using-Java\" class=\"headerlink\" title=\"CacheLookup attribute (or Annotation if you are using Java)\"></a>CacheLookup attribute (or Annotation if you are using Java)</h2><p>This is probably the most obvious place for improvement.  Assuming you are using the Page Model pattern in your testing, your page model should have properties that already look something like:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">FindsBy(How = How.Id, Using = <span class=\"string\">&quot;radioButton&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"keyword\">private</span> IWebElement RadioButton&#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>What you may not know is that the way this works is that EVERY time you access the property named RadioButton it will lookup the location of the radio button.  The RadioButton property is actually a proxy for the real IWebElement that it will lookup on the fly. So, if you are using the element more than once in your test, it will perform the lookup each time you access the RadioButton property. By adding the CacheLookup attribute to the RadioButton property,</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">FindsBy(How = How.Id, Using = <span class=\"string\">&quot;radioButton&quot;</span>), CacheLookup</span>]</span><br><span class=\"line\"><span class=\"keyword\">private</span> IWebElement RadioButton&#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>you can force the RadioButton to be resolved once and only once. Most of my test ask for elements once per test, so I didn’t see any major performance gains by adding this.  Your mileage may vary.</p>\n<h2 id=\"CacheLookup-Warning\"><a href=\"#CacheLookup-Warning\" class=\"headerlink\" title=\"CacheLookup Warning\"></a>CacheLookup Warning</h2><p>Be careful when adding CacheLookup to your properties because any time the HTML is recreated, the element will become “stale” and you’ll need to look it up again. For example, in one of the pages I’m testing, I have two modal windows that get created as part of the test.  Each time they are created, they have to be resolved again because the old ones no longer exist. It would be like trying to reference a pointer to an object that no longer exist because something else deleted it.  Actually, that’s exactly what is happening.</p>\n<h2 id=\"CacheLookup-Only-Solves-One-of-Your-Problems\"><a href=\"#CacheLookup-Only-Solves-One-of-Your-Problems\" class=\"headerlink\" title=\"CacheLookup Only Solves One of Your Problems\"></a>CacheLookup Only Solves One of Your Problems</h2><p>But if all you do to your site is add CacheLookup, you are wasting your time.  You have to start thinking like your code. Did you know that every time you access a property on an IWebElement, Selenium has to make a call to the browser to access the current value? Yep. Actually, if you think about it, this is what you hope it does.  It is what makes code like this work:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wait.Until(x =&gt; Page.RadioButton.GetAttrinbute(<span class=\"string\">&quot;disabled&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>But how many times to we write code that goes after a property multiple times when we know the value, or at least we assume the value, hasn’t changed? Or how many of you are doing the same thing multiple times in the same test? For example, in the code I’m testing currently, I have a header and a footer that I need to hide so that when an element is scrolled into view by Selenium, it doesn’t scroll under the header or the footer. I’m currently hiding and showing every time I perform some action on an element.  But now that I’m starting to think about performance, I’m asking myself, “What was I thinking?!” In this case, I would save a lot of time by turning the header off once a the beginning of my test.  I bet my test end up running twice as fast simply by doing that. So, keep in mind that every Selenium call you make is probably going to have to access the server in order to perform the action or retrieve the value you are looking for and try to write your code so that you are only making that call to the server one time per test. I bet you see some performance improvements.</p>\n",
            "tags": [
                "tdd",
                "c#",
                "bdd",
                "selenium",
                "java"
            ]
        },
        {
            "id": "http://davembush.github.com/make-your-test-work-for-you/",
            "url": "http://davembush.github.com/make-your-test-work-for-you/",
            "title": "Make Your Test Work For You",
            "date_published": "2014-04-18T15:53:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/04/TDD-CI.png\" alt=\"TDD-CI\" title=\"TDD-CI\"> So far we’ve been talking about creating test as part of the development process.  If all you ever used those test for was to make the design of your systems better, you would already be far ahead of most of your peers.</p>\n<p>But now that we have test, we might as well get as much mileage out of them as possible.  To do that, we are going to run our test every time we make a change.</p>\n<p>Now, you COULD run your test every time you make a change manually.  But who has time for that?  Certainly not me.  I doubt you do either.  And even if we did have time, there are better things we could be doing with that time if we could have those test run for us by some other process.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Continuous-Integration\"><a href=\"#Continuous-Integration\" class=\"headerlink\" title=\"Continuous Integration\"></a>Continuous Integration</h2><p>For this we need a continuous integration server.  Here’s what you want to make sure your CI server is able to do.</p>\n<ul>\n<li>Run your unit test</li>\n<li>Run your integration test</li>\n<li>Run your acceptance test</li>\n</ul>\n<p>To make sure it can do that, it will also need to be able to pull the source code from version control every time a new change is committed and build the new version.  I would bet that IF you have a CI server at all, this is all that it does.</p>\n<p>It needs to be able to notify  the developer who put the change in that the change caused a problem.  Ideally, it wouldn’t even allow  a change to go into your version control system if committing the change would cause the build or the test to fail.</p>\n<p>By implementing a CI server you are well on your way to ensuring that whatever is in version control can be released without causing any problems.</p>\n<h2 id=\"CI-Setup\"><a href=\"#CI-Setup\" class=\"headerlink\" title=\"CI Setup\"></a>CI Setup</h2><p>Since unit test are the core of your system, you’ll want to make sure that you run these test with every build.  But your integration test, and especially your acceptance test are going to take a lot longer than is practical to run as part of the process that runs with each check in.  I’ve been working on one scree of a system and so far I have about 30 hours of acceptance&#x2F;integration test using Selenium to drive 3 different web browsers.  Even if I narrowed the test down to one browser, that’s about 10 hours of test.  I don’t want to wait 10 hours to find out that my build worked (or not) and the changes that one of those test will fail is pretty small.  So, I’ve scheduled half of my test to run on one day and half of them to run on another day.</p>\n<p>With a good CI setup, you can be sure that changes you are making are not breaking code you’ve already confirmed is working.</p>\n",
            "tags": [
                "tdd",
                "test driven development",
                "CI. Continuous Integration"
            ]
        }
    ]
}