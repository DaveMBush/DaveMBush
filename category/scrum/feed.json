{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"scrum\" category",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "url": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "title": "You Aren’t Doing Scrum If…",
            "date_published": "2020-06-20T11:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/01/YouArentDoingScrumIf.png\" alt=\"You Aren&#39;t Doing Scrum If...\" title=\"YouArentDoingScrumIf\">I’ve been frustrated lately by the flippant use of the words “Scrum” and “Agile” in our industry. </p>\n<p>Actually, I’m STILL frustrated.  I originally wrote this article January 2015.  Not only is it still true.  It is <strong>more</strong> true.</p>\n<p>Our industry has been treating Scrum and Agile as “buzzwords that mean nothing.” These words get slapped onto job requirements like the typical requirements we’ve all seen.</p>\n<ul>\n<li>Must be able to communicate</li>\n<li>Must be able to work in a team environment</li>\n<li>Must be able to work under pressure</li>\n<li>Must be able to work in an Agile environment</li>\n</ul>\n<p>What’s really funny is when I see</p>\n<ul>\n<li>Meet tight deadline</li>\n<li>Expert in Agile</li>\n</ul>\n<p>together in the same job request.</p>\n<p>And even if it doesn’t show up in the job description.  Once you get into the organization, you find out they are no different than any other organization.  All those promises about running “Agile” or “Scrum” as a well of figuring out how long a project will take fly right out the window as soon as a manager wants something done by a specific date.</p>\n<p>If management ain’t Agile, ain’t no one Agile.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Really-Do-you-know-what-you’re-saying\"><a href=\"#Really-Do-you-know-what-you’re-saying\" class=\"headerlink\" title=\"Really?  Do you know what you’re saying?!\"></a>Really?  Do you know what you’re saying?!</h2><p>Many people even use the words “Agile” and “Scrum” interchangeably.  Most because they really do think they are the same thing.</p>\n<p>I’m finding that what most people mean when they use these words is, either, “we work really fast”, “we work iteratively”, or “we don’t really have a plan.”</p>\n<h2 id=\"So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\"><a href=\"#So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\" class=\"headerlink\" title=\"So, the first thing we need to clarify is, what is Scrum and what is Agile.\"></a>So, the first thing we need to clarify is, what is Scrum and what is Agile.</h2><p>Agile is a set of values.  It is what we believe about software development specifically and, I would argue, also impacts how we view life.  You might have other beliefs that live on top of Agile, but these beliefs will have an impact on how you manage the software development process specifically and your organization in general. Check out the <a href=\"//www.agilemanifesto.org/\">Agile Manifesto</a>.  This is what it means to be Agile.</p>\n<p>In contrast to this, Scrum is a methodology that helps an organization BE agile.</p>\n<p>Now here is where things get tricky for some people.  They read in the manifesto that we should value “Individuals and interactions over processes and tools” and think that they can make Scrum be whatever they want it to be because, they would say, “we don’t value processes and tools”.</p>\n<p>But the Agile Manifesto never says that.  It says we value individuals and interactions MORE than, not INSTEAD of, processes and tools.</p>\n<p>So, yes, you can adapt and modify Scrum to fit your situation.  You may need to.  But there are some specific elements of Scrum that you simply can’t ignore because to do so would mean either that you are no longer Agile or you are not implementing Scrum.</p>\n<h2 id=\"And-so-you-aren’t-doing-Scrum-if\"><a href=\"#And-so-you-aren’t-doing-Scrum-if\" class=\"headerlink\" title=\"And so, you aren’t doing Scrum if:\"></a>And so, you aren’t doing Scrum if:</h2><h4 id=\"You-have-deadlines-especially-if-you-have-“tight-deadlines”\"><a href=\"#You-have-deadlines-especially-if-you-have-“tight-deadlines”\" class=\"headerlink\" title=\"You have deadlines, especially if you have “tight deadlines”\"></a>You have deadlines, especially if you have “tight deadlines”</h4><p>“Now wait a minute,” you say, “I heard that Scrum has these things called ‘Sprints’ that are a fixed length.  Don’t those qualify as ‘deadlines?’” Well, yes and no.  You see, I don’t think what Scrum treats as a “deadline” is what most managers mean by “deadline.” At the end of the day you’ll get to the end of the Sprint and you’ll show what you’ve got.  The GOAL is to have a complete set of code that you wouldn’t be embarrassed to show to another programmer.  You should have only selected what could reasonably get done in the timeframe of a sprint so that all that needs to be done to complete the task could get done.</p>\n<p>One of the confusions is that somewhere along the line we were told that at the end of each sprint we should have a “shippable unit of software” and we’ve confused that with “a viably marketable product”  All that shippable means is, “if the customer thinks what you’ve completed so far is something they can use, you would not respond with, ‘but it still needs…’” This ties in with the other way you know you aren’t doing Scrum</p>\n<h4 id=\"You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\"><a href=\"#You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\" class=\"headerlink\" title=\"You aren’t doing scrum if you don’t have a “definition of done.”\"></a>You aren’t doing scrum if you don’t have a “definition of done.”</h4><p>And once again, there is confusion.  To most people, the “definition of done” is “I can ship this code.”  But that may not be appropriate.  You’re definition of done during your first sprint may be “a set of stories that begin to describe the application we are trying to build.”  As you are learning scrum, you’re definition of done may be as simple as, “all of the code we’ve written so far have Unit Test, appropriate documentation, and we’ve learned something of how long a story point will take our team.” Definition of done doesn’t always have to mean “I’ve written code I can ship.”</p>\n<h4 id=\"You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\"><a href=\"#You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\" class=\"headerlink\" title=\"You aren’t doing Scrum if you HAVE to work more than 40 hours a week.\"></a>You aren’t doing Scrum if you HAVE to work more than 40 hours a week.</h4><p>One of the benefits of Scrum is that it allows us to pace ourselves.  We no longer scramble to get stuff done.  We work consistently toward the goal.  But it isn’t a race.</p>\n<p>I have a rule.  If I tell you something will be done by a set time, I’ll bust my butt to make that happen.  If you tell me when it will be done, good luck with that.</p>\n<p>Of course, even when I tell someone when something will be done, I pad the estimate with enough hours that I never work more than 45 hours a week.  There is one day, in the 26 years I’ve been doing this where I worked longer than 12 hours.</p>\n<p>In fact, I had one manager who called me into his office and asked me to come in on Saturdays.  I was already working 10 hour days 5 days a week!  Talk about getting blood out of a turnip! I looked him straight in the eye and said, “I have 50 hours a week in me.  I’d prefer to give them to you Monday through Friday.  But if you want me to come in on Saturday, I can do that, but you are still only going to get 50 hours a week.” Needless to say, I never came in on Saturday.</p>\n<h2 id=\"I-could-go-on…\"><a href=\"#I-could-go-on…\" class=\"headerlink\" title=\"I could go on…\"></a>I could go on…</h2><p>But I won’t</p>\n",
            "tags": [
                "agile",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "url": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "title": "8 Reasons Johnny Does Not Write Bug Free Code",
            "date_published": "2016-09-20T10:30:00.000Z",
            "content_html": "<p>There have been a number of things that have occurred over the last week that have prompted this particular post.  And for anyone I work with, this is not an indictment of our work place so much as it is an indictment of our industry.  PLEASE don’t take this personally.</p>\n<p>Some of those reasons will show up in this article.  But the question we need to examine today is why is it so hard to write bug free code.  And I’m not even talking about perfection.  Why is it that we miss the simple stuff?  The stuff that once it is found, we think, “how could we have missed that?!”.  I’m perfectly aware that all code has bugs some just haven’t been found yet.  I’m also aware that no matter how hard I try, the stupid bugs always make their way past my desk.</p>\n<figure>![](/uploads/2016/09/image-1.png \"8 Reasons Johnny Does Not Write Bug Free Code\")<figcaption>Photo credit: [~Pawsitive~Candie_N](//www.flickr.com/photos/scjn/3450910519/) via [Visualhunt](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"No-Training\"><a href=\"#No-Training\" class=\"headerlink\" title=\"No Training\"></a>No Training</h2><p>Certainly not the only reason.  But at the same time I think this is a core reason.  Our industry really sucks when it comes to teaching computer science.  So much so, that I’ve written articles about how, for the most part, you don’t need a college education to become a programmer.  Maybe if we taught what programmers don’t already know how to do, a college education would be valuable.</p>\n<p>But what do we do instead?  We teach programmers how to program.</p>\n<p>Dumb! I think back to my education.  Here’s a basic summary of what I learned:</p>\n<ol>\n<li>COBOL, dBase III, JCS, CICS syntax.</li>\n<li>Break your code into functions</li>\n<li>A bit on how to do requirements analysis.</li>\n</ol>\n<p>Guess what?  I could have learned all of that on my own.  How do I know that?  Because I had already taught myself, Basic and C before.  I taught myself every language I’ve learned since.  I was already writing structured code, and still do.  And how we gather requirements has changed and somehow I managed to learn that on my own.  Programming is a learning profession.  It is one of the things that makes it attractive to me.</p>\n<p>But what didn’t I learn?  At no point did anyone ever teach me how to break my own code.  And while Test Driven Development wasn’t a thing when I was going to school.  I doubt they are teaching it today.  (Let me know if your school did or is.)</p>\n<h2 id=\"Happy-Path-Specs\"><a href=\"#Happy-Path-Specs\" class=\"headerlink\" title=\"Happy Path Specs\"></a>Happy Path Specs</h2><p>So, the programmers have no training.  But it isn’t just a programmer problem.</p>\n<p>When is the last time you got a specification from whoever creates them in your organization that had any more than a happy path set of requirements?  But, certainly there are things the system should not do.  I recently had to go asking for required fields and maximum field lengths in an application I was working on.  And that’s the simple stuff.</p>\n<h2 id=\"Not-My-Job\"><a href=\"#Not-My-Job\" class=\"headerlink\" title=\"Not My Job\"></a>Not My Job</h2><p>If you have a QA department, you might be tempted to leave testing to QA.  My personal goal is to make sure QA doesn’t find anything.  At least, not something really obvious.</p>\n<p>But I know that some programmers get sloppy about testing their code if they know the safety net of QA exist.</p>\n<p>There is also the problem of QA believing they are the only ones who test.  Strange, but true.  When QA found out I was writing unit test for a pretty complex piece of logic, I was asked, “Then what will be left for me to do?!”  Strange but true.</p>\n<p>But what if we started working as teams?  For example, what if I could get QA to help me develop my test plan?  What if developing software was a WE activity instead of several silo developers each doing their own thing?</p>\n<h2 id=\"Batch-Programming\"><a href=\"#Batch-Programming\" class=\"headerlink\" title=\"Batch Programming\"></a>Batch Programming</h2><p>This is one I really don’t understand.  But I know programmers who will write code for hours prior to running it.  Even if you did remember everything you coded, how can you possibly know where a bug is located if you wait that long?  You should be running your code every time you have something different that can be run so that you know what change caused a problem.  And don’t tell me you test every possible condition.  I know you don’t.</p>\n<p>Programmers who program like this are “Debbie Done” programmers.</p>\n<p>Why “Debbie Done”? There is this story about a programmer who used to work at one of the companies I worked at in the past.  She considered code done if it compiled and linked.</p>\n<p>I’m not as good at testing as I would like (yet) and I’m always embarrassed when someone finds a problem with my code.  So, I was shocked one day when I found out that a project manager wanted to give me some work because my code “always works.”  I knew that wasn’t true.  But when I reflected on what he was saying I realized that the difference in how I code and the other programmers he was comparing me to is that I write for a few minutes and then make sure that works before I continue on.</p>\n<h2 id=\"We-Don’t-Plan-to-Test\"><a href=\"#We-Don’t-Plan-to-Test\" class=\"headerlink\" title=\"We Don’t Plan to Test\"></a>We Don’t Plan to Test</h2><p>Ah.  And here we get a little closer to the truth.</p>\n<p>What do I mean by planning to test? For any spec you are working on, you should have, written out or coded, a repeatable set of steps that ensures that your code does what it should and doesn’t do what it shouldn’t.  This is what test driven development attempts to steer us toward.  I’m not going to go off on a rant about TDD again here.  But I will tell you that either having a written out test plan prior to coding enables me to ensure that my code does what the people who gave me the specification think it should.  It also forces me to think about ways I might break the code.  I know my code is delivered with less bugs because of this process.  Hopefully, I’ll get better at thinking of how to break my own code.</p>\n<p>Having a plan helps with the Debbie Done programmer as well as people who code more like me.</p>\n<p>Even though I code&#x2F;test incrementally, I still only test the code right after I’ve written it.  Once I think it is working, I don’t go back, even though something else I’ve written may have changed how the code is working.  Having repeatable tests has save me several times.</p>\n<h2 id=\"We-Don’t-Know-what-we-Don’t-Know\"><a href=\"#We-Don’t-Know-what-we-Don’t-Know\" class=\"headerlink\" title=\"We Don’t Know what we Don’t Know\"></a>We Don’t Know what we Don’t Know</h2><p>Even if we do everything right, we are still going to miss stuff.  One person can’t possibly figure out all that might go wrong.  It is how we deal with the problems once they are revealed that becomes the issue.  This is where we would, ideally, have the team come up with the test scenarios.</p>\n<h2 id=\"Shame-Driven-Development\"><a href=\"#Shame-Driven-Development\" class=\"headerlink\" title=\"Shame Driven Development\"></a>Shame Driven Development</h2><p>I actually heard a project manager say, “Shame on the developer if QA finds bugs.” Really?!  What about “Shame on the BA for not including that item in the requirements.”?  What about “Shame on the product owner for not mentioning it.”? Or what about no shame at all? While shame is a powerful motivator in the short term, it is a sure way to make sure your developers leave.</p>\n<p>That you only retain highly dysfunctional programmers.  Or that you can only retain programmers who can’t really code.</p>\n<p>Shame based development can only lead to even more bugs.  Not fewer.</p>\n<p>At some point I should probably write about the dangers of a shame based culture.   If your organization is using shame to manage personnel.  Get out!</p>\n<h2 id=\"Long-Hours\"><a href=\"#Long-Hours\" class=\"headerlink\" title=\"Long Hours\"></a>Long Hours</h2><p>Another way you can kill the overall effectiveness of your team is to make sure everyone works more than 45 hours a week for months or years at a time.  One of two things will happen, if not both.</p>\n<p>The code will suffer.  Want to introduce more bugs?  Keep everyone working overtime.  A week here or there is a different story.</p>\n<p>If the code doesn’t suffer, then you are likely to find a lot more socialization, social media activities, and just plain goofing off occurring.  People just can’t work that many hours.  Just because someone is at work for 10 hours doesn’t mean they are working 10 hours.  But hours are easy to measure, so this terrible practice continues.</p>\n<h2 id=\"We-Can’t-Fix-Everything\"><a href=\"#We-Can’t-Fix-Everything\" class=\"headerlink\" title=\"We Can’t Fix Everything\"></a>We Can’t Fix Everything</h2><p>I’m in a unique position in that I’m currently functioning as a Scrum coach.  This allows me to influence all the areas I’ve discussed.  As programmers, you can only influence your own stuff.  So, my recommendation to you is to concentrate on what you have control over.  Create a test plan prior to writing code.  Once you’ve learned how to do that, work on learning how to code those test so you don’t have to run them manually over and over again.  Do this slowly.  Maybe start with just one test.  Squeeze it into the cracks of your regular work.  Learning to test and learning to code test takes time, but it will make you a better programmer and will ultimately make you a more reliable and faster programmer.  Someday you might just hear that they want to give you an important job because “Johnny’s code always works.”</p>\n",
            "tags": [
                "tdd",
                "code",
                "agile",
                "scrum",
                "bug"
            ]
        },
        {
            "id": "http://davembush.github.com/how-to-establish-peace-to-the-qa-vs-dev-battle/",
            "url": "http://davembush.github.com/how-to-establish-peace-to-the-qa-vs-dev-battle/",
            "title": "How to Establish Peace to the QA vs Dev Battle",
            "date_published": "2016-09-13T10:30:00.000Z",
            "content_html": "<p>Have you ever noticed how, when QA reports a “defect” developers tend to bristle?  I first noticed this in myself a few years ago.  Now that I’m functioning as a Scrum coach, I’m noticing it in others.</p>\n<p>Is there a way to have some kind of quality checking in our code that doesn’t make the whole process feel so adversarial?  I think so.</p>\n<p>I believe there are some adjustments that need to be made organizationally and personally that will bring these two groups together.</p>\n<p>But first, why does this problem exist in the first place? <figure><img src=\"/uploads/2016/09/image.png\" title=\"How to Establish Peace to the QA vs Dev Battle\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/39908901@N06/9129574323/\">m01229</a> via <a href=\"//visualhunt.com\">Visual hunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by/2.0/\">CC BY</a></figcaption></figure></p>\n<span id=\"more\"></span>\n\n<h2 id=\"How-The-Battle-Started\"><a href=\"#How-The-Battle-Started\" class=\"headerlink\" title=\"How The Battle Started\"></a>How The Battle Started</h2><h3 id=\"How-to-Insult-a-Programmer\"><a href=\"#How-to-Insult-a-Programmer\" class=\"headerlink\" title=\"How to Insult a Programmer\"></a>How to Insult a Programmer</h3><p>When I was growing up, my sister was very direct.  If she thought you were ugly, she’d tell you so.  OK.  Maybe it wasn’t quite that bad.  But one day, I remember she said something to the effect of, “I didn’t say anything that wasn’t true.”  And both my mom and I said, “Yes, but it isn’t what you said so much as how you said it.”  In fact, you can say the same words in two entirely different ways.  Two sets of inflections.  And what they mean can change drastically.  Sometimes just changing the words you use can change the meaning.</p>\n<p>But, to a programmer, no matter how you say, “Your code has a bug,” they will probably end up hearing.</p>\n<p>“Your code sucks!” You see.  Programmers really do care about their code.  At least the really good ones do.  And while it may seem very silly, most programmers get offended when you suggest they’ve written buggy code.</p>\n<p>This, you see, is the core of the problem.  Once you understand this, the fix becomes rather obvious.</p>\n<h3 id=\"Don’t-Call-It-a-Bug\"><a href=\"#Don’t-Call-It-a-Bug\" class=\"headerlink\" title=\"Don’t Call It a Bug\"></a>Don’t Call It a Bug</h3><p>I think nothing has done more damage in the field of programming that the fact that we call software problems “Bugs.”  It is such an ugly word.  When is the last time, other than a Pixar movie, when we’ve thought of bugs as something we would want to welcome?  We might as well say, “Hey, I found some shit in this program!” When I got my Scrum certification, our instructor asked a simple revealing question.  “How many of you think people are doing their best to do the right thing?”  That’s not exactly what he asked, but that’s what he meant.  If you believe that all evil in the world is intentional, you’ll come away believing that all programmer intentionally put bugs in their code.  And while I do know of a few cases where this has happened.  Most of us try our best to write perfect code.  When we don’t it is because we didn’t think of the situation and code for it.</p>\n<p>If on the other hand, you think everyone is trying to do their best, why treat defects in software as something evil? To paraphrase Scott Hanselman, “Most people are not nearly smart enough to be as evil as you act like they are.”</p>\n<h3 id=\"Most-Bugs-are-a-Specification-Problem\"><a href=\"#Most-Bugs-are-a-Specification-Problem\" class=\"headerlink\" title=\"Most Bugs are a Specification Problem\"></a>Most Bugs are a Specification Problem</h3><p>Weather you have a formal specification or an informal specification, my observation is that most “Bugs” that show up in code are a result of either 1) the specification being misunderstood or 2) the specification being incomplete.</p>\n<p>Yes, there are a few places where neither of those are true and the programmer clearly missed the mark.  But, even then, assuming they missed the mark rather than assuming the specification was unclear will go a long way in making the programmer more receptive to the fact that the code needs to be changed.  Just the fact that we call a defect in our programs a “Bug” reveals and colors what we think about who’s fault</p>\n<h2 id=\"What-Programmers-Can-Do\"><a href=\"#What-Programmers-Can-Do\" class=\"headerlink\" title=\"What Programmers Can Do\"></a>What Programmers Can Do</h2><h3 id=\"It’s-Not-Personal\"><a href=\"#It’s-Not-Personal\" class=\"headerlink\" title=\"It’s Not Personal\"></a>It’s Not Personal</h3><p>Listen gang.  Bugs are not a reflection of your personal character.  And even if someone thought it was, that doesn’t make it true.  At worse, it means you might have some stuff you still need to learn about how to program well.  OK.  We’ll never be perfect.  Think about this, while you are writing the code, your compiler, or runtime, tells you you’ve done something wrong quite frequently.  But as soon as a human tells you something similar, you take it personally?  That’s pretty wacked.</p>\n<p>Here are a few tips I’ve learned:</p>\n<ul>\n<li>Emotions are learned responses.  This means your negative response to bugs can be retrained.</li>\n<li>Just because someone says something about you, or disapproves of you personally, doesn’t mean they are right.</li>\n<li>Most criticism is only an opinion based on an expectation.</li>\n</ul>\n<p>If you can internalize these, you will be much more receptive to hearing that your code has a flaw.</p>\n<h3 id=\"Break-the-Spec-into-Tasks\"><a href=\"#Break-the-Spec-into-Tasks\" class=\"headerlink\" title=\"Break the Spec into Tasks\"></a>Break the Spec into Tasks</h3><p>One thing I’ve started doing recently that I’ve found to be a great help is that I’ve started breaking the specification I’ve been given down into the composite task that I’ll need to implement the specification.  How granular.  I aim for task that should take less than four hours.  By getting this granular, I’m able to accurately estimate how long it should take me to complete the specification, and I’m sure I’ve caught all of the tasks involved in completing the specification.</p>\n<p>You should track your time against your estimates so you can get a sense of how far off your gut is relative to reality.  This will improve your ability to estimate projects.</p>\n<p>By breaking down the project like this, you are more likely to see holes in the requirements before you even start coding.</p>\n<h3 id=\"Create-a-Test-Plan\"><a href=\"#Create-a-Test-Plan\" class=\"headerlink\" title=\"Create a Test Plan\"></a>Create a Test Plan</h3><p>The other thing I’ve started doing is that I’ve started writing out how I plan to test the specification once I’ve completed it.  I just write this out.  Once again, this helps me find holes in the requirement.  But this also forces me to start thinking of ways someone might use the code that would break it.  And that simple act of trying to break it in my mind prior to coding it, refines the spec, and makes my code more reliable.</p>\n<h3 id=\"Ask-for-a-Review\"><a href=\"#Ask-for-a-Review\" class=\"headerlink\" title=\"Ask for a Review\"></a>Ask for a Review</h3><p>Once you have your tasks and your test plan, ask the person who gave you the spec to review it.  “Does this look like it reflects what you’ve asked me to do?”  This does two things.  First, and most importantly, it ensures you understand what it is you are building.  But, it also enlists someone else in the responsibility of ensuring what you finally build is what should have been built.</p>\n<h2 id=\"What-QA-Can-Do\"><a href=\"#What-QA-Can-Do\" class=\"headerlink\" title=\"What QA Can Do\"></a>What QA Can Do</h2><h3 id=\"Don’t-Call-Them-Bugs\"><a href=\"#Don’t-Call-Them-Bugs\" class=\"headerlink\" title=\"Don’t Call Them Bugs\"></a>Don’t Call Them Bugs</h3><p>I remember reading a Louis L’amour book one where the basic plot was this wagon train going out west.  At the beginning of the trip they had all agreed that no “bad language” was allowed.  And then one day, someone used the word, “shit” to describe cow poop that was on the ground.  The group was in shock and he was reprimanded.  At that point I remember the line, “If a word makes it any different, why don’t we just call it pudding?” But you see, as I’ve already explained, a word DOES make a difference.</p>\n<p>The word I would prefer to use is “Specification Refinement” because, in the end, that is what they are.</p>\n<h3 id=\"Don’t-Write-Requirements\"><a href=\"#Don’t-Write-Requirements\" class=\"headerlink\" title=\"Don’t Write Requirements\"></a>Don’t Write Requirements</h3><p>One thing I’ve noticed happens quite frequently is that once QA has verified all of the items in the requirement, they start doing exploratory testing, as they should.  But, when they find something, they inadvertently start writing requirements.  It looks like this.</p>\n<p>“I did X, Y and Z.  I expected to get result 1 but instead got result 2.” Some of you are probably thinking, “What’s wrong with this?!” Well, why did you EXPECT to get result 1?  If the expectation was not listed in the requirement, you have no valid reason to expect anything.  Your expectation is just your opinion about what should happen based on previous experience.</p>\n<p>So, how to write up this problem instead? “I did X, Y and Z and 2 happened.  This doesn’t look right but I don’t see anything in the spec that says what should happen.”</p>\n<h3 id=\"Don’t-Assign-Bugs\"><a href=\"#Don’t-Assign-Bugs\" class=\"headerlink\" title=\"Don’t Assign Bugs\"></a>Don’t Assign Bugs</h3><p>This one is going to fly in the face of QA teams everywhere.  But remember, we are trying to find peace in what has become an antagonistic relationship.</p>\n<p>Remember how I said that programmers react emotionally to the fact that you found a bug?  Well, if you assign a bug to them and they get a notification about that bug in the middle of writing code for the current sprint, here is what is going to happen.  First, the email is going to interrupt them.  Second, they will have an emotional response to the bug report that could continue to derail them for the rest of the day.</p>\n<p>Instead, you should be assigning the bug to the project.  Assuming you are using Scrum and have a backlog, the issue should be put on the backlog for grooming.  Grooming would include figuring out who is responsible for the bug or who is responsible for finding out what the core issue is so we can assign the bug appropriately.</p>\n<p>One of the problems I’ve seen with assigning bugs to specific developers is that the bug is often assigned incorrectly.</p>\n<p>By assigning the bugs to the back log as specification refinements, they just become additional features and the sting associated with “Bugs” goes away.</p>\n<p>If you are using software that requires you to assign bugs to an individual, make that individual the Scrum Master, Product Owner, or Project Manager (if you aren’t doing Scrum).</p>\n<h2 id=\"Organizational-Changes\"><a href=\"#Organizational-Changes\" class=\"headerlink\" title=\"Organizational Changes\"></a>Organizational Changes</h2><p>Finally, I want to address organizational changes that you may need to make.  Hopefully, you are already doing this.  But my experience tells me otherwise.</p>\n<h3 id=\"Silos-Kill\"><a href=\"#Silos-Kill\" class=\"headerlink\" title=\"Silos Kill\"></a>Silos Kill</h3><p>Everywhere I go, QA is a separate department.  Why can’t QA be co-located with the developers?  Wouldn’t it make a lot more sense to have QA working with the developers to figure out a test plan so we can code for the plan rather than having the plan developed in isolation?  I get that exploratory testing might reveal additional issues, but certainly some of those issues can be revealed early by defining how the code is going to be explored.  Plus, making everyone part of the same team means they are all working toward the same goal.  No one gets offended that way.</p>\n<p>When one QA person found out I was writing unit tests, she asked, “What will be left for me to tests?”  Which I found to be an incredibly naïve way of thinking.  Wouldn’t you hope that you don’t find any problems with the code I am working on?  How is the fact that I’m testing a problem for QA?  Aren’t we all working on the same goal?</p>\n<h3 id=\"Central-Source-of-Truth\"><a href=\"#Central-Source-of-Truth\" class=\"headerlink\" title=\"Central Source of Truth\"></a>Central Source of Truth</h3><p>Another place that needs to be addressed related to silos – Another area that re-enforces and is a result of silos – is this habit of each group using their own project management software.</p>\n<p>In one organization I’ve worked at we used four different systems.  One system for version control (GitHub) another system for QA (HP Quality Center) a third system to manage requirements (which we only used minimally and instead had documents on a shared drive) and a forth system for managing our Kanban board (Jira).</p>\n<p>The frustrating thing is that 80% of what everyone needed to do could have been achieved by using GitHub.  But even if we needed to use separate systems for the actual artifacts, it seems to me that we could use one system for tracking the project instead of having it tracked three or four different ways.  That’s just craziness.</p>\n",
            "tags": [
                "project management",
                "best practices",
                "QA"
            ]
        },
        {
            "id": "http://davembush.github.com/how-to-estimate-software-projects-like-a-pro/",
            "url": "http://davembush.github.com/how-to-estimate-software-projects-like-a-pro/",
            "title": "How to Estimate Software Projects Like a Pro",
            "date_published": "2016-08-30T10:30:00.000Z",
            "content_html": "<p>We’ve all been there.  Either at the micro level or at the macro level.  Business wants to know, “How much is this going to cost me?”  And as software developers, we all know the answer is, “more than you were expecting.”  We also know that whatever number we give will probably be wrong for a number of reasons.  Chief among them is that no one really knows what they want until they see it.</p>\n<p>And yet, there has to be some way of providing business what they need and still allowing for unknowns.</p>\n<p>So what follows are a few tips on estimating that help you estimate software projects like a pro.</p>\n<figure>![](/uploads/2016/08/image-2.png \"How to Estimate Software Projects Like a Pro\") Photo via [Visualhunt](//visualhunt.com/photos/business/)</figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"You-Don’t-Know-What-You-Don’t-Know\"><a href=\"#You-Don’t-Know-What-You-Don’t-Know\" class=\"headerlink\" title=\"You Don’t Know What You Don’t Know\"></a>You Don’t Know What You Don’t Know</h2><p>This tends to be the most famous argument for not giving an estimate.  Or for giving an estimate that is all but meaningless.</p>\n<p>“My gut says this will take a month, so I’m going to say four months because I really have no idea.” Well, that might be a safe estimate, and you might be right.  But if the business is looking for a number to use for a budget, they are going to learn that you pad your estimates.  So, a better answer is, “Are you looking for a rough ballpark or are you basing your budget on this?” And if they say they need a somewhat accurate number, your answer should be, “I really don’t know enough about the project.  Could we break it down into its component parts?</p>\n<h2 id=\"Virtually-Walk-Through-the-Project\"><a href=\"#Virtually-Walk-Through-the-Project\" class=\"headerlink\" title=\"Virtually Walk Through the Project\"></a>Virtually Walk Through the Project</h2><p>This will work regardless of the project size and regardless of if it is just you or a team.</p>\n<p>Here’s what you need to do, once you’ve broken the project down into the component parts, ask yourself, “What is the next thing I would need to do to get this project moving?”  You write that down, come up with an estimate for how long that will take, and then ask yourself the question, “Assuming I’ve completed what I’ve listed so far, what is the next thing I need to do?”  And you just keep doing this until the project is (virtually) done.</p>\n<p>You want to be careful as you are doing this to:</p>\n<ol>\n<li><p>For estimating actual work at the programming level, make sure none of your tasks take more than 8 hours to complete.  I personally aim for 4 hours.  Even if you use story points instead of actual hours, I’m sure internally you have some idea of how many hours a story point represents for you.  Size the work accordingly.</p>\n</li>\n<li><p>For estimating at the more macro level, I recommend dividing the project into 2-man week chunks.  Basically a sprint.</p>\n</li>\n<li><p>Don’t forget the obvious</p>\n</li>\n<li><p>Setup time</p>\n</li>\n<li><p>Creating tests.</p>\n</li>\n<li><p>Bug fix time.</p>\n</li>\n<li><p>Broken dependencies</p>\n</li>\n</ol>\n<h2 id=\"Everything-takes-twice-as-long-as-you-think-it-will\"><a href=\"#Everything-takes-twice-as-long-as-you-think-it-will\" class=\"headerlink\" title=\"Everything takes twice as long as you think it will.\"></a>Everything takes twice as long as you think it will.</h2><p>This rule of thumb has served me well over the years.  But it isn’t a hard and fast rule.  It often depends on the client.  I switch clients frequently because I am a contract programmer.  If I’m new, I’ll provide estimates with the 2x multiple factored in.  But as I learn more about the people providing the requirements, I’ll tweak that factor appropriately.</p>\n<p>I had one product owner I worked with who I learned to provide a multiple of four to because I only heard half of what he was trying to communicate.  I’m not sure where the communication breakdown was, all I know is if I multiplied by four, I was much better at being able to manage his expectations.</p>\n<h2 id=\"Track-Everything\"><a href=\"#Track-Everything\" class=\"headerlink\" title=\"Track Everything\"></a>Track Everything</h2><p>Even if you implemented everything I’ve recommended, you are still likely to fail in the long term because you’ll never learn from your mistakes.</p>\n<p>So what might you track?  Well, at the personal level, you want to track how close your estimate was to reality.  Over time you’ll learn that you tend to be off by so much.  And as you learn to estimate and track, I would expect your estimates to account for more items so that your multiple gets closer to a factor of 1x than the 2x I recommended you to start with.</p>\n<p>At the more macro level, you want to track the team.  Please, don’t track individuals.  Let the individuals do that.  Provide training so they can get better.  But if you do the tracking for them, you’ll destroy moral.</p>\n<p>But you want to know, when the team says they can do X in a week, that probably means it is going to take a week and a half… or whatever it ends up taking.</p>\n<p>I’m working on a project now where, had I been the project manager, I would have doubled all the estimates I was given.  Oh well, they’ll find out soon enough.  Although I would have expected this particular PM to know better.</p>\n<p>You also want to track items you may have forgotten to put in your plan.  You’ll add this to your “estimation checklist” which I’ll discuss next.</p>\n<h2 id=\"Estimation-Checklist\"><a href=\"#Estimation-Checklist\" class=\"headerlink\" title=\"Estimation Checklist\"></a>Estimation Checklist</h2><p>You want to create a checklist that you can use to make sure you’ve covered everything that needs to be estimated.  Along with the items I included above, here are some others you might want to include:</p>\n<ol>\n<li>Database Refresh side effects – yes I know, each programmer SHOULD have their own copy of the database, but I’ve yet to work for an organization that does this.  Because we don’t have this on my current project, we’ve lost valuable morning time twice this week waiting for the database we are using to get updated.  At least we aren’t all working against the production database.</li>\n<li>Version Control Management – this includes branching, merging, pull request, and code reviews.</li>\n<li>Holidays and Vacations</li>\n<li>Any learning curves that must be mastered.</li>\n</ol>\n<h2 id=\"Management-Doesn’t-Like-the-Estimate\"><a href=\"#Management-Doesn’t-Like-the-Estimate\" class=\"headerlink\" title=\"Management Doesn’t Like the Estimate\"></a>Management Doesn’t Like the Estimate</h2><p>There have been a few times when the manager I’m working for doesn’t like the estimate I provide.  In my experience there are several reasons for this.</p>\n<p>First, and almost always, if I’m right, the project is going to take a lot longer than they expected, or longer than they’ve been told to do it in.</p>\n<p>Second, they are used to estimates that are half as long.  The problem isn’t that my estimates are wrong, but that their expectations have been set lower.</p>\n<p>What to do? Well, I take them to my list and show them where all the time is.  Because I can document where the time is going to be spent, I rarely have to do more than explain how I came to the estimate I did.</p>\n<p>If they still bulk, I simply have this conversation, me: “So, you think my estimates are high?” them: (yes).</p>\n<p>me: “Do your other programmers write tests for their code?”</p>\n<p>them: (no)</p>\n<p>me: “When you compare their time to the time I’ve said I’m going to take, do you account for bug fixes?”</p>\n<p>them: (no)</p>\n<p>me: “If you did account for the bug fixes, would their estimates be more or less accurate?”</p>\n<p>them: (less)</p>\n<p>me: “Do you believe the way I’ve proposed to complete this project will result in less bugs than you normally see?”</p>\n<p>Well, you get the point.  I’ve yet to have to have a conversation that went into that much detail.  And the more you track, the easier this conversation becomes because you can just say, “I’ve been tracking my estimates against reality now for N years and I’ve found that I normally am within X% of my estimate.</p>\n<h2 id=\"Tools\"><a href=\"#Tools\" class=\"headerlink\" title=\"Tools\"></a>Tools</h2><p>There are a couple of tools I really like for estimating.  The first one is the Mind Map.  If you aren’t familiar with Mind Mapping, it is a way of just getting your ideas down on paper without having to worry about the structure or the order.  All you concentrate on is relationships.  This is a great way of breaking a project down into the smallest possible units of work.</p>\n<p>Once you have a mind map of your tasks, you can put the individual tasks into a Kanban Board.  You want a board that can provide the ability to attach estimates to the tasks and will show you a burn down&#x2F;up chart based on how much work you’ve completed.</p>\n<p>For Mind Mapping, I currently use <a href=\"//www.mindmup.com\">Mind Mup</a>.</p>\n<p>For Kanban, I use <a href=\"//trello.com/\">Trello</a> with <a href=\"//chrome.google.com/webstore/detail/plus-for-trello-time-trac/gjjpophepkbhejnglcmkdnncmaanojkf?hl=en\">Plus For Trello</a>.</p>\n<p>I wish there was a tool that married the two ideas.  That way I could use Mind Mapping for Epics, Stories, and defining tasks and I could use a Kanban board for tracking work.</p>\n",
            "tags": [
                "project management",
                "estimating"
            ]
        },
        {
            "id": "http://davembush.github.com/10-reasons-projects-succeed/",
            "url": "http://davembush.github.com/10-reasons-projects-succeed/",
            "title": "10 Reasons Projects Succeed",
            "date_published": "2016-08-09T22:30:00.000Z",
            "content_html": "<p>We’ll get to Reasons Projects Succeed soon, but I need to do some setup work first.</p>\n<p>I’ve been thinking about starting an Open Source project for a while.  The only issue was; I didn’t have an idea for a project that didn’t already exist.  Now I do.  So, I’ve begun the process.</p>\n<p>The issue with starting a project like this is that I would much rather just start coding.  In fact, I would much rather not even make this Open Source.  But making it Open Source has forced me to face project management issues head on.</p>\n<p>I’ve been listening to enough podcast recently to know that putting something up on GitHub isn’t going to make a project Open Source any more than it will make it successful.  Therefor, I’ve decided to start the project as though it had a team of people already working on it.  It is a team of one for now.  But, one thing I’ve learned in life is that having the structure in place to handle a larger team now will not just benefit me in the future, but it will actually help my small little team of me today.</p>\n<p>I’ve started looking at other successful Open Source projects to see what they are doing and to determine what components of what they are doing I want to include in my project.  As I’ve gone through this exercise, the thought occurred to me, “If the organizations I’ve worked for implemented half of what these projects implement, the projects would have been run so much more efficiently and the projects that were in trouble may have avoided the trouble.” <figure><img src=\"/uploads/2016/07/image-5.png\" title=\"10 Reasons Projects Succeed\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/vuhung/8576985602/\">Nguyen Vu Hung (vuhung)</a> via <a href=\"//visualhunt.com\">Visual Hunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by/2.0/\">CC BY</a></figcaption></figure></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Clear-Mission-Statement\"><a href=\"#Clear-Mission-Statement\" class=\"headerlink\" title=\"Clear Mission Statement\"></a>Clear Mission Statement</h2><p>One of the most fundamental items that must exist in any project is a clear sense of what it is you are doing.  If you can’t explain what it is you are building in a couple of sentences, then how will you know when you are done?  How will you know you’ve succeeded? Once you’ve explained the summary, you might also want to go into some detail.  What makes this project different?  What problem does it solve?  What’s the short term vision?  Where might this project end up long term?  If there are other projects like this one, how is this one different? Why would anyone want to contribute to this tool?</p>\n<h2 id=\"Clear-Expectations\"><a href=\"#Clear-Expectations\" class=\"headerlink\" title=\"Clear Expectations\"></a>Clear Expectations</h2><p>The thing that strikes me most about well-run projects is that they set clear expectations for people who will contribute to the project.  Here’s just a few items that are typically covered:</p>\n<ul>\n<li>Where to go if you have questions.  This typically includes email addresses, web sites, and other communication channels.  In a corporate setting you might also include phone numbers.</li>\n<li>How to file a bug request.  Typically, you find this includes a line that says something about “steps to reproduce consistently”</li>\n<li>How to ask for and&#x2F;or add a new feature.  You’ll probably want to include something about making sure the feature gets accepted prior to working on it.</li>\n<li>What constitutes “done” for a pull request.  Tests, documentation, code quality, etc.</li>\n<li>Specific coding rules that need to be followed.  Even better if your style guide is automated in your build process and violations cause the build to fail.</li>\n</ul>\n<h2 id=\"Easy-Development-Environment\"><a href=\"#Easy-Development-Environment\" class=\"headerlink\" title=\"Easy Development Environment\"></a>Easy Development Environment</h2><p>This one drives me crazy.  In just about every organization I go to, setting up my development environment takes a day.  Some places it takes three days.  Simply because I don’t have rights, or the items I need are scatter here and there.</p>\n<p>Why not write the documentation for this, or better yet, take the time to write a script, that walks you through exactly how to get the development environment setup?  Life would be so much easier.</p>\n<p>And for places that already have this, when is the last time you verified that the instructions or script still worked?  Stuff changes and we barely notice until the new guy shows up.</p>\n<h2 id=\"Continuous-Integration-Server\"><a href=\"#Continuous-Integration-Server\" class=\"headerlink\" title=\"Continuous Integration Server\"></a>Continuous Integration Server</h2><p>It sounds crazy in this world, but how many places still don’t have a continuous integration server.  And yet the most successful OS projects do.  Correlation?</p>\n<h2 id=\"Unit-Tests\"><a href=\"#Unit-Tests\" class=\"headerlink\" title=\"Unit Tests\"></a>Unit Tests</h2><p>Testing.  We all hate it.  And here again, the best projects make sure there are test.  I’ve covered testing in multiple places before.  We’ll just leave this at, “You need tests!”</p>\n<h2 id=\"Application-Level-Tests\"><a href=\"#Application-Level-Tests\" class=\"headerlink\" title=\"Application Level Tests\"></a>Application Level Tests</h2><p>And if you are writing an application, you need application level tests.  At least a few to make sure everything works together.</p>\n<h2 id=\"Centralized-Communication\"><a href=\"#Centralized-Communication\" class=\"headerlink\" title=\"Centralized Communication\"></a>Centralized Communication</h2><p>It amazes me how many places still use email as the primary way of communicating.  What’s wrong with that?  Well, people get included who shouldn’t.  Don’t get included that should.  And finding the email when you need it is impossible.  Which version of the email has what you need anyhow? Most projects fail at the communication level.  There are tools for that.</p>\n<h2 id=\"Project-Management-Tools\"><a href=\"#Project-Management-Tools\" class=\"headerlink\" title=\"Project Management Tools\"></a>Project Management Tools</h2><p>Find a project management tool and use it.  Actually, find a project management tool that your team will use and use it.  There is a lot of crap out there.  Don’t let the sales literature pick your tool.  Try the tool.  I’ve finally been introduced to a VERY popular tool where I’m working now.  I can’t believe it is so popular because I’ve used tools that are SO much better.  Better yet, find a useable tool that doesn’t just integrate with other tools, but merges with other tools.  You shouldn’t have to leave GitHub to use your Kanban board, for example.</p>\n<h2 id=\"Swarms-vs-Silos\"><a href=\"#Swarms-vs-Silos\" class=\"headerlink\" title=\"Swarms vs Silos\"></a>Swarms vs Silos</h2><p>Here’s another places that drives me crazy.  Did you ever notice that in an Open Source project, the QA, Documentation and Coding all happen off of GitHub.  But in most organizations, those are all Silos?  What would happen if your QA, Documentation, and Coding people all worked out of the same space in your office.  In our situation, I have no idea if we even have documentation people.  We certainly don’t have QA people working WITH us daily.  And the programmers are even spread all over the place.  And we wonder why nothing gets done and we have communication problems.  We might as well work from home.  At least then there wouldn’t be an illusion that we were working together and we’d rely on collaboration tools more.</p>\n<h2 id=\"Opt-In\"><a href=\"#Opt-In\" class=\"headerlink\" title=\"Opt-In\"></a>Opt-In</h2><p>OK.  This one is going to scare the managers.  But what would happen if the team of programmers where you worked were able to choose what projects they worked on?  I know in some places this wouldn’t work because there is only one project.  But in larger organizations? In most places, you get hired for a gig and then you get assigned to some project.  In some cases, you get hired for one project and assigned to another.   So even the choice you thought you had, you don’t have.</p>\n<p>Here are some advantages to this:</p>\n<ol>\n<li>Poorly run projects would get abandoned.</li>\n<li>Projects with no viable reason would get abandoned.</li>\n<li>Programmers would work on things they enjoyed.</li>\n<li>Product owners would have to contribute.</li>\n</ol>\n",
            "tags": [
                "project management"
            ]
        },
        {
            "id": "http://davembush.github.com/technical-debt-is-inevitable/",
            "url": "http://davembush.github.com/technical-debt-is-inevitable/",
            "title": "Technical Debt Is Inevitable",
            "date_published": "2014-10-16T10:00:00.000Z",
            "content_html": "<p>Whoa there Dave.  What are you talking about?  Have you given up the fight? You who have preached the TDD religion.  You who’ve struggled to get organizations to adopt naming conventions, to use version control systems and to use project management software.  The same guy who has implemented continuous integration on his current project?  What’s this world coming to?</p>\n<span id=\"more\"></span>\n\n<p>No. Relax. I haven’t given up.  In fact it is precisely because technical debt is inevitable that we need to implement all of the above.</p>\n<h2 id=\"Danger\"><a href=\"#Danger\" class=\"headerlink\" title=\"Danger\"></a>Danger</h2><p>But there  is a danger in believing that if we were to implement all of the best practices in the book, or that could ever be devised, that technical debt would simply vanish.  And the sooner some of you realize this, the less stressed out you will be.</p>\n<p>You see, no matter how good of a programmer you are today, tomorrow you will be a better programmer.  That is true for all of us.  We are all doing as good of a job as we possibly can today.</p>\n<h2 id=\"A-Story\"><a href=\"#A-Story\" class=\"headerlink\" title=\"A Story\"></a>A Story</h2><p>This reminds me of a story I heard once.</p>\n<p>It seems there was this programmer who had to make a change to some code and, like we all do, the first thing he did was to try to wrap his head around the code he was looking at.  A few minutes into this common exercise, he starts exclaiming:</p>\n<ul>\n<li>Who wrote this code?</li>\n<li>This is the worst code I’ve ever seen.</li>\n<li>The guy who wrote this can’t even really call himself a programmer!</li>\n</ul>\n<p>And then, it got unusually quite in his cubicle.</p>\n<p>His friend in the next cube calls over the wall, “Hey John, you OK?”</p>\n<p>And John responds, “It’s my code.”</p>\n<p>Now, the reason this is a funny story… well, it is a funny story for me anyhow… is because this happens to us all of the time.</p>\n<p>I think I spent the first 5 years of my career looking at code I wrote six months ago and thinking, “What was I thinking when I wrote this?”</p>\n<p>Even today, 26 years in, I have code I wrote six months or more ago that I know I need to rewrite.  The only reason I haven’t yet is because I want to make sure I have a full test harness around it before I tweak it.</p>\n<h2 id=\"Here’s-the-point\"><a href=\"#Here’s-the-point\" class=\"headerlink\" title=\"Here’s the point.\"></a>Here’s the point.</h2><p>We are all getting better at what we do.  What we would do today isn’t what we would have done six months ago.  The person who wrote the code you are looking at was doing the best he could at the time.</p>\n<p>Therefore, we should just plan on code being “wrong.”</p>\n<p>This has two explicit implications to how you relate to your code and your co-workers.</p>\n<h3 id=\"Don’t-be-surprised-by-bad-code\"><a href=\"#Don’t-be-surprised-by-bad-code\" class=\"headerlink\" title=\"Don’t be surprised by bad code\"></a>Don’t be surprised by bad code</h3><p>First, you should not be surprised when you find bad code.  You should instead be shocked when you find well written code.  Since even you write bad code, you should be gracious when you find bad code that isn’t yours.  You don’t want to be the guy in the story  I just told.  You might have done the same thing today if you knew only what the person who wrote the code you are looking at knew at the time the code was written.</p>\n<h3 id=\"You-should-expect-that-your-code-will-be-broken-in-some-way\"><a href=\"#You-should-expect-that-your-code-will-be-broken-in-some-way\" class=\"headerlink\" title=\"You should expect that your code will be broken in some way.\"></a>You should expect that your code will be broken in some way.</h3><p>This has been probably the hardest thing for me to get control of.  I have, historically, been one to deny that my code has a bug.  I’ve taken it as a personal insult, or an assault on my character when someone finds a bug in my code. </p>\n<p>Until recently.</p>\n<p>Once I was able to internalize the fact that the person reporting the bug was not upset, that the only person who expected me to be perfect was me, and that being wrong was part of being human, I was able to calm down a bit.</p>\n<p>You see, none of us are all knowing.  Most of us program for what the code is supposed to do and don’t think about what it shouldn’t do (which is where most of the bugs occur).  The spoken&#x2F;written language is an imprecise communicator, even if you develop a dictionary for your project.  You’ll never get all of your terms defined.  You just don’t know what you don’t know.  And therefore there will be bugs.</p>\n<p>Maybe you’ll think, “I should have known that!”  Well, yes, maybe you SHOULD have.  But the fact is, you didn’t.</p>\n<p>When before I used to deny that the bug could even exist, my reaction now is, “Hmmm, wonder what’s going on there.  OK, well, put it in the issue tracker and I’ll get it fixed.”</p>\n<p>No drama.  No conflict.  No denial.  No blame.  Just deal with the issue.</p>\n<h2 id=\"This-is-what-it-means-to-be-Agile\"><a href=\"#This-is-what-it-means-to-be-Agile\" class=\"headerlink\" title=\"This is what it means to be Agile\"></a>This is what it means to be Agile</h2><p>And you see, this is the beauty of the Agile methodology.  Agile assumes we aren’t going to get it right the first time.  It assumes humans are poor communicators.  It assumes that programmers aren’t going to understand the problem the first time they try to come up with a solution.  It assumes technical debt is inevitable.</p>\n<p>Isn’t it time that you do too? Or am I the only one who has suffered with this problem?</p>\n",
            "tags": [
                "agile",
                "scrum",
                "technical debt"
            ]
        },
        {
            "id": "http://davembush.github.com/defining-%E2%80%9Cdone%E2%80%9D/",
            "url": "http://davembush.github.com/defining-%E2%80%9Cdone%E2%80%9D/",
            "title": "Defining “Done”",
            "date_published": "2014-07-10T17:00:00.000Z",
            "content_html": "<p>A couple of weeks ago, I mention <a href=\"/are-we-there-yet/\">“definition of done”</a> which many of my readers may have never heard of before. The phrase, “definition of done” comes out of the agile movement.  But there is no reason why it needs to stay there.  In fact, I would argue that many of the problems we have in the software industry are because most organizations only have one definition of done, “If we ship this today, can we make money?” When the Agile people talk about “definition of done” what they ultimately mean is, “if we were to ship this product today,and someone were to inspect what we’ve done, would we be embarrassed?” Definition of done, is about the quality of the code. When thinking about the definition of done, here are some items you might consider.</p>\n<span id=\"more\"></span>\n\n<h4 id=\"Does-the-code-meet-the-requirements-of-the-user-story\"><a href=\"#Does-the-code-meet-the-requirements-of-the-user-story\" class=\"headerlink\" title=\"Does the code meet the requirements of the user story?\"></a>Does the code meet the requirements of the user story?</h4><p>This is the most obvious.  Of course for this to work, you have to have a user story that is specific enough for you to answer this question.</p>\n<h4 id=\"Has-all-the-documentation-that-the-organization-requires-been-updated\"><a href=\"#Has-all-the-documentation-that-the-organization-requires-been-updated\" class=\"headerlink\" title=\"Has all the documentation that the organization requires been updated?\"></a>Has all the documentation that the organization requires been updated?</h4><p>This one can fall through the cracks easily because documentation is the least favorite activity of a programmer.  But, it isn’t necessarily a programmer activity.  Remember, an ideal team has all the skills it needs.  So, if you have a documentation requirement, be it an ISO requirement or simple end user documentation telling them how to use the software, your team should have someone on it that can produce this documentation.</p>\n<h4 id=\"Does-the-code-have-a-reasonable-level-of-unit-tests\"><a href=\"#Does-the-code-have-a-reasonable-level-of-unit-tests\" class=\"headerlink\" title=\"Does the code have a reasonable level of unit tests?\"></a>Does the code have a reasonable level of unit tests?</h4><p>I say “reasonable” here because the principle is high code coverage where we need it.  To try to aim for some metric will cause us to write tests where we don’t need them.  By combining a “reasonableness” level with code reviews, I think we can hit this target without setting an unrealistic arbitrary limit.</p>\n<h4 id=\"Do-all-of-the-unit-tests-succeed\"><a href=\"#Do-all-of-the-unit-tests-succeed\" class=\"headerlink\" title=\"Do all of the unit tests succeed?\"></a>Do all of the unit tests succeed?</h4><p>You’d think this one would be obvious.  You have tests, you should be running them every time the code changes.  But, I’ve seen situations where tests sit in version control and never get run. Run your tests!</p>\n<h4 id=\"Is-the-code-covered-by-system-level-tests\"><a href=\"#Is-the-code-covered-by-system-level-tests\" class=\"headerlink\" title=\"Is the code covered by system level tests?\"></a>Is the code covered by system level tests?</h4><p>Once again, this one should be obvious.  Just because you have unit tests, doesn’t mean the system works.  The main problem with the Federal Health Care web site that went live in the United States recently is because no one made sure all the parts worked together. And don’t leave this to manual testing.  There are many ways of testing at this level that you can automate.</p>\n<h4 id=\"Do-all-the-system-tests-succeed\"><a href=\"#Do-all-the-system-tests-succeed\" class=\"headerlink\" title=\"Do all the system tests succeed?\"></a>Do all the system tests succeed?</h4><p>Once again, run your tests.</p>\n<h4 id=\"Has-the-code-been-reviewed-by-one-other-programmer\"><a href=\"#Has-the-code-been-reviewed-by-one-other-programmer\" class=\"headerlink\" title=\"Has the code been reviewed by one other programmer?\"></a>Has the code been reviewed by one other programmer?</h4><p>If there isn’t at least one other programmer on your team that understands what you’ve done, you aren’t done.  I could, and probably will, write a whole post about this sometime.</p>\n<h4 id=\"Have-coding-conventions-been-observed-throughout-the-code\"><a href=\"#Have-coding-conventions-been-observed-throughout-the-code\" class=\"headerlink\" title=\"Have coding conventions been observed throughout the code?\"></a>Have coding conventions been observed throughout the code?</h4><p>There are a number of tools out there  that check for coding conventions.  For CSharp, I like ReSharper.  JsHint is what I prefer for JavaScript.  There is  FxCop built into Visual Studio. Pick a standard, find a way to automatically verify the code meets the standard, and make sure nothing gets put into version control that doesn’t meet the standard!</p>\n<h4 id=\"Has-the-code-passed-some-level-of-complexity-threshold\"><a href=\"#Has-the-code-passed-some-level-of-complexity-threshold\" class=\"headerlink\" title=\"Has the code passed some level of complexity threshold?\"></a>Has the code passed some level of complexity threshold?</h4><p>I’ve talked about <a href=\"/avoiding-code-complexity/\">code complexity</a> before.  Just go read that post.</p>\n<h4 id=\"Is-there-any-known-code-duplication\"><a href=\"#Is-there-any-known-code-duplication\" class=\"headerlink\" title=\"Is there any known code duplication?\"></a>Is there any known code duplication?</h4><p>Again, there are tools for this.  Find one and use it.</p>\n<h4 id=\"When-you-compile-are-there-warnings\"><a href=\"#When-you-compile-are-there-warnings\" class=\"headerlink\" title=\"When you compile, are there warnings?\"></a>When you compile, are there warnings?</h4><p><a href=\"/treat-warnings-as-errors/\">Compiling without warnings</a> is something else I’ve already talked about.  </p>\n<h2 id=\"Other-Places-Talking-About-“Definition-of-Done”\"><a href=\"#Other-Places-Talking-About-“Definition-of-Done”\" class=\"headerlink\" title=\"Other Places Talking About “Definition of Done”\"></a>Other Places Talking About “Definition of Done”</h2><ul>\n<li><a href=\"//www.scrumalliance.org/community/articles/2008/september/what-is-definition-of-done-(dod)\">What Is Definition of Done (Scrum Alliance)</a></li>\n<li><a href=\"//www.mountaingoatsoftware.com/blog/clarifying-the-relationship-between-definition-of-done-and-conditions-of-sa\">Clarifying Definition of Done (Mountain Goat Software)</a></li>\n<li><a href=\"//blogs.atlassian.com/2013/10/8-steps-to-a-definition-of-done-in-jira/\">8 Steps To Definition of Done in JIRA (Atlassian Blog)</a></li>\n<li><a href=\"//www.mitchlacey.com/intro-to-agile/scrum/definition-of-done\">Definition of Done Creation (Mitch Lacey &amp; Associates)</a></li>\n</ul>\n",
            "tags": [
                "programming",
                "definition of done",
                "DoD"
            ]
        },
        {
            "id": "http://davembush.github.com/are-we-there-yet/",
            "url": "http://davembush.github.com/are-we-there-yet/",
            "title": "Are We There Yet?",
            "date_published": "2014-06-26T17:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/06/StoryPoints.png\" alt=\"StoryPoints\" title=\"StoryPoints\">When my kids were young, my wife introduced a concept for this question that she got from her family that is so brilliant in its simplicity that I wonder that this isn’t common knowledge with all parents.  Something they should tell you during Lamaze class. When the kids asked, “Are we there yet?” Which they did very infrequently, we would answer, “Just a few more units.” If you think about it, it is just about as helpful as any other answer we could have given them, “Just a few more hours.”, “Just a few more miles.”, “Sure, get out of the car.” (While continuing to drive the car down the road.) Or “Does it look like we are there yet?” What does the child want to know?  Nothing, they are just expressing their displeasure at still being in the car.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Story-Points\"><a href=\"#Story-Points\" class=\"headerlink\" title=\"Story Points\"></a>Story Points</h2><p>Story Points remind me of “Just a few more units.”  While “Just a few more units,” had no real meaning, Story Points do have meaning, but they don’t answer the question, “how long until we are done?”  Story Points don’t represent time, they represent difficulty.  Given two stories, a story with 2 story points should be twice as difficult as a story with 1 story point assuming that everything is as it should be.  It does not take into account that the code might have technical debt that we need to deal with prior to actually implementing the story.  It doesn’t take into account which programmer is going to do the work.  It just says, “This story is this much easier or harder than that story.” How long will it take to complete the story?  “Just a few more units.” “But wait!”  You say, “How can anyone plan a project if they don’t know how long something is going to take? Well, I have two answers to that question.</p>\n<h2 id=\"How-Accurately-Do-You-Estimate\"><a href=\"#How-Accurately-Do-You-Estimate\" class=\"headerlink\" title=\"How Accurately Do You Estimate?\"></a>How Accurately Do You Estimate?</h2><p>First, if you look at how well you estimate projects now.  How’s that working for you? If you are a programmer, you might say, “Yeah, we hit the estimate every time.”  But do you?  I would be willing to bet that when you estimated a project, you had in mind that you would do a certain number of things.</p>\n<ul>\n<li>Collect the requirements</li>\n<li>Write a nice user interface</li>\n<li>Write clean backend code</li>\n<li>Have the application tested completely.</li>\n</ul>\n<p>What I suspect really happened is that you:</p>\n<ul>\n<li>Collect enough requirements to get going and made up a significant number of the rest.</li>\n<li>Wrote an adequate user interface</li>\n<li>Clean code?  No, you were just glad to get it all working.</li>\n<li>Testing?  We don’t have time for testing.</li>\n</ul>\n<p>So you didn’t meet your estimate, you adjusted you scope so you could meet a target date.</p>\n<h2 id=\"Estimates-Are-More-Accurate-Over-Time\"><a href=\"#Estimates-Are-More-Accurate-Over-Time\" class=\"headerlink\" title=\"Estimates Are More Accurate Over Time\"></a>Estimates Are More Accurate Over Time</h2><p>Now, if you use story points AND you concentrate on a well-established definition of done for each story.  The programmers can concentrate on writing quality code, and over time, management will learn how long a story point is on average. No, you’ll never know how long a story point will take for any one story.  But you will know that if you look at all of the stories we’ve done so far, a story point equals X amount of time. By doing this we achieve two major milestones.  First, we move the decisions about what to do or not do up to the management level.  Management will be able to see quickly that if we continue at the rate we are going, we will have a releasable product by such and such a date.  Second, the programmers can concentrate on writing good code rather than writing code that is simply adequate for today but ends up slowing them down in the future because they were too busy concentrating on delivering “on time.”</p>\n",
            "tags": [
                "scrum",
                "estimating",
                "story points"
            ]
        }
    ]
}