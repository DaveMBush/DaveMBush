{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"routing\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/how-to-implement-angular-routing/",
            "url": "http://davembush.github.com/how-to-implement-angular-routing/",
            "title": "How to Implement Angular Routing",
            "date_published": "2017-07-18T10:30:23.000Z",
            "content_html": "<p>In the old world where all of our pages were on the server and every change on the client side required a full round trip to the server, each page was a unique URL on the server.  In the SPA world, we only load one “Page” from the server and the client takes care of making it look like we have moved from one page to another. </p>\n<p>When done well, we can create pages that reuse existing content on the screen causing a minimal screen refresh while still allowing the user to link to a specific “Page” in our application. </p>\n<p>These “Pages” are called “Routes”  As in, here is the route to some code I want to execute. <figure><img src=\"/uploads/2017/07/2017-07-18.png\" title=\"How to Implement Angular 2+ Routing\"> Photo via <a href=\"//visualhunt.com/re/9589c4\">Visual Hunt</a></figure></p>\n<span id=\"more\"></span>  Sounds pretty cool.  But there is a down side that shows up every time someone tries to do this for the first time.  You won’t see this problem until the first time you try to deploy your code because the development server handles this issue for you. \n\n<p>The problem is this.  When a server receives a request from the browser, it tries to find that file on the server.  If it doesn’t exist, the server returns a 404 error.  File not found. </p>\n<p>Most servers provide ways of circumventing this issue by providing rules.  Essentially, you write a server rule that says, “If the browser ask for a file that doesn’t exist, send them back index.html instead.”  You may need to provide exceptions or otherwise refine the rule if your server is also rerouting other traffic. If you are running on an IIS server, <a href=\"/asp-net-angular-js-html5mode/\">I wrote instructions for how to take care of this issue</a> for AngularJS (1.x).  The instructions work for any client side framework that implements routing. </p>\n<p>Assuming you have that end of things working correctly, here are the steps to get basic routing working in your Angular application.</p>\n<h2 id=\"Define-Your-Routes\"><a href=\"#Define-Your-Routes\" class=\"headerlink\" title=\"Define Your Routes\"></a>Define Your Routes</h2><p>While we could easily define our routes in app.module.ts, the code we write will be much easier to maintain if we create a separate module file named app-routes.module.ts.  So to start, create an app-routes.module.ts file right next to your app.module.ts file.  You can do this with the Angular CLI by typing the following in the command line from within the src&#x2F;app directory: </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng g module app-routes</span><br></pre></td></tr></table></figure>\n\n<p>When you create a module with the Angular CLI, it will put it in a sub-directory.  In this case, it created an app-routes sub-directory.  We want it next to our app.module.ts file.  So, now we need to move the module up a directory and remove the app-routes directory. </p>\n<p>Open up the file, it has some stuff in it that we don’t need.  Remove the CommonModule references and the declarations section of the @NgModule decorator. </p>\n<p>In this new file, you will create an empty Routes array, called routes and decorate the class with @NgModule </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppRoutesModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>You need to also import Routes and while you are doing that, you might as well import RouterModule because you are going to need that soon too. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">RouterModule</span>, <span class=\"title class_\">Routes</span>&#125; <span class=\"keyword\">from</span> ‘<span class=\"meta\">@anguler</span>/router’; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppRoutesModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Next, in your app.modules.ts file, import AppRoutesModule using both the TypeScript import and as part of the imports section of the @NgModule decorator.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">AppRoutesModule</span>&#125; <span class=\"keyword\">from</span> ‘./app-routes.<span class=\"property\">module</span>’;</span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  …,</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">  …,</span><br><span class=\"line\">  <span class=\"title class_\">AppRoutesModule</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  …</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>We really haven’t done anything useful yet, we’ve just setup some boilerplate code that will compile so we won’t have to think about it any more. </p>\n<p>Now, back to the app-routes.module.ts file. </p>\n<p>Each element in our Routes array defines a specific route in our system relative to the parent route it is a part of.  At the top level the parent route would be the root of the application. </p>\n<p>Here are the properties that are available to us:</p>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>The path property allows us to specify what path, or URL, will load this route.  If you want the component to load for any path, use ‘<strong>’ as the value.  If you want the component to load for the root element, use ‘’ for the path and specify pathMatch: ‘full’ as another property.  You can also use the value ‘</strong>’ to mean, “match anything.”  We typically use ** to match what would typically be thought of as 404 errors.  For this to work correctly, it should be the last element in your top most route definition.</p>\n<h3 id=\"pathMatch\"><a href=\"#pathMatch\" class=\"headerlink\" title=\"pathMatch\"></a>pathMatch</h3><p>As we’ve already mentioned, pathMatch should be ‘full’ to match ‘’ as the exact path.  But you can also give this value ‘prefix’ to tell it to match any path that starts with the value.  You only need to specify this value if you want to use ‘full’. </p>\n<p>It should also be noted that this value only evaluates the part of the path you are in.  If you use this in a child path, it won’t match the whole path, but only the part that is in the child.</p>\n<h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><p>Component specifies what component should get loaded when the path is matched.</p>\n<h3 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"children\"></a>children</h3><p>The children property allows us to specify an array of child paths.</p>\n<h2 id=\"Route-Components\"><a href=\"#Route-Components\" class=\"headerlink\" title=\"Route Components\"></a>Route Components</h2><p>Since our routes will need components, let’s start by creating several components so that we can illustrate routing. </p>\n<p>But first, a short word about how we organize our code. </p>\n<p>In many demos online, the tendency is to put all of our components right under the app directory.  But, in larger applications, I’ve found that it makes a lot more sense to create a route directory under the app directory that we place each of our routes in. </p>\n<p>Now, you might think that we would want to place our child routes as child directories under the routes they are a part of, but the problem with this is that we often have child components in our routes.  How do we know which directory represents a child route and which represents a child component? </p>\n<p>No.  </p>\n<p>What we really want to do is place even the components that represent child routes right under our routes directory.  So, say we have a Page1 route and there is a SubPage route that is a child of Page1.  To make it clear, we put SubPage in a directory named page1.sub-page. </p>\n<p>As for components that are common to multiple pages, we place those in a components directory which is right under the app directory.  This keeps our directories well organized and the code neatly organized as well. </p>\n<p>The next obvious thing that we need to do is that we need to create a routes directory.  Do that now. </p>\n<p>Now, at the command line, inside the new routes directory, execute the following Angular CLI commands </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng g component page1</span><br><span class=\"line\">ng g component page2</span><br><span class=\"line\">ng g component page1-subpage</span><br></pre></td></tr></table></figure>\n\n<p>As you executed each command, it should have created a directory for each component with the corresponding css, html, ts and spec files.  Then it updated the app.module.ts file for you so that the components are available for use in the system. </p>\n<p>You may also notice that we created the component as page1-subpage instead of page1.subpage.  The reason for this is that the CLI doesn’t like period separation of file names.  Now, the next thing we are going to do is change the directory name to page1.subpage.  You will also need to change the TypeScript import line that references this directory in your app.module.ts file. </p>\n<p>Now that we have components to page to, let’s create our route definitions.  Back to the Routes array in our app-routes.module.ts file. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: ‘page1’,</span><br><span class=\"line\">  <span class=\"attr\">children</span>: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: ‘’,</span><br><span class=\"line\">    <span class=\"attr\">pathMatch</span>: ‘full’,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: ‘<span class=\"title class_\">Page1Component</span>’ &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: ‘subpage’,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"title class_\">Page1SubpageComponent</span></span><br><span class=\"line\">  &#125;]&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: ‘page2’,</span><br><span class=\"line\">  <span class=\"attr\">component</span>: <span class=\"title class_\">Page2Component</span></span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>The first definition may look a bit odd.  We are setting up a route to page1, but the route is the children.  Then in the children we define a route to ‘’.  This is where the Page1Component is specified as the component we want to load. </p>\n<p>You will also note that we specified <code>pathMatch: &#39;full&#39;</code> for the Page1Component.  This is because we only want this component to be loaded when the child path is empty. </p>\n<p>Using this definition, everything loads into the top level router-outlet.  If we placed Page1Component at the same level as we defined the page1 path, then Angular would expect to have a router-outlet in Page1Component where Pag1SubpageComponent would be loaded. </p>\n<p>Needless to say, you need to be careful how you define your routes. </p>\n<p>Next, you will need to import the three components using the TypeScript import statement. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Page1Component</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./routes/page1/page1.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Page2Component</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./routes/page2/page2.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Page1SubpageComponent</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./routes/page1.subpage/page1-subpage.component&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Now that everything is defined, we just need to tell Angular where we want these components to show up.  For right now, open the app.component.html file and remove everything that is there and add the router-outlet component. </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-outlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Now, <code>router-outlet</code> is a component that is defined in the RouterModule, so we need to import that in the imports section of our AppRoutesModule.  But we don’t just import the RouterModule, we use RouterModule.forRoot() and pass in the route array we just defined into forRoot(). </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [<span class=\"title class_\">RouterModule</span>.<span class=\"title function_\">forRoot</span>(routes)],</span><br><span class=\"line\">  <span class=\"attr\">exports</span>: [<span class=\"title class_\">RouterModule</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppRoutesModule</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>There is one final tweak that we need to make to our route definition.  Right now, if you go to the root of the application, there isn’t a component defined for it.  To fix this, we are going to add the following definition at the top of  our routes: </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  path<span class=\"punctuation\">:</span> &#x27;&#x27;<span class=\"punctuation\">,</span></span><br><span class=\"line\">  redirectTo<span class=\"punctuation\">:</span> &#x27;page1&#x27;<span class=\"punctuation\">,</span></span><br><span class=\"line\">  pathMatch<span class=\"punctuation\">:</span> &#x27;full&#x27;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure>\n\n<p>You need <code>pathMatch: &#39;full&#39;</code> to tell the router to only match this rule when the path is ‘’ exactly, just like we did with the Page1Component in the children list.  Otherwise, it will match everything. </p>\n<p>The <code>redirectTo: &#39;page1&#39;</code> part tells it to redirect to the page1 path when this rule is true.</p>\n<h2 id=\"Lazy-Loading\"><a href=\"#Lazy-Loading\" class=\"headerlink\" title=\"Lazy Loading\"></a>Lazy Loading</h2><p>I realize that I still need to show you how to navigate to routes in your application, but first let’s look at lazy loading the routes. </p>\n<p>In the past, when building a Single Page Application, the custom was to load all of the JavaScript code we needed for the page up front.  But, if you have multiple pages in your application, some of those may never be needed by your user.  So, what are we doing loading stuff that will never get used? </p>\n<p>No, it is better to load only what we need when we need it.  While it might take longer if you totaled up each load, the user perceives the experience as faster.  Therefore what we want to do is to make each of our pages load as we need them. </p>\n<p>To do this, we need to create a module for each of the components that represent our top level routes.  We want to import modules and services into the module that is closest to where we need them.  This is why.  By only importing things where we need them, Angular can create the smallest package necessary all up and down the dependency tree. </p>\n<p>To make things easy and to do them the way you would have done them if you had done it this way to begin with, let’s delete all of the sub-directories under routes.  It’s OK.  We aren’t losing any work that we can’t quickly get back.  We haven’t added any code to these routes yet. </p>\n<p>At the command line, navigate to the routes directory and then type in the following Angular-CLI commands:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng g module page1</span><br><span class=\"line\">ng g component page1</span><br><span class=\"line\">ng g module page1-subpage</span><br><span class=\"line\">ng g component page1-subpage</span><br><span class=\"line\">ng g module page2</span><br><span class=\"line\">ng g component page2</span><br></pre></td></tr></table></figure>\n\n<p>And then, just like we did the first time, rename the page1-subpage directory to page1.subpage. </p>\n<p>Now, go to the app.modules.ts file and remove the references to the Page1, Page2, and Page1Subpage components anywhere you see them. </p>\n<p>Do the same thing in the app-routes.module.ts file. </p>\n<p>Now, the way we define our routes changes slightly.  We will still need the redirect route, but everything else changes. </p>\n<p>The key to making this work is the property <code>loadChildren</code>, which is a string in the format of: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;pathToModule#ModuleClassName&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>We’ll work from the top down.  Change the routes array in app-routes.module.ts to look like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">redirectTo</span>: <span class=\"string\">&#x27;page1&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">pathMatch</span>: <span class=\"string\">&#x27;full&#x27;</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;page1&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">loadChildren</span>: <span class=\"string\">&#x27;./routes/page1/page1.module#Page1Module&#x27;</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;page2&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">loadChildren</span>: <span class=\"string\">&#x27;./routes/page2/page2.module#Page2Module&#x27;</span></span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>When we try to access something from page1, it will load the Page1Module and try to resolve it from there.  When we try to access something from page2, it will load the Page2Module.  Both of these happen during run time. </p>\n<p>Next, go to page1.module.ts and, import RouterModule and add the following to the imports section of @NgModule.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">RouterModule</span>.<span class=\"title function_\">forChild</span>([&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">pathMatch</span>: <span class=\"string\">&#x27;full&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">component</span>: <span class=\"title class_\">Page1Component</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;subpage&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">loadChildren</span>: ‘../page1.<span class=\"property\">subpage</span>/page1-subpage.<span class=\"property\">module</span>#<span class=\"title class_\">Page1SubpageModule</span>’</span><br><span class=\"line\">&#125;]),</span><br></pre></td></tr></table></figure>\n\n<p>Next move over to page2 and do something similar.  Since page2 doesn’t have a sub-route, you only need, one route. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">RouterModule</span>.<span class=\"title function_\">forChild</span>([&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">pathMatch</span>: <span class=\"string\">&#x27;full&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">component</span>: <span class=\"title class_\">Page2Component</span></span><br><span class=\"line\">&#125;]),</span><br></pre></td></tr></table></figure>\n\n<p>And again, similarly for page1-subpage. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">RouterModule</span>.<span class=\"title function_\">forChild</span>([&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">pathMatch</span>: <span class=\"string\">&#x27;full&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">component</span>: <span class=\"title class_\">Page1SubpageComponent</span></span><br><span class=\"line\">&#125;]),</span><br></pre></td></tr></table></figure>\n\n<p>If you haven’t already, move your command-line prompt back to the root of the project and type</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n\n<p>To start the server and compile your code.  If everything compiles, you should see 3 chunk files along with the other files we saw when we compiled the code without lazy loading. One each for each of the routes. </p>\n<p>Run the app in your browser now to make sure it works correctly. </p>\n<p>See how easy that was?  It isn’t really that much harder than specifying the routes like we did the first time, but we get huge benefits in performance.</p>\n<h2 id=\"Passing-Parameters\"><a href=\"#Passing-Parameters\" class=\"headerlink\" title=\"Passing Parameters\"></a>Passing Parameters</h2><p>The last thing you need to know about is how to pass parameters.  You would normally do this when you are coming from an existing list of items.  Each item has some sort of unique identifier.  We click some link and that takes us to another page to show details or to edit the content.  For our purposes here, it doesn’t matter. </p>\n<p>To specify that a route takes a parameter, use colon notation: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">path</span>: <span class=\"string\">&#x27;detail/:id&#x27;</span> </span><br></pre></td></tr></table></figure>\n\n<p>Angular knows it is a parameter when you use a URL to get to it because of the location.</p>\n<h2 id=\"Retrieving-Parameters\"><a href=\"#Retrieving-Parameters\" class=\"headerlink\" title=\"Retrieving Parameters\"></a>Retrieving Parameters</h2><p>Let’s say you have a component that represents a route with a parameter.  For that to be useful, you’ll need to pull the parameter out of the route information. </p>\n<p>To do this, you’ll need to inject <code>ActivatedRoute</code> into the component.  Then when you need the parameter(s) you can use: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route.<span class=\"property\">params</span>.<span class=\"title function_\">take</span>(<span class=\"number\">1</span>).<span class=\"title function_\">subscribe</span>(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"params\">params</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// Use params[&#x27;id&#x27;], where ‘id’ is the name</span></span><br><span class=\"line\">  <span class=\"comment\">// we gave the parameter in the path.</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Route-Navigation\"><a href=\"#Route-Navigation\" class=\"headerlink\" title=\"Route Navigation\"></a>Route Navigation</h2><p>Now that we have routes in place, we need to discuss how to navigate from one route to another.  The temptation, having just used URLs to go from one to the other, would be to use hyperlinks and put the information in the href attribute. </p>\n<p>No doubt, you could probably get that to work, but the main problem with using that method is that there is no safeguards to make sure that the URL you use to navigate when you are developing will work when you move the site to another environment. </p>\n<p>The reason for this is that we have to set the base href for the site.  During development this is normally ‘&#x2F;’.  But when you go to production, it could be some sub directory. </p>\n<p>Also, because of this base href, every page&#x2F;route we land on is still relative to that base.  This means that every route we want to navigate to would have to be hard wired to the base of the site, and again, that’s assuming that the site will always be in the same relative location when it is deployed. </p>\n<p>Now, if we can’t using a regular URL to navigate, what do we use instead?</p>\n<h3 id=\"routerLink\"><a href=\"#routerLink\" class=\"headerlink\" title=\"routerLink\"></a>routerLink</h3><p>You use the routeLink directive added to your anchor tag.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">&quot;[&#x27;/page1&#x27;]&quot;</span>&gt;</span>go here<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>This may look a little different from what you expected, so let’s break this down. </p>\n<p>The routerLink directive takes an array.  Since we can’t pass an array as a string, the only way we can pass it is by evaluating it at run time.  Remember, the square bracket syntax is an indication to the Angular compiler that what we are assigning is something that should be evaluated.  Typically this would be pointing to a function or variable in our TypeScript code.  In this case, we are pointing to a literal array.  Everything between the opening and closing quotes is JavaScript. </p>\n<p>As for the actual parameter, the string in the single element array works much like you would use a URL.  The forward slash says to start at the root of the web application (instead of the root of the domain like a URL would.)  And the page1 is the route we’ve already defined.  If you leave the forward slash off, it is relative to the current route. </p>\n<p>But what about passing parameters? </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">&quot;[&#x27;/page1&#x27;, someVariable]&quot;</span>&gt;</span>go here<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Each comma delimited value represents a segment of your route.</p>\n<h3 id=\"Router-navigate\"><a href=\"#Router-navigate\" class=\"headerlink\" title=\"Router.navigate()\"></a>Router.navigate()</h3><p>The other way you might want to cause navigation to a page to occur is by using the navigate() method hanging off the Router class.  Using dependency injection, you inject the Router into the class that needs to use it and then use that instance to call navigate().  The parameter you pass in looks very similar to what you used for routerLink. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.<span class=\"title function_\">navigate</span>(‘/page1’,someVariable);</span><br></pre></td></tr></table></figure>\n\n<p>Yes, both routerLink and Router.navigate() both support URL like references using ‘.&#x2F;path’ or ‘..&#x2F;path’.</p>\n<h2 id=\"Where-Am-I-Now\"><a href=\"#Where-Am-I-Now\" class=\"headerlink\" title=\"Where Am I Now?\"></a>Where Am I Now?</h2><p>The last part of routing you will commonly need to know about is detecting what the current route is.  Once again this will require you to inject the Router object into the component that needs the information.  Once you have the router object, you can use code like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.<span class=\"property\">routerState</span>.<span class=\"property\">snapshot</span>.<span class=\"property\">url</span>;</span><br></pre></td></tr></table></figure>\n\n<p>This will get the current route url.  I normally grap this as part of listening for the router’s NavigationEnd. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">router</span>.<span class=\"property\">events</span></span><br><span class=\"line\">  .<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg <span class=\"keyword\">instanceof</span> <span class=\"title class_\">NavigationEnd</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selectedTab</span> = router.<span class=\"property\">routerState</span>.<span class=\"property\">snapshot</span>.<span class=\"property\">url</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">selectedTab</span>;</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Guards\"><a href=\"#Guards\" class=\"headerlink\" title=\"Guards\"></a>Guards</h2><p>Guards control access to our routes.  What happens if you have a route that only certain people should have access to.  Like an admin page.  Sure, you could leave the link off so no one can click the link to get to the page, but that doesn’t prevent someone from pasting the link to the forbidden page into the address bar of the browser and getting there anyhow. </p>\n<p>In Angular, we have four kinds of guards and two ways of creating them. </p>\n<p>The four types of guards are:</p>\n<ul>\n<li>CanActivate</li>\n<li>CanActivateChild</li>\n<li>CanDeactivate</li>\n<li>CanLoad</li>\n</ul>\n<p>If you follow my advice and always lazy load your routes, than the two you will most often use are CanLoad and CanDeactivate.  CanLoad provides rules for lazy loading a module.  CanDeactive provides rules for leaving a route. </p>\n<p>If you decide to bundle routes together, then you may also need CanActivate and CanActivateChild.  CanActivate is exactly what it sounds like.  Can I activate this route?  CanActivateChild would go on a route definition that has a children’s collection.  This rule determines if I can activate the children. </p>\n<p>To use Guards in our application, the first thing we need to do is to define them.  The easiest way to define them is as a function that returns a boolean value, a boolean Observable, or a boolean Promise.  For our purposes here, we will just return a boolean value.  But when you have some asynchronous call you need to make to determine if we should return true or false, you’ll want to return an Observable or a Promise.  I favor Observables. </p>\n<p>The definition for a Guard rule looks like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">provide</span>: <span class=\"string\">&#x27;ruleNameHere&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">useValue</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Then, to use the rule, you assign the appropriate rule the name of the rule. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;page1&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">canLoad</span>: [<span class=\"string\">&#x27;ruleNameHere&#x27;</span>],</span><br><span class=\"line\">  <span class=\"attr\">loadChildren</span>: <span class=\"string\">&#x27;./routes/page1/page1.module#Page1Module&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Notice that canLoad, as well as the other guard properties, takes an array.  This allows you to apply multiple rules to a route. </p>\n<p>The other way of defining a route is as a class that implements an interface, or multiple interfaces that include CanActivate, CanActivateChild, CanDeactivate, and CanLoad.  You them implement the corresponding functions in your class. </p>\n<p>Now, to include the rule you use the Class rather than a string: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;page1&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">canLoad</span>: [<span class=\"title class_\">RuleClassHere</span>],</span><br><span class=\"line\">  <span class=\"attr\">loadChildren</span>: <span class=\"string\">&#x27;./routes/page1/page1.module#Page1Module&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"But-wait-there’s-more-…\"><a href=\"#But-wait-there’s-more-…\" class=\"headerlink\" title=\"But wait, there’s more …\"></a>But wait, there’s more …</h2><p>Believe it or not, there is even more to routing than we’ve discussed here.  But we’ll leave that for another day or this post will turn into a <a href=\"https://davembush.github.io/get-started-with-angular/\">book</a>. </p>\n",
            "tags": [
                "angular",
                "routing"
            ]
        },
        {
            "id": "http://davembush.github.com/adding-client-side-routing-to-angular-2/",
            "url": "http://davembush.github.com/adding-client-side-routing-to-angular-2/",
            "title": "Adding Client Side Routing to Angular 2",
            "date_published": "2016-11-29T12:30:00.000Z",
            "content_html": "<p>Over the last several Angular 2 posts, we’ve been building up our application bit by bit and examining the various features of Angular 2 along the way using the Angular CLI where that makes sense and modifying it along the way. So far, routing is an area that the Angular CLI does not yet support and so, when you want to use routing in your Angular 2 application, you’ll need to wire most of it in by hand. Now, the routing engine has changed several times during the development of Angular 2. And I know you’re wondering which version of the router this article is going to be talking about. So, to be clear, this article was written using the Angular CLI version 1.0.0-beta.21 and Router version 3.2.1.</p>\n<figure>![](/uploads/2016/11/image-4.png \"Adding Client Side Routing to Angular 2\")<figcaption>Photo credit: [xomiele](//www.flickr.com/photos/xomiele/6759264721/) via [Visualhunt](//visualhunt.com/photos/snow/) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"What-is-Routing\"><a href=\"#What-is-Routing\" class=\"headerlink\" title=\"What is Routing?\"></a>What is Routing?</h2><p>If you are new to developing Single Page Application (SPAs) you might wonder what Routing is. You might be surprised to find out that you already know what routing is, but you’ve never actually called it by this name.</p>\n<p>For example, using MVC in the ASP.NET world, you used routing whenever you specified what controller you expected your code to hit when you specified a particular URL. You’ll remember that we set our code up so that when we specified that URL, code in a controller would get hit. We also had the option of specifying parameters that we wanted to have passed into our controller methods.</p>\n<p>In a SPA, routing does essentially the same thing. The only difference is that we never have to call the server. This makes all our “Pages” virtual. Instead of requiring that our visitors always start at our home page and navigate into the rest of our site; instead of creating a separate page on the server for each page in our site; we can load all the site up front and the user can navigate to exactly the page they want to be at. They can even link directly to that page and the client side will handle displaying the page appropriately.</p>\n<h2 id=\"There’s-a-Catch\"><a href=\"#There’s-a-Catch\" class=\"headerlink\" title=\"There’s a Catch\"></a>There’s a Catch</h2><p>One of the problems you’ll quickly discover is that for this to work, you’ll need to set your server up so that it doesn’t try to handle the routing as well.</p>\n<p>You see, if you navigate to the home page of your web site and then click around into the sub-pages, everything is going to appear to work correctly. But once you try to navigate directly to an inner page, you are going to become extremely frustrated. The problem lies in order your code gets executed.</p>\n<p>When you request a page directly, what happens is that the server will look for that page on the server. If it can’t find it, it will return, appropriately, a 404 error. The problem is that when we ask for a page that only exist because the client side has said it does, when the server goes to look for it, it will return the 404 error. It isn’t there.</p>\n<p>For the moment, I’m ignoring the fact that Angular 2 supplies a feature called Server Side Rendering, which can also take care of this problem. Given regular, out of the box, Angular 2 code, you’ll want to make sure you server knows what to do when the files don’t exist. What I normally do is that I create a rule on my server that says, “if I’m looking for a path that doesn’t have an extension, just return the index.html page you would have returned if I had asked for the home page.” In Express on Node.JS, the code for this looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This comes last.  right before we start listening</span></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this sends back the index.html file when</span></span><br><span class=\"line\">    <span class=\"comment\">// it looks like they are looking for</span></span><br><span class=\"line\">    <span class=\"comment\">// a client side route</span></span><br><span class=\"line\">    <span class=\"comment\">// assuming a real file will have an extension</span></span><br><span class=\"line\">    <span class=\"comment\">// and a route will not.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(req.<span class=\"property\">url</span>.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;.&#x27;</span>) &gt; -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">status</span>(<span class=\"number\">404</span>)        <span class=\"comment\">// HTTP status 404: Not Found</span></span><br><span class=\"line\">            .<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;Not found&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">sendFile</span>(__dirname + <span class=\"string\">&#x27;/www/index.html&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>If you are using IIS and ASP.NET, you might find this article I wrote about using <a href=\"/asp-net-angular-js-html5mode/\">Angular, Routing, and ASP.NET</a> useful.</p>\n<h2 id=\"Enabling-Routing\"><a href=\"#Enabling-Routing\" class=\"headerlink\" title=\"Enabling Routing\"></a>Enabling Routing</h2><p>Since the Angular CLI has included the packages you’ll need to enable routing, there is nothing to install. We just need to write some code.</p>\n<p>Typically routes get enabled at the top of your application after all the common code has been implemented. So, in the location where you want the routing to take effect, add the following tag:</p>\n<p><router-outlet></router-outlet></p>\n<p>I’ve added this to my <code>app.component.html</code> file in the sample app I’ve been working on. Replacing the <code>&lt;h1&gt;&#123; &#123;title&#125;&#125;&lt;/h1&gt;</code> code that we had from the previous weeks.</p>\n<p>If you were to run the code now all that you would see is that the title no longer shows up. We need to add the route code next. You will notice that an <code>app-routing.module.ts</code> file already exist. Open this file. You will see that the bulk of the code we are going to need is already there.</p>\n<p>You should see a line that looks like:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [];</span><br></pre></td></tr></table></figure>\n\n<p>We are going to add a route to this array:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">component</span>: <span class=\"title class_\">ViewComponent</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>What this is saying is that whenever we ask for the home page, load the “ViewComponent” component.</p>\n<p>But wait, we haven’t added any components yet.</p>\n<p>While we COULD just add a component, what I prefer to do is to add a new module. This is because I dislike the idea of making all the components in my code part of one huge modules. It makes it extremely difficult to refactor my code. I also want the ability to implement lazy loading in the future and I will need the component I am routing to, to be part of its own component in order for that to work.</p>\n<p>To add a View component to our code run the following line from the terminal&#x2F;command line <code>ng g module view</code> This will create a new ViewModule module with a new ViewComponent component located in the view directory.</p>\n<p>The rest of what we need to do is to just wire this all into the existing application.</p>\n<p>Go back to <code>app-routing.module.ts</code> and add an import statement to load in <code>ViewComponent</code> and the <code>ViewModule</code>:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ViewComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./view/view.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">ViewModule</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./view/view.module&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>We also need to add <code>ViewModule</code> to the imports array.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">RouterModule</span>.<span class=\"title function_\">forRoot</span>(routes),</span><br><span class=\"line\">    <span class=\"title class_\">ViewModule</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">exports</span>: [<span class=\"title class_\">RouterModule</span>],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Next, we need to register the routing module with the application. So, load up the app.module.ts file and add an import statement to import the app-routing module:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; _applicationName_RoutingModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app-routing.module&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>And add <code>_applicationName_RoutingModule</code> to the imports array:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">declarations</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">AppComponent</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">BrowserModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">FormsModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">HttpModule</span>,</span><br><span class=\"line\">    _applicationName_RoutingModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [],</span><br><span class=\"line\">  <span class=\"attr\">bootstrap</span>: [<span class=\"title class_\">AppComponent</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Adding additional routes is more of the same. Let’s add another module for editing.</p>\n<p><code>ng g module edit</code></p>\n<p>Add two new paths. One so we can add a new item and one so we can edit an existing item.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">Routes</span> = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"title class_\">ViewComponent</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">&#x27;Add&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"title class_\">EditComponent</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">&#x27;Edit/:id&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"title class_\">EditComponent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>Notice that for the Edit command I added :id at the end. The :id specifies that this location is where the parameter will be. In this case, the ID of the record that we want to edit.</p>\n<p>We will flesh these out later and I’ll leave adding import statements and adding modules to the import arrays to you. It is essentially copy&#x2F;paste&#x2F;modify from the previous code. When you have the code working, you should be able to navigate to &#x2F;Add or &#x2F;Edit&#x2F;id and see the new page.</p>\n<p>If you get stuck, the code so far can be found here: <a href=\"//github.com/DaveMBush/GettingStartedWithAngular2/tree/Step3\" title=\"https://github.com/DaveMBush/GettingStartedWithAngular2/tree/Step3\">https://github.com/DaveMBush/GettingStartedWithAngular2/tree/Step3</a></p>\n",
            "tags": [
                "angular",
                "routing"
            ]
        },
        {
            "id": "http://davembush.github.com/asp-net-angular-js-html5mode/",
            "url": "http://davembush.github.com/asp-net-angular-js-html5mode/",
            "title": "ASP.NET, Angular.js & html5mode",
            "date_published": "2015-09-24T11:30:00.000Z",
            "content_html": "<p>I’ve been looking at Angular.js recently.  I’ve already got enough of a project done in <a href=\"//www.mongodb.org/\">MongoDB</a> (with <a href=\"//mongoosejs.com/\">Mongoose</a>), <a href=\"//expressjs.com/\">Express</a>, <a href=\"//angularjs.org/\">Angular</a> and <a href=\"//nodejs.org/\">Node.js</a> (MEAN) to be comfortable with how Angular works.  But I wanted to give it a try using ASP.NET as the back end.  I’m always learning.  Always improving.</p>\n<p>To start out, I just setup an index.html page to hold my basic form as I got the basic look and feel going.  But as I progressed, I wanted to make sure I progressed, I wanted to add in the capability of using Angular’s html5mode for the client side routing.</p>\n<span id=\"more\"></span>\n\n<p>For those of you who are new to Angular, Angular is a client side JavaScript framework that will allow you to create web applications where much of the processing happens on the client side instead of the server side.  That’s cool enough.  But it also adds the ability to handle client side routing, just like ASP.NET’s MVC handles server side routing.  This allows you to have a client side “master page” that can suck in the differences from the server as it needs them based on the url that is in the address bar.  In fact, there is an extension that will let you have sub routes as far down as you need.</p>\n<p>Out of the box, Angular, and most other frameworks that implement client side routing, using the hash symbol to specify the route.  For example</p>\n<p>http:&#x2F;index.html#&#x2F;pathToRoute</p>\n<p>This allows the routing to work on older browsers.</p>\n<p>ASP.NET, Angular.js &amp; html5mode <img src=\"/uploads/2015/09/image3.png\" alt=\"image\" title=\"image\"> ASP.NET, Angular.js &amp; html5modeBut if you are working with newer browsers that support HTML5, you can avoid the hash tag and just create a route that looks like this:</p>\n<p>http:&#x2F;pathToRoute</p>\n<p>Which you have to admit, looks a whole lot nicer.</p>\n<p>But here is where the problems start.</p>\n<p>As soon as you implement html5mode on a site that is hosted in IIS or IIS express, you will get a 404 error because your initial request to the server is going to ask the server for a path that doesn’t exist.</p>\n<p>There are a few ways that you can take care of this.</p>\n<h2 id=\"Return-a-default-view-for-every-undefined-server-route\"><a href=\"#Return-a-default-view-for-every-undefined-server-route\" class=\"headerlink\" title=\"Return a default view for every undefined server route.\"></a>Return a default view for every undefined server route.</h2><p>One of the first suggestions you are likely to find suggest creating a default view for all routes that start with “&#x2F;angular&#x2F;”.</p>\n<p>This is a great start.  But here are my issues with it.  If I really want to use Angular the way it was intended to be used, I would prefer to not have to use MVC on the server side at all.  While not a huge hit, writing a razor page just to get my initial angular page up seems to be a bit of overkill.  There must be a way to do this without creating a *.chshtml file.  I also don’t want to have a sub directory for my page.  Why can’t I just go to <a href=\"//blog.dmbcllc.com\">http://blog.dmbcllc.com</a> as my default route?  And why can’t I just return a plain old html file?! Well, it turns out you can.  A slight modification of the “Return a default view” method is to have your controller return your html page.</p>\n<h2 id=\"Return-an-HTML-page-direct-from-the-controller\"><a href=\"#Return-an-HTML-page-direct-from-the-controller\" class=\"headerlink\" title=\"Return an HTML page direct from the controller.\"></a>Return an HTML page direct from the controller.</h2><p>If you dig a bit further, you’ll find that someone else has realized that you can just return your HTML directly from the controller.  The magic to this trick is all similar to what the guy in the original article did except for in the controller, instead of returning the view, he returns the html file that contains the main html.</p>\n<p>public ActionResult Index()<br>{<br>    return File(“~&#x2F;yourstartpage.html”, “text&#x2F;html”);<br>}</p>\n<p>And his main MVC route looks like this:</p>\n<p>routes.MapRoute(<br>      name: “Default”,<br>      url: “{*.}”,<br>      defaults: new<br>      {<br>        controller &#x3D; “Home”,<br>        action &#x3D; “Index”,<br>      }<br>  );</p>\n<p>This implementation has the added benefit that I’m not tied to a specific sub directory because it just says, “Any URL that doesn’t have a real file behind it should resolve to this default route.” Of course, you may be thinking, but what about the WEB API route, or any other routes I want in my system.  Well, just make sure this route comes first and you have other routes to cover the real routes you want to be able to support.</p>\n<p>Now, this gets past the objection I had with the first solution.  I no longer have to have a route.  But, why should I need to call the controller?  This is just a static HTML file we are talking about.  I should be able to by pass ASP.NET handling this file and just have IIS serve it up directly to me.</p>\n<h2 id=\"Use-the-URL-Rewrite-Module\"><a href=\"#Use-the-URL-Rewrite-Module\" class=\"headerlink\" title=\"Use the URL Rewrite Module\"></a>Use the URL Rewrite Module</h2><p>A little deeper digging on the search engines reminded me that  I could just setup the <a href=\"//www.iis.net/downloads/microsoft/url-rewrite\">URL Rewrite module</a> to return my main HTML page when no real page is available.  BTW, URL Rewrite is built into IIS Express, so it should work in your development environment if you are using IIS Express as well as under IIS with the module installed. The main step to getting this working is to add the following XML to your Web.config file:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">system.webServer</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rewrite</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rules</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;angularjs routes&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">stopProcessing</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">match</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;.*&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">conditions</span> <span class=\"attr\">logicalGrouping</span>=<span class=\"string\">&quot;MatchAll&quot;</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">input</span>=<span class=\"string\">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">matchType</span>=<span class=\"string\">&quot;IsFile&quot;</span> <span class=\"attr\">negate</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">input</span>=<span class=\"string\">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">matchType</span>=<span class=\"string\">&quot;IsDirectory&quot;</span> <span class=\"attr\">negate</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">input</span>=<span class=\"string\">&quot;&#123;REQUEST_URI&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;^/(api)&quot;</span> <span class=\"attr\">negate</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">conditions</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;Rewrite&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;/&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">rule</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rules</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rewrite</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">system.webServer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>You should already have a system.webServer section in your web.config file, so you just need the rewrite rule inside of it.</p>\n<p>Basically what this rule does is that it says, “If you can’t find the file, and the path you are looking for is not a subdirectory of the “api” directory, return the default file at the root.”  The part about the API directory allows your WEB API stuff to continue working.</p>\n<p>The only other thing you will need to do, which isn’t unique to ASP.NET or MVC, is that you will need to remember to add the base tag to the HEAD section of your HTML file.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">base</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>And all of your client side routing with HTML5 issues should be solved. Notice that no ASP.NET code has to run to get this working.  In fact, the only time you’ll need to run ASP.NET is to call the server for data.</p>\n",
            "tags": [
                "routing",
                "asp.net",
                "angular.js",
                "iis"
            ]
        }
    ]
}