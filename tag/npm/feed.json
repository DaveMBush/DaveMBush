{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"npm\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/you-can-start-using-node-today/",
            "url": "http://davembush.github.com/you-can-start-using-node-today/",
            "title": "You Can Start Using Node Today",
            "date_published": "2016-08-02T10:30:00.000Z",
            "content_html": "<p>I was just getting started writing an article about using Node&#x2F;JavaScript to drive my Selenium tests and as I was writing the “Prerequisite” section, I realized I have never written the basics about how to get setup with Node or even why you would want to.</p>\n<p>As popular as Node is, I am still finding that many of the people I work with have no idea what it is or if they do, they only have a partial idea and can’t see how it would apply to the work they do on a daily basis.</p>\n<p>So, let’s start with the fundamentals.</p>\n<figure>![](/uploads/2016/07/image-4.png \"You Can Start Using Node Today\")<figcaption>Photo credit: [stevendepolo](//www.flickr.com/photos/stevendepolo/5749192025/) via [VisualHunt.com](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"What-is-Node\"><a href=\"#What-is-Node\" class=\"headerlink\" title=\"What is Node?\"></a>What is Node?</h2><p>I think the best place to start with our introduction is by providing a comprehensive view of what Node is.  A rather simplistic description would be, “Node is the V8 JavaScript engine from the Chrome browser, wrapped in an executable, that lets you run JavaScript without a browser.” Now, with that simplistic definition, you might think, “Why would I want to do that?”  Maybe you are assuming that this implementation only lets you do the same stuff that you can do in the browser.  And this is where you would be wrong.</p>\n<p>So, let’s start over.</p>\n<p>Node allows you to write cross platform applications that will run directly on your computer using JavaScript as the language.</p>\n<p>And now I hear everyone thinking, “Yeah, yeah, that was the promise of Java.” OK.  Maybe that’s true.  Time will tell.</p>\n<h2 id=\"What-Can-You-Do-with-Node\"><a href=\"#What-Can-You-Do-with-Node\" class=\"headerlink\" title=\"What Can You Do with Node?\"></a>What Can You Do with Node?</h2><p>Several well-known applications use Node.  You may be surprised at how much node is already being used.  Here’s a short list:</p>\n<ul>\n<li>Many Web Servers</li>\n<li>Desktop Applications</li>\n<li>Developer Build Processes</li>\n</ul>\n<p>Does any of that surprise you? There is a <a href=\"//github.com/nodejs/node/wiki/Projects,-Applications,-and-Companies-Using-Node\">long list of companies</a> who are using Node for some part of their development process or infrastructure.  Some more notable implementations include:</p>\n<ul>\n<li>VS Code by Microsoft – a code editor built using Node and Electron.</li>\n<li>Slack Desktop App – uses Node and Electron</li>\n</ul>\n<p>In short, you can do just about anything you can think of.</p>\n<h2 id=\"Installing-Node\"><a href=\"#Installing-Node\" class=\"headerlink\" title=\"Installing Node\"></a>Installing Node</h2><p>This falls under the category of “Things I wish I had known.” You can just go to the <a href=\"//nodejs.org/en/\">Node site</a> and download the version you want to use.  But at some point, you are going to want to use multiple versions of Node.  One version for one project and a different version for some other project.  For that, you are going to need a tool called ‘NVM’.  Life will be a lot easier if you just install NVM first and then install Node from there.</p>\n<p>If you are running Windows, you’ll want to <a href=\"//github.com/coreybutler/nvm-windows/releases\">grab NVM from here</a>.  Everyone else can <a href=\"//github.com/creationix/nvm\">get NVM from here</a>. Once you have NVM installed, you should be able to run <code>nvm install _version.number.here_</code> or you can run <code>nvm install node</code> To install the latest version.</p>\n<p>You can run this command for each version you want to have installed.</p>\n<p>To see which versions are installed, you can run <code>nvm ls</code> And to use a specific version you can run <code>nvm use _version.number.here_</code></p>\n<h2 id=\"Using-the-Node-Package-Manager\"><a href=\"#Using-the-Node-Package-Manager\" class=\"headerlink\" title=\"Using the Node Package Manager\"></a>Using the Node Package Manager</h2><p>When you installed Node, you also installed the Node Package Manager(NPM).  For those of you who are coming from the Microsoft world, NPM is like NuGet.  It is how we install additional “Modules” (think libraries) into our Node environment.</p>\n<p>The commands for NPM are pretty straight forward and most of the time, the documentation will tell you exactly what command to run to get it into your development environment.  But, it is helpful to know why you are running the various commands.</p>\n<p>But, before you start installing Node packages into your development environment, you are going to want a package.json file.  The easiest way to create this in a form that NPM can use is to use the command <code>npm init</code> which will walk you through all of the questions you need to answer to create a proper package.json file.</p>\n<p>The next command you are going to encounter is <code>npm install</code>.</p>\n<p>But <code>npm install</code> has several switches that you’ll be using.  Each with a different purpose.</p>\n<p><code>npm install _packagename_</code></p>\n<p>This will install the most recent version of the package into your node_modules directory and record the dependency in your package.json file in the dependencies section.</p>\n<p>If you want to be explicit about where you are saving the file you can use the <code>--save</code> flag.  It does the same thing as <code>npm install package</code>.</p>\n<p><code>npm install --save _packagename_</code></p>\n<p>Your other option for saving is</p>\n<p><code>--save-dev</code>.</p>\n<p>This puts the dependency in the devDependencies section.</p>\n<p>You might wonder why you would have two different dependency sections.</p>\n<p>The reason for this is because you might have modules that you need simply to build the project. They aren’t needed when you deploy the project. So having the two different sections allows you to deploy without the extra set of modules.</p>\n<h2 id=\"Node-JavaScript\"><a href=\"#Node-JavaScript\" class=\"headerlink\" title=\"Node JavaScript\"></a>Node JavaScript</h2><p>I once had someone assert that even within the same versions of JavaScript, there are different versions of JavaScript.  His main point was that there are differences between JavaScript on the browser and JavaScript in Node.  I assert, they are the same version of JavaScript, but the API that is available, or required, is different based on the environment.</p>\n<p>So, JavaScript on Node is syntactically no different from the JavaScript you write now.  However, Node does solve an age old problem we’ve had in client side code automatically. This problem is global scope pollution. If we write JavaScript that looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Without wrapping the code in a function, the code will end up in global scope.</p>\n<p>The fix for this is to wrap all of our files in immediately invoked function expressions (IIFEs).  I’ve written about using IIFEs before as a best practice for Angular programming.  In fact, it is a best practice for all client side JavaScript programming.</p>\n<p>But, in Node it is completely unnecessary because Node puts each file in its own scope.  Putting something on the global scope is something you have to do intentionally.  This is good, but it does require us to write some extra code.</p>\n<p>You see, the problem is, if all of the code we write is only local to the file we write it in, how are we going to be able to write code in a modular fashion?  We don’t want all of our code in one monolithic file.</p>\n<h2 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h2><p>So, to handle this problem, Node implements two keywords&#x2F;functions&#x2F;variables (depends on how you think about it) We’ll just call them keywords for now.</p>\n<p>The first is the requires() keyword.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fooScript&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>This says go find the script “fooScript.js” and assign what was exported from it to our “foo” variable.  If the file you need to require has been installed with NPM, then all you need is the name of the module, like I did above.  But if you are requiring in a file from your own code, you’ll need to require using a path reference.  For you Windows people, this always works using forward slashes (&#x2F;) not backslash (\\).</p>\n<p>This probably leaves you asking the question, how does fooScript expose its content to the module requiring it? With code that looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = fooFunc;</span><br></pre></td></tr></table></figure>\n\n<p>This line normally appears at the end of a file.  In the case of the line above, assume that fooFunc is a function that is defined somewhere above the module.exports line. You could also write the exports using:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exports</span> = fooFunc;</span><br></pre></td></tr></table></figure>\n\n<p>They do the same thing.</p>\n<p>If our fooFunc is in a file named “fooScript.js” then our foo variable above can call the fooFunc() function by using foo.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = require(&#x27;fooScript&#x27;);</span><br><span class=\"line\">foo(); // this line calls fooFunc() in fooScript.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Optimizations\"><a href=\"#Optimizations\" class=\"headerlink\" title=\"Optimizations\"></a>Optimizations</h2><p>What took me a while to grasp is that you can export anything.  A function, a variable, an object.  It really doesn’t matter.  But you have to be aware of some optimizations that Node makes for you.</p>\n<p>You see, it would be pretty stupid to process the file every time it was required into another file.  So rather than do that, Node caches the export and assigns that the next time it is required.  If you export an object, the next time you require it, you will get the same object.  So an exported object becomes a singleton.  If you want to be able to create new objects, you are better off exporting the function (or class in ES2015) that creates the object and new-ing it up when you need it.</p>\n<h2 id=\"Your-Turn\"><a href=\"#Your-Turn\" class=\"headerlink\" title=\"Your Turn\"></a>Your Turn</h2><p>So, now it is your turn.  If you have not tried using Node.js install it and try a few things.</p>\n",
            "tags": [
                "javascript",
                "node",
                "npm",
                "nvm"
            ]
        }
    ]
}