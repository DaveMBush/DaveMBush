{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"redux\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/rethinking-action-names-redux-ngrx/",
            "url": "http://davembush.github.com/rethinking-action-names-redux-ngrx/",
            "title": "Rethinking Action Names (Redux/NgRX)",
            "date_published": "2021-05-29T10:52:47.000Z",
            "content_html": "<p>If you’ve been using some form of Redux, you are familiar with the basic flow of data through the Redux loop. Central to this flow are Actions, the messages that trigger code in our Reducer or Effect&#x2F;Epic&#x2F;Saga (depending on what flavor of Redux you are using).</p>\n<p>The model allows us to disconnect our code so that it only cares that an action was triggered in some way.  That is, “when this action occurs, I will run this code.”</p>\n<p>Because of this, we can create an action that triggers multiple code blocks to run. Our only concern is that the code that gets triggered can’t depend on each other.</p>\n<p>In fact, much of the official literature encourages this practice.</p>\n<p>And, this is where all our troubles begin.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Current-Recommendation\"><a href=\"#Current-Recommendation\" class=\"headerlink\" title=\"Current Recommendation\"></a>Current Recommendation</h2><p>You see, the official literature around actions also suggest a naming convention that is tied to what we want to happen, rather than what just happened or something otherwise more generic.</p>\n<p>For example, take the simple act of loading a list of employees from the server. To do this, we would typically create two actions.  The first would be <code>LoadEmployees</code> and the second would be <code>LoadEmployeeResults</code>. Both of these actions represent what we want to do, not what just happened.</p>\n<p>Now, let’s say we also want to display some sort of wait state and that we want to control it using Redux.  For that we would create a Reducer in our store.  Let’s call it <code>Wait</code>. And for the purposes of this post, we will assume that <code>Wait</code> tracks wait state by incrementing and decrementing a counter.</p>\n<p>But, we don’t need to create new Actions for our Wait state because we can re-use the actions we’ve already created. When we fire <code>LoadEmployees</code> we can increment <code>Wait</code> and when we fire <code>LoadEmployeesResult</code> we can decrement the load.</p>\n<h2 id=\"What’s-Wrong-With-That\"><a href=\"#What’s-Wrong-With-That\" class=\"headerlink\" title=\"What’s Wrong With That?\"></a>What’s Wrong With That?</h2><p>Do you see the problem here? We now have a reducer responding to an event that is not obviously tied to an action that has anything to do with the code that is getting executed. <code>Wait</code> is not a <code>LoadEmployees</code> thing although, you might reasonably say it is a <code>Load</code> thing.</p>\n<p>And so how might we think about restructuring our code so that this makes more sense.</p>\n<h2 id=\"A-Change-In-Perspective\"><a href=\"#A-Change-In-Perspective\" class=\"headerlink\" title=\"A Change In Perspective\"></a>A Change In Perspective</h2><p>What if instead of naming actions what we wanted to do, we named them something more along the lines of what just happened.  That would make our <code>LoadEmployees</code> action <code>NeedEmployees</code> and our <code>LoadEmployeesResult</code> action, <code>EmployeesLoaded</code>.</p>\n<p>Even these names don’t get at the fact that Needing Employees doesn’t mean we need to increment the wait state.</p>\n<h2 id=\"Rethinking-The-Problem\"><a href=\"#Rethinking-The-Problem\" class=\"headerlink\" title=\"Rethinking The Problem\"></a>Rethinking The Problem</h2><p>One way we can think about this problem is to look at other messaging systems, like the windows messaging system. It’s been a while since I’ve used the raw messages in Windows but I seem to recall a <code>WM_BUTTON</code> or <code>WM_BUTTON_CLICK</code> message that would get passed to my application when a button was clicked.  One message for every button in my system that had, as part of the payload, what button was clicked so my code could listen for that message for that button and do something because of it.</p>\n<p>We could do something similar with the code above. Instead of tying the actions to particular code we want to run, our actions could be more generic.<br>What if we had two generic messages, <code>Load</code> and <code>LoadResult</code>. The payload for these messages could then have a <code>LoadType</code> property that defined WHAT we were loading so that we could Load Employees, Addresses, and Phone Numbers all using the same two actions and we could also use <code>Load</code> and <code>LoadResult</code> to increment and decrement our wait state.</p>\n<p>This would work except we still have a problem.</p>\n<h2 id=\"That’s-Not-How-It-Was-Designed\"><a href=\"#That’s-Not-How-It-Was-Designed\" class=\"headerlink\" title=\"That’s Not How It Was Designed\"></a>That’s Not How It Was Designed</h2><p>Most of the tools we currently have in place to reduce the boiler plate code we need to write are based on a one-to-one relationship between actions and the code that gets run. This isn’t to say that we couldn’t adapt them but doing so would be more trouble than it is worth because we would be working against the intended design.</p>\n<p>And so, I would suggest to you that the advice the current literature gives us about using Actions to trigger multiple blocks of code is wrong. Since Actions are primarily used as loosely coupled method calls, using them in unrelated places violates the Single Responsibility Principle and makes the code hard to follow.</p>\n<p>I’ve seen one code base where the code that gets triggered has absolutely nothing to do with the Action that triggers it. Not something in the simple case of LoadEmployee triggering Wait, but in more obscure relationship like <code>LoadCandyBars</code> triggering <code>LoadSteakDinner</code>.  The result is that the code becomes extremely difficult to follow. This is one of the biggest causes of bugs in this system.</p>\n<h2 id=\"Maybe-This-Will-Work\"><a href=\"#Maybe-This-Will-Work\" class=\"headerlink\" title=\"Maybe This Will Work\"></a>Maybe This Will Work</h2><p>For our discussion about the Wait state, I would suggest that we create a separate set of Actions for our Wait state, possibly WaitStart() and WaitEnd() that get fired when we fire EmployeeLoad() and EmployeeLoadResult(). You could wrap these calls in a function or method to ensure they always get called together, but the actions themselves need to be unique to make the code easier to follow.</p>\n<p>Currently, this is my recommended implementation. While not ideal, it gets the job done and makes maintaining the code simple and straight forward even if I do have to duplicate more Actions that I would like to.</p>\n",
            "tags": [
                "angular",
                "react",
                "ngrx",
                "redux"
            ]
        },
        {
            "id": "http://davembush.github.com/thinking-in-javascript/",
            "url": "http://davembush.github.com/thinking-in-javascript/",
            "title": "Thinking in JavaScript",
            "date_published": "2017-09-05T10:30:54.000Z",
            "content_html": "<p>Over the last week I’ve gradually come to the realization that the fundamental reason why most people have trouble with JavaScript is because it doesn’t fit their mental model of how programming should be done.  This isn’t to say that most programmers don’t manage to achieve their end goal.  But if you sit back and take an objective look at the code we end up writing, you have to admit, the code ends up being quite ugly. </p>\n<p>Now, this isn’t a dig at the way we’ve been doing things.  We’ve all been doing the best we can with what we have.  But, the JavaScript world has progressed and there is a better mental model that has developed and should even be expanded which will allow us to develop more complex and feature rich applications now and well into the future. <figure><img src=\"/uploads/2017/09/2017-09-05.jpg\" title=\"Thinking in JavaScript\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/froderik/8283727226/\">freddie boy</a> via <a href=\"//visualhunt.com/re/fb4c57\">Visual Hunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\"> CC BY-SA</a></figcaption></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Where-We’ve-Been\"><a href=\"#Where-We’ve-Been\" class=\"headerlink\" title=\"Where We’ve Been\"></a>Where We’ve Been</h2><p>I’ve been saying for years that the thing that holds most programmers back is that they always want to treat whatever new thing they are using like the last thing they were using.  And nowhere has this displayed itself more apparently than with JavaScript. </p>\n<p>Take the most obvious of examples.  Everyone knows, or should know by now, that JavaScript is not really object-oriented.  And yet, we’ve been trying to force JavaScript to BE object-oriented pretty much from the beginning.  This hasn’t been such a big problem, although one could argue that by trying to make JavaScript object-oriented, we’ve prevented it from being able to do some of the things it does best. </p>\n<p>Where we really run into trouble is with the event based, and often asynchronous nature of JavaScript. Think about this.  For years, we’ve been trying to synchronize something that is inherently asynchronous.  And this is where the real trouble begins. </p>\n<p>First, we had call back. Then promises. Now Observables. Soon async and await. And while callbacks are how the asynchronous nature of JavaScript is handle under the hood, the others are attempts to tame the asynchronous beast.  Especially async and await.</p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why?\"></a>Why?</h2><p>Now, this is where we are. Constantly trying to make JavaScript be something it isn’t. But, why is this? </p>\n<p>I believe it is because we are trying to impose models onto JavaScript that were useful in our desktop and server-side applications.  MVC, MVVM, Object-Oriented, and others all grew up in a world that was both synchronous, multi-threaded, and lent themselves well to an object-oriented model.  As various frameworks have evolved, the attempt has been to take these familiar models and apply them to an asynchronous, single threaded and not really object-oriented.  From where I sit, I am amazed any of this worked at all.  It seems to me it should have failed long ago.</p>\n<h2 id=\"A-Light-in-The-Darkness\"><a href=\"#A-Light-in-The-Darkness\" class=\"headerlink\" title=\"A Light in The Darkness\"></a>A Light in The Darkness</h2><p>Hey, I’ve been stuck in the old school model too.  But, I’m starting to think there may be a better way.  I’ve written about Redux and NgRX a lot on this blog.  I’ve fielded a lot of questions on the Angular slack channel.  Most of the questions revolve around the basic question of handling multiple asynchronous calls for data as part of one action.  All of the questions presuppose you would need to make each of the calls for data and then use some method of waiting for everything to return and assemble the data before moving on.  In each case, I recommend an alternative.  What if, each call was a unique action.  When each returns, another action is fired that places the return data in the appropriate store, or sub store.  In this model, we don’t care when the data comes back.  When it comes back, we deal with it appropriately.</p>\n<h2 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h2><p>Let’s go with one of the more common examples I see. </p>\n<p>I need to make a request for a set of records.  Once I have the results, for each record in the result, I need to go get a set of child records.  Here is how I would deal with this at a very high level using NgRX.  I’m sure this would work for multiple Redux patterns but they may call things by different names.</p>\n<ul>\n<li>Fire an Action that request the main set of records.</li>\n<li>The appropriate Effect responds to the action by making an AJAX call for the data.</li>\n<li>When the AJAX call returns,<ul>\n<li>fire an Action that puts the main records in the store.</li>\n<li>for each record in the result fire an Action asking for the child record(s).</li>\n</ul>\n</li>\n<li>The appropriate Effect(s) responds to the request for child records by making AJAX calls.</li>\n<li>When the data returns fire an Action that places the data in the store.</li>\n</ul>\n<p>Since your view is listening for changes on the entities in your store, it will update as the data comes in. Even better if you setup a debounce on your listener, the screen will update only when all of the data has been retrieved.</p>\n<h2 id=\"The-Key-Concept\"><a href=\"#The-Key-Concept\" class=\"headerlink\" title=\"The Key Concept\"></a>The Key Concept</h2><p>The key concept here is that we no longer care WHEN something happens.  We only care THAT it happens.  And rather than trying to setup forkJoins() or some other mechanism to flatten this all out, our code ends up being quite simple.  Discrete bits of functionality.  And now, all our asynchronous code becomes Reactive code.  We no longer need to flatten anything out.</p>\n<h2 id=\"Server-Side\"><a href=\"#Server-Side\" class=\"headerlink\" title=\"Server Side\"></a>Server Side</h2><p>Sadly, on the server side, things aren’t quite so easy.  At best we are tied to an implementation Observables and the various methods of combining Observables.  But I could also see some kind of client&#x2F;server implementation that used a framework like SignalR or Socket.io so that as the various Observables complete, the data on the client would get updated.  An interesting way to make all of the AJAXy calls rather transparent to the user.</p>\n<h2 id=\"Taking-it-To-the-Next-Level\"><a href=\"#Taking-it-To-the-Next-Level\" class=\"headerlink\" title=\"Taking it To the Next Level\"></a>Taking it To the Next Level</h2><p>You may call me a dreamer, but what if we made a JavaScript framework that was all message driven and reactive like I’ve described above?  We’ve done it before. </p>\n<p>When Windows was first created in ran on single core CPUs.  It was essentially single threaded.  The way it worked was primarily by putting “events” on a que and then sending the events to the appropriate application that needed to know about them. </p>\n<p>If you applied this model to JavaScript and folded in what I’ve described above, you could easily have a system that appeared to be multi-threaded even though it was single threaded at its core.</p>\n<h2 id=\"Don’t-Throw-the-Baby-Out-…\"><a href=\"#Don’t-Throw-the-Baby-Out-…\" class=\"headerlink\" title=\"Don’t Throw the Baby Out …\"></a>Don’t Throw the Baby Out …</h2><p>Now, you may think I’m endorsing throwing out object-oriented JavaScript.  Actually, I think most of the View stuff we do lends itself well to object-oriented programming.  But, most of our business rules lend themselves better to the model I’ve described above.  Functional and Reactive.</p>\n",
            "tags": [
                "javascript",
                "mvvm",
                "redux",
                "MVC",
                "NgRX"
            ]
        }
    ]
}