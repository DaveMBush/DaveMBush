{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"software architecture\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/reasons-software-architecture-matters/",
            "url": "http://davembush.github.com/reasons-software-architecture-matters/",
            "title": "Reasons Software Architecture Matters",
            "date_published": "2017-02-14T12:30:00.000Z",
            "content_html": "<p>Several weeks ago, I was talking to a programmer and we got into a discussion about the importance of software architecture. I maintained that having a defined architecture is important regardless of the team size, the person I was talking to asserted that architecture wasn’t necessary when there was just one person involved.</p>\n<p>But here’s the thing. All software has an architecture. Even the most junior of programmers has an idea of how code should fit together. At issue isn’t really about architecture. It is about having a defined architecture, based on experience and best practices, that will allow the team to develop the software in question as efficiently as possible. Software architecture, at its core, says, “this is how we build software.”</p>\n<p>To find the reasons why software architecture matters, it is helpful to think about what happens when there isn’t any defined architecture in place.  For the purposes of this article, I’m going to generalize on how architecture impacts teams and where appropriate show why that is also important when your team is just you. <figure><img src=\"/uploads/2017/02/image-1.png\" title=\"Reasons Software Architecture Matters\"> Photo via <a href=\"//visualhunt.com/\">VisualHunt</a></figure></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Assumptions\"><a href=\"#Assumptions\" class=\"headerlink\" title=\"Assumptions\"></a>Assumptions</h2><p>In a team, having an architecture is important simply because it means we can make certain assumptions about how someone wrote the code you are now looking at.</p>\n<p>Have you ever been in a situation where you wrote some code assuming that the programmers who would be using it had written their code in a particular way only to find out that they hadn’t and because of that, your code needs to be rewritten?</p>\n<p>Or, how about the time you went to work on a bug? Once again, you made some assumptions that weren’t true so it took you much longer to fix the bug than it would have had you known that your assumptions were wrong.</p>\n<p>Imagine what it would be like in those situations if the assumptions you were making were legitimate because everyone was using the same playbook. How much easier would that make your life?</p>\n<p>Ah, but your team is just you, and you know how you put the code together. </p>\n<p>OK. Fine. </p>\n<p>But what about two years from now? Without a defined architecture, would you say you code things the same way every time? I know, even with an architecture, sometimes I “cheat” and my code doesn’t always follow the rules I’ve set out. If I do that WITH an architecture, I can just imagine how sloppy my code would be without it.</p>\n<h2 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h2><p>Get any two programmers in a room and you will almost always get two different opinions about how software should be written. A good architecture reduces the number of arguments so we can get on with the craft of writing code. I’ve been in situations where, even with an architecture, there are programmers who disagree. Some with good reason. But if you don’t have any definition, all you end up with is two opinions with no rule book to say who is “right.”</p>\n<h2 id=\"Cognitive-Load\"><a href=\"#Cognitive-Load\" class=\"headerlink\" title=\"Cognitive Load\"></a>Cognitive Load</h2><p>With so much to consider in software development, the fewer decisions we have to make, the better. This leaves brain power for solving problems that still need answers.</p>\n<p>There are people who wear the same thing every day, or nearly the same, so they don’t have to make that decision. I’m actually one of those people. I kind of fell into this mode of dressing because I’m color blind and this is one of my ways of compensating. But I can tell you, it leaves me free to think about other things as I get ready in the morning.</p>\n<p>This is another place where software architecture will help you regardless of team size. Even if you are the only one on the team, this is one less thing to think about.</p>\n<h2 id=\"Scrambled-Eggs\"><a href=\"#Scrambled-Eggs\" class=\"headerlink\" title=\"Scrambled Eggs\"></a>Scrambled Eggs</h2><p>Software built without an architecture will eventually take on the feel of scrambled eggs. Imagine how hard it will be to modify the code when you have no idea where the different parts of your code should go.</p>\n<p>And once again, we end up with a system that is difficult to maintain simply because no one knows for sure where the various parts of the system should live.</p>\n<h2 id=\"Good-Architecture\"><a href=\"#Good-Architecture\" class=\"headerlink\" title=\"Good Architecture\"></a>Good Architecture</h2><p>You’ll notice I’ve been saying “Good” architecture. This is because I’ve been in situations where the architecture has not been defined tightly enough leaving too many loop holes. I’ve also seen architectures misapplied. It is important when an architecture is defined that the person defining is knows something about the tools that will be used and the environment they will be used in.</p>\n<p>It is also helpful if the architectures that are defined, are defined by consensus rather than having one person defining it. We all have holes in our thinking. Someone may be a great architect, but maybe they suffer from the old saying, “when all you have is a hammer, everything looks like a nail.” More people bring more points of view. This can fill in gaps and can produce an architecture that can be used rather than one that will be resisted.</p>\n<h2 id=\"Success\"><a href=\"#Success\" class=\"headerlink\" title=\"Success\"></a>Success</h2><p>This is all about building successful systems. But just because you got some code working and into production doesn’t mean the code is going to hold up over time.</p>\n<p>There is one guy I know who brags about how fast he can write code. Well, yes, you did get that into QA in a month. But, it took you three months to get it out of QA. The test of a good architecture is:</p>\n<ol>\n<li>Does it help make the project successful?</li>\n<li>Is it relatively easy to understand?</li>\n<li>Has it been adopted by the team using it?</li>\n<li>Is it generally accepted as a valid architecture in the community at large for similar software.</li>\n<li>Does it make the code easier to maintain?</li>\n</ol>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p>So, now I’ve convinced you that you should be using an architecture. How do you get started? It is a lot easier than you think. Most frameworks either have an architecture already defined, or somewhere the community has already defined one for it. Start there. Maybe refine it a bit and settle on something that works.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>If you don’t use an architecture yet, you are probably still thinking, “Yeah, but I don’t have any issues that this would solve.” To which I would answer, “How do you know? What if your wrong?”</p>\n<p>You see, most of my reasons have to do with making software development easier or better. I’m not saying you can’t get something done without architecture. What I am saying is that with architecture you can do everything you are already doing better, faster, cheaper, and easier. Until you try it, you’ll never know if I’m right or not.</p>\n",
            "tags": [
                "best practices",
                "software architecture"
            ]
        },
        {
            "id": "http://davembush.github.com/software-architecture-without-test-driven-development-is-dangerous/",
            "url": "http://davembush.github.com/software-architecture-without-test-driven-development-is-dangerous/",
            "title": "Software Architecture without Test Driven Development is DANGEROUS!",
            "date_published": "2015-01-29T12:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/01/TddImpactsSoftwareArchitecture.png\" alt=\"TDD Impacts Software Architecture\" title=\"TddImpactsSoftwareArchitecture\"></p>\n<p>I’ve had two incidents recently that have shown me how TDD impacts Software Architecture.  Both of these are with code I’m working on.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"What-Software-Architecture-Might-Do\"><a href=\"#What-Software-Architecture-Might-Do\" class=\"headerlink\" title=\"What Software Architecture Might Do\"></a>What Software Architecture Might Do</h2><p>Software architecture might specify how it is put together at a very high level.  For example, software architecture might specify that we use a three tiered approach or an n-tiered approach.  This approach places our view code is at one level, our business rules are at another level, and our data access at yet a third level.</p>\n<p>Software architecture might specify that we use MVC where our business rules are in the model, and a controller communicates between the view and the model to get data between the two.</p>\n<p>It might specify MVVM. This would have the view model take the place of the controller and manage the state information for the view.</p>\n<p>Software architecture might also tell us we should use MVP, giving the presenter the role of the controller and managing state information for the view and communicating with the business rules.</p>\n<p>But none of these patterns tell us how to write maintainable code.  They only tell us about the general software architecture.  This is like having a sketch of a house without a wiring or plumbing plan.</p>\n<h2 id=\"When-the-view-gets-in-the-way\"><a href=\"#When-the-view-gets-in-the-way\" class=\"headerlink\" title=\"When the view gets in the way\"></a>When the view gets in the way</h2><p>So, if you’ve been following this blog for a while, you may remember that I’m working with EXTjs.  Specifically, I’m working with EXTjs 4.2.  This has what Sencha calls an MVC architecture.  The problem is, what they refer to as the “Model” we would all recognize as a “Record” in a table, and their Controller is tightly coupled to their View.  That is, they call this MVC, but no one who understands what MVC is supposed to look like as a design pattern would recognize Sencha’s MVC as the real MVC design pattern.</p>\n<p>This makes the code incredibly hard to test.  The tendency is to write code that is highly dependent on the view.  The view is dependent on the DOM.  Rendering the view takes quite a bit of time.  So any test of your business rules end up taking an incredibly long time to test because they ultimately cause DOM manipulation to occur.</p>\n<p>It isn’t until you decide to borrow a bit of architecture from Angular that you realize that your business rules should be separate classes.  Angular has “Service Classes.” My Service classes are built specifically so they do not rely on anything else.</p>\n<p>By doing this, I was able to get two thirds of my code under test that run in about a second.  Prior to this, they took a half an hour.</p>\n<p>My next task was to get the view and my logic for enabling and disabling controls on the view more loosely coupled.  This was a bit more difficult because enabling and disabling controls is, naturally, a view thing.</p>\n<p>But again, taking a page from another framework, this time Knockout and Angular, I created a ViewModel.  My ViewModel holds the state of my view separate from the actual view.  When the state changes, it fires an event that actually changes the view, but this will allow me to test my enable&#x2F;disable logic, along with other code in my system, without ever instantiating the view.  Under test, the events will fire and nothing will happen.</p>\n<h2 id=\"Avoiding-Dependencies\"><a href=\"#Avoiding-Dependencies\" class=\"headerlink\" title=\"Avoiding Dependencies\"></a>Avoiding Dependencies</h2><p>Now the structure  of my code looks something like the following: View – ViewModel – EnableDisableController – EnableDisableService I could have put the EnableDisableService code in the EnableDisableController, and many people would, but what I’ve found is that if I do that, it would be nearly impossible to UNIT test my Enable&#x2F;Disable logic.  Why?  Because I would be creating all of the objects I needed for the logic in the same class the logic is in.</p>\n<p>By breaking the logic code into it’s own class that takes the ViewModel as a construction parameter, I can create my own ViewModel that looks exactly like what I need it to look like so that I can test the logic with entirely known values.</p>\n<p>These are just two of the ways that code architecture is impacted by Test Driven Development.  I’m sure there are others.</p>\n",
            "tags": [
                "tdd",
                "mvvm",
                "mvp",
                "MVC",
                "dependency injection",
                "software architecture"
            ]
        }
    ]
}