{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"properties\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/javascript-object-fields/",
            "url": "http://davembush.github.com/javascript-object-fields/",
            "title": "JavaScript Object Fields",
            "date_published": "2016-03-10T13:30:00.000Z",
            "content_html": "<p>Last week as I was discussing the basics of <a href=\"/javascript-objectswhat-you-dont-know-can-hurt-you/\">JavaScript Objects</a>, I kept referring to the members of the object as “fields.”  Never did I call them properties or methods.  This is because all members that are hanging off of an object are treated the same, from a membership perspective.  It is the type of data it contains that makes it behave as what we would normally refer to as a property or a method.</p>\n<p>This is an important distinction.</p>\n<p>In a strongly typed system, we can say that a member of our object is a property or method simply because it was defined as one or the other when we defined our class. In JavaScript we have neither classes where we can define what something is, nor strong typing.</p>\n<span id=\"more\"></span>\n\n<p>So, how something functions is determined by the type of variable it is pointing to at run time. <img src=\"/uploads/2016/03/image.png\" alt=\"JavaScript Fields\" title=\"image\">  As I demonstrated last week, there are several ways that you might add a field to your object.</p>\n<ul>\n<li>Use object literal notation and create them as you create the object.</li>\n<li>Add them to the object after the fact using dot notation</li>\n</ul>\n<p>But these are not the only ways. That was just enough so we could have the discussion about objects generally. As we have already seen, fields can be added to the object dynamically. There is nothing that restricts additional fields from being added. You can also delete a field using the <code>delete</code> key word.</p>\n<h2 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h2><p>In fact, one of the most common misconceptions with the JavaScript syntax is that the <code>delete</code> keyword is how you release memory. So, you’ll find code that looks something like this.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// do some other stuff here</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> a;</span><br></pre></td></tr></table></figure>\n\n<p>And the people who write this code believe that ‘abc’ will somehow be removed from memory because they’ve done this. But that’s not how <code>delete</code> works. The proper way to use <code>delete</code> would look like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">a.<span class=\"property\">b</span> = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// do some stuff</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> a.<span class=\"property\">b</span>;</span><br></pre></td></tr></table></figure>\n\n<p>And what this would do is that it would remove the <code>b</code> field from the <code>a</code> object. The side effect would be that ‘abc’ would be released, but only if nothing else was pointing to it. It is just a side effect. <code>Delete</code> does not cause the memory to be released, it only enables that to happen if and when it is appropriate.</p>\n<h2 id=\"Key-x2F-Value\"><a href=\"#Key-x2F-Value\" class=\"headerlink\" title=\"Key&#x2F;Value\"></a>Key&#x2F;Value</h2><p>If you are new to JavaScript, you might not realize that fields are just key&#x2F;value pairs. End even if you do know this, you may not immediately realize all the implications this has. What this means is that you can either write your code to look like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.<span class=\"property\">b</span> = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"property\">b</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Or you can write it like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a[<span class=\"string\">&#x27;b&#x27;</span>] = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a[<span class=\"string\">&#x27;b&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>This means that we can create and access fields by using variables:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fieldName = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">a[fieldName] = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Invalid-Field-Name\"><a href=\"#Invalid-Field-Name\" class=\"headerlink\" title=\"Invalid Field Name\"></a>Invalid Field Name</h2><p>OK. Using a variable as a field name is pretty cool, but did you know that you can also name a field anything you want? That’s right. The only time it matters what you name a field is when you don’t use the key&#x2F;value pair mechanism to create and access your fields. This means you can create a field that is any string that JavaScript will let you create.</p>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p>Which leads to another powerful use of using keys for property names. Have you ever wished you could create a HashMap that used strings for the key to some value? Once again, it may look like the only type of list that JavaScript has available to it is the array. But by using this key&#x2F;value pair mechanism for creating properties, we can actually leverage JavaScript’s properties as HashMaps.</p>\n<h2 id=\"For-Fields-in-Object\"><a href=\"#For-Fields-in-Object\" class=\"headerlink\" title=\"For Fields in Object\"></a>For Fields in Object</h2><p>So, you might be thinking, if fields are essentially members of a HashMap, shouldn’t I be able to iterate through them? Well, actually, yes you can.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;abc&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(f <span class=\"keyword\">in</span> a) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f + <span class=\"string\">&#x27;: &#x27;</span> + a[f]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Will output</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: abc</span><br><span class=\"line\">b: function()&#123;&#125;</span><br><span class=\"line\">c: 3</span><br></pre></td></tr></table></figure>\n\n<p>to the console. The variable <code>f</code> is the key and we use <code>a[f]</code> to get the value. I’ve used this feature to manipulate my code in a lot of creative ways including cloning objects. Be careful with this syntax. For&#x2F;in is not the same as for&#x2F;each and while it may appear to work like for&#x2F;each, it was never intended to work on arrays. There are other ways of iterating through arrays.</p>\n<h2 id=\"Fields-and-Inheritance\"><a href=\"#Fields-and-Inheritance\" class=\"headerlink\" title=\"Fields and Inheritance\"></a>Fields and Inheritance</h2><p>We will have a full discussion of inheritance in a future post. But for today, I just want to touch on the implications of how fields work in light of inheritance.</p>\n<p>Let’s say we have an object <code>a</code> that inherits from object <code>b</code>. Object <code>b</code> has a field on it named, ‘firstName’ that has been set to ‘Dave’. Now, moving over to object <code>a</code>, we <code>console.log(a.firstName)</code> and what gets logged out is, of course, ‘Dave’. No big surprise there.</p>\n<p>Next, we set <code>a.firstName</code> to ‘James’ and <code>console.log(a.firstName)</code> again. This time we get ‘James’ to display in the console. The question is, what is the value of <code>b.firstName</code>? You may be surprised to learn that <code>b.firstName</code> is still set to ‘Dave’ because when you set a field on an object, it is set on that object even if the parent object has the same field name. This is called “shadowing”. Most of the time we don’t care about this because most of the time the end result is what we were expecting anyhow. But, there are times when, if you don’t know this is what will happen, you can shoot yourself in the foot.</p>\n<h2 id=\"Control-Your-Fields\"><a href=\"#Control-Your-Fields\" class=\"headerlink\" title=\"Control Your Fields\"></a>Control Your Fields</h2><p>But what if you want a read only field, or you don’t want to have the field show up in a for&#x2F;in listing? And what do we do about that shadowing issue I just mentioned? ES5 added a new feature that gives us a lot more control using the method named ‘defineProperty’.  It is unfortunately named ‘define<strong>Property</strong>‘ because what makes it a property or not is how it is used, as I’ve explained.  But this actually works for both properties and methods. The basic syntax for defineProperty is:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.<span class=\"title function_\">defineProperty</span>(propertyName, description);</span><br></pre></td></tr></table></figure>\n\n<p>Where <code>propertyName</code> is a string and <code>description</code> is a JavaScript literal in the form of:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>/<span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>/<span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">value</span>: someValue,</span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>/<span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;<span class=\"keyword\">return</span> value;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span>(<span class=\"params\">value</span>) &#123; backingStore = value;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Let’s step through these one by one.</p>\n<h3 id=\"configurable\"><a href=\"#configurable\" class=\"headerlink\" title=\"configurable:\"></a>configurable:</h3><p>The configurable field defaults to true. If for some reason you don’t want anyone to be able to change the definition of the field in the future, you would set configurable to false.</p>\n<h3 id=\"enumerable\"><a href=\"#enumerable\" class=\"headerlink\" title=\"enumerable:\"></a>enumerable:</h3><p>Remember how we were able to use for&#x2F;in to list out all of our fields. If you don’t want to have a field show up in for&#x2F;in, you would set this configuration option to false. It is true by default. This option also controls if the property will allow you to list this property when you convert the object to a JSON string.</p>\n<h3 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"value:\"></a>value:</h3><p>This will let you set the default value of the string.</p>\n<h3 id=\"writable\"><a href=\"#writable\" class=\"headerlink\" title=\"writable:\"></a>writable:</h3><p>The default value for this option is false. You would set this to true if you don’t want the field to change for any reason. Two places where you might use this feature are:</p>\n<ul>\n<li>If you create a string table for constants. These constants should never change, defining them as writable would be a good way to ensure this is true.</li>\n<li>If you are creating a property that is an array. The common way of emptying an array is by assigning an array literal to it.<code>a.b = []</code>;but that assigns a new array to a.b instead of just resetting the length on the existing array object, which is probably what you wanted to do. This gets a lot of AngularJS programmers in trouble. By setting this field to false, you can still use <code>a.b.length = 0</code>; to reset the length, but you won’t accidentally assign a new array object.</li>\n</ul>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get:\"></a>get:</h3><p>The get option allows us to specify a function that returns the value of this field we are defining.</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set:\"></a>set:</h3><p>The set option lets us use a function to set the value. Aside from the obvious feature of being able to use a function to set the value, it has one other benefit. Remember that shadowing issue we talked about previously? If you have a field that uses a setter to set the field value, then the setter will get called instead of creating a shadow field in the child object.</p>\n<h2 id=\"So-much-to-know\"><a href=\"#So-much-to-know\" class=\"headerlink\" title=\"So much to know\"></a>So much to know</h2><p>I bet you didn’t know there was so much to know about JavaScript fields.  It is amazing how much we can get done in programming when we only know a small fraction of what is available. If you found this helpful, don’t forget to sign up for the newsletter so you can learn even more about JavaScript.</p>\n",
            "tags": [
                "javascript",
                "properties",
                "fields",
                "methods"
            ]
        },
        {
            "id": "http://davembush.github.com/c-properties-get-and-set/",
            "url": "http://davembush.github.com/c-properties-get-and-set/",
            "title": "C# Properties Get and Set",
            "date_published": "2014-11-13T12:00:00.000Z",
            "content_html": "<p>My son is learning to program.  Last week he asked me to explain C# properties get and set and, as it turns out, it looks like many others are asking for the same.  So, I’ve decided to spend the time on this post, explaining getters and setters in about as much detail as one can expect. So here it goes…</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Member-Variables\"><a href=\"#Member-Variables\" class=\"headerlink\" title=\"Member Variables\"></a>Member Variables</h2><p>So, a class has “member variables” that are typically scoped as private, although they could be (but shouldn’t be) scoped as public.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _someMemberIntegerVariable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Inside the class definition but not in the methods.  You’ll also sometimes see this referred to as a “field”.  I call them “member variables” because that is what I learned them as back when I was programming C++.</p>\n<h2 id=\"Local-Variables\"><a href=\"#Local-Variables\" class=\"headerlink\" title=\"Local Variables\"></a>Local Variables</h2><p>If the variable is in a method, it is called a “local variable”</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SomeMethod</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> someLocalIntegerVariable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Class-“State”\"><a href=\"#Class-“State”\" class=\"headerlink\" title=\"Class “State”\"></a>Class “State”</h2><p>Now, the reason we have member variables is because they hold the “state” of the object.  For example, you might have a person class (typical example).  The Person class would have a firstName, lastName, birthDate as member variables so that when the class is created (and becomes an object) they can hold the state of the person. “Dave”, “Bush”, 6&#x2F;20&#x2F;61.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> _firstName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> _lastName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date _birthDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Old-Time-Get-and-Set\"><a href=\"#Old-Time-Get-and-Set\" class=\"headerlink\" title=\"Old Time Get and Set\"></a>Old Time Get and Set</h2><p>Now, in the old days (my C++ days) we’d just make those member variables public so that any other class could access them directly.  The problem with that is that any other class could access them directly leaving our class unable to control what exactly came into them.  And so, some gatekeeping was added.  In C++ and Java, that was done with setter methods and getter methods.  In Java that may have changed since the days I programmed in Java, but they started that way at least. That is, setFirstName(string name), setLastName(string name), setBirthDay(date birthday)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> _firstName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> _lastName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date _birthDate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setFirstName</span>(<span class=\"params\">firstName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _firstName = firstName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setLastName</span>(<span class=\"params\">lastName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _lastName = lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setFirstName</span>(<span class=\"params\">Date birthDate</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _birthDate = birthDate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  and to retrieve them…. getFirstName(), getLastName(), getBirthDate() the setters and getters are public (or protected, or private as needed) but the member variables are always private so that only the class they are declared in can access them. Inside the setter, we make sure the data is valid before we set the member variable, or possibly do some sort of computation before we store it, or even pass it on to some other location. But as far as anyone using the class is concerned, it is set setting a value and when it calls the getter, it retrieves the value, or something similar.</p>\n<h2 id=\"C-Properties-Get-and-Set\"><a href=\"#C-Properties-Get-and-Set\" class=\"headerlink\" title=\"C# Properties - Get and Set\"></a>C# Properties - Get and Set</h2><p>So along comes C# and that language says, “having a getter method and a setter method is pretty dumb, we should syntactically stich them together.” And so they came up with properties The syntax for that is</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> datatype _propertyName;</span><br><span class=\"line\"><span class=\"keyword\">public</span> datatype PropertyName</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123;<span class=\"keyword\">return</span> _propertyName;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>&#123;_propertyName = <span class=\"keyword\">value</span>;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Which is all declared inside a class.  The member variable doesn’t have to be named the same as the property, but it often is .  It is customary to name member variables with a leading underscore.  Local variables start with a lowercase character. So, properties and member variables are distinct. Although, you may have thought they were essentially the same thing. At the end of the day, once they are compiled, properties are just methods. But syntactically, you access them as though they were variables.  In fact, if you looked at a property in Intermediate Language (IL), the language that all .NET code compiles to, you would see that it is just a method. To access a property from within your code, you would access it as</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">someObject.FirstName = <span class=\"string\">&quot;Dave&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">someVariable = someObject.FirstName;</span><br></pre></td></tr></table></figure>\n\n<p>the only reason they exist at all is to keep the outside world (outside the class) from stomping on the member variables of the class directly. The compiler does for us what the old timers did (and the Java guys still do) using getMethod and setMethod So, as it turns out, we need all that gatekeeping, but the fact of the matter is, many times we don’t. When I was teaching, I’d have guys say, “if I don’t need the gatekeeper, why even bother with the properties?” Which is kind of a valid point But I always countered, “But what if you eventually do?</p>\n<h2 id=\"Enhanced-Properties\"><a href=\"#Enhanced-Properties\" class=\"headerlink\" title=\"Enhanced Properties\"></a>Enhanced Properties</h2><p>I think Microsoft heard that so they embellished the language so that we don’t have to declare the member variable if all we are going to do is just pass the data on through to it. That syntax is</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> dataType PropertyName &#123;<span class=\"keyword\">get</span>;<span class=\"keyword\">set</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>the compiler generates the member variable for you So if I wanted to actually do something with the member variable, you would need to declare the member variable. It depends on what you were going to do with it. If you just wanted to retrieve the data at some other point in your application, you’d just use the property.  But if you needed to manipulate the data as it was being set or retrieved, you’d have to use the original syntax. And that’s properties up until today.</p>\n",
            "tags": [
                "c#",
                ".net",
                "get",
                "properties",
                "set"
            ]
        }
    ]
}