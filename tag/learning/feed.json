{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"learning\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/test-driven-learning-an-experiment/",
            "url": "http://davembush.github.com/test-driven-learning-an-experiment/",
            "title": "Test Driven Learning - An Experiment",
            "date_published": "2016-03-24T11:30:00.000Z",
            "content_html": "<p>As I mentioned last week, <a href=\"/react-js-and-associated-bits/\">I’ve been learning React JS over the last month or so</a>. Up until the start of this project, I would learn a new framework, and then I would try to paste in Test Driven Development after the fact.  I would use the excuse that because I didn’t know the framework well enough, I wouldn’t be able to properly write tests for it.</p>\n<p>But this time, I decided to do something different.  What if I wrote tests for my demo application as I was learning this new framework?  My reasoning was that learning how to test code written in the framework was just as important as learning the framework.</p>\n<p>What follows are the lessons I learned from this wildly successful experiment.</p>\n<p><img src=\"/uploads/2016/03/image-4.png\" alt=\"image\" title=\"Test Driven Learning\"> Photo credit: <a href=\"//www.flickr.com/photos/tom-margie/1538953234/\">twm1340</a> via <a href=\"//visualhunt.com\">Visualhunt.com</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"I-Learned-the-Framework-Better\"><a href=\"#I-Learned-the-Framework-Better\" class=\"headerlink\" title=\"I Learned the Framework Better\"></a>I Learned the Framework Better</h2><p>As I’ve written before, most people don’t test because they’ve never learned how.  When you are learning a new framework, in a lot of ways you start out at that same place all over again.  Yes, you’ve got all of your previous testing experience to fall back on, but in a lot of ways, because you don’t know the framework, you don’t really know how to properly test the code you are writing.  So, doing anything takes a lot more time than it would if you just wrote the code and ignored testing.</p>\n<p>But what I learned by forcing myself to write test as I wrote the demo – either before, as TDD should be practiced, or immediately after – is that this all helped me learn the framework better than if I hadn’t.</p>\n<p>For example,</p>\n<ul>\n<li>I stopped thinking of JSX as HTML and instead saw it as code with objects that can be mocked.</li>\n<li>I saw that the Flux system worked best as a “notify with data” system rather than a “notify and pull” system.</li>\n<li>I was forced to fully understand Flux</li>\n<li>I was more inclined to enforce the Single Responsibility Principle both at the View level and with Flux</li>\n</ul>\n<h2 id=\"I-Learned-How-to-Test-the-Framework\"><a href=\"#I-Learned-How-to-Test-the-Framework\" class=\"headerlink\" title=\"I Learned How to Test the Framework\"></a>I Learned How to Test the Framework</h2><p>This probably seems obvious.  But this gets back to the problem with my normal way of learning a framework.  Let’s take something like Angular as an example.  I know Angular 1.  I can get a pretty respectable application put together in it.  But, because I didn’t learn it using TDD, I would be the first to admit that my ability to unit test an Angular application is pretty weak.  I’m actually planning to go back and rework my Angular 1 and Angular 2 reference applications using TDD just to get that experience.</p>\n<p>I recently started working with EXT again.  This time with version 6.  Guess what I spent the first couple of days learning how to do?  That’s right.  “What’s the best way to write code using EXT 6 that makes the code testable?”  How did I answer that question?  I wrote tests.</p>\n<p>I learned:</p>\n<ul>\n<li>If you use the ViewModel and ViewController and never have either call the View directly, you can create highly testable code.</li>\n<li>Unit tests in EXT are best written using PhantomJS instead of JSDom.  Although, I’d still like to go back and try to make JSDom work.</li>\n</ul>\n<p>In React JS, I learned:</p>\n<ul>\n<li>View components are easier to test if they only do one thing.  Favor composition over monolithic view component.</li>\n<li>Stores (the part responsible for CRUD actions) can also be EventEmitters</li>\n</ul>\n<h2 id=\"I-Didn’t-Develop-Bad-Habits\"><a href=\"#I-Didn’t-Develop-Bad-Habits\" class=\"headerlink\" title=\"I Didn’t Develop Bad Habits\"></a>I Didn’t Develop Bad Habits</h2><p>This one, to me, is probably the most significant reason for me to repeat this process in the future.</p>\n<p>Here’s the deal.  Every other time I’ve learned a new framework or language, I’ve learned it from a “let’s just get something working” perspective.  If I concentrated on testing at all, it was after I got it all working.</p>\n<p>The problem with this method is now I’ve learned how to get something working, but I haven’t really learned the best way to organize my code so that it can be tested or swapped out later if I need to.</p>\n<p>By writing my code using TDD, I will have to write the code in a way that is testable the first time.  This means that while it may have taken you over twice as long to get that first demo application up and running, all future applications will be written in a more efficient, more testable, and easier to maintain.</p>\n<h2 id=\"I-Learned-How-Testable-the-Framework-Really-Is\"><a href=\"#I-Learned-How-Testable-the-Framework-Really-Is\" class=\"headerlink\" title=\"I Learned How Testable the Framework Really Is\"></a>I Learned How Testable the Framework Really Is</h2><p>If you read last week’’s article, you know that the testability story for React JS is what really got me excited.  None of the other frameworks I have used have been testable starting at the view level.  This is one of the areas where Angular could improve.  I wish I had leaned Angular 1 using TDD because then I would have either figured out how to test decorators on directives or I would have found out that it is only possible under the certain conditions.</p>\n<p>So far, I think React is incredibly testable.  Although I have not had a chance to do some of the things I’ve done with Angular yet.</p>\n<h2 id=\"I-Learned-Where-the-Holes-Are\"><a href=\"#I-Learned-Where-the-Holes-Are\" class=\"headerlink\" title=\"I Learned Where the Holes Are\"></a>I Learned Where the Holes Are</h2><p>This goes back to learning the framework better.  Because I was testing along the way.  Because I implemented code coverage.  I discovered that the code coverage story is the weakest link right now.  This is because Istanbul in combination with ES2015 syntax, which is the preferred React JS JavaScript syntax, does not work well together yet.  So, you’ll never get 100% code coverage no matter how hard you try because the transpilers that convert your ES2015 code to ES5 code add in conditions that will never get triggered, which show up in Istanbul as uncovered conditions.  This is probably more a reflection of the state of JavaScript right now than any of the tools involved.  Had I been willing to convert all of my React JS code to ES5, I would have been able to get 100% code coverage all the way down from the view to the server.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>So, I invite you to try it yourself.  The next time you are learning a framework, learn ALL of it by testing it along the way.</p>\n",
            "tags": [
                "tdd",
                "learning"
            ]
        },
        {
            "id": "http://davembush.github.com/5-reasons-learning-terminology-increases-your-effectiveness-as-a-programmer/",
            "url": "http://davembush.github.com/5-reasons-learning-terminology-increases-your-effectiveness-as-a-programmer/",
            "title": "5 Reasons Learning Terminology Increases Your Effectiveness [As A Programmer]",
            "date_published": "2015-08-27T11:30:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/08/image3.png\" alt=\"image\" title=\"image\"></p>\n<p>A couple of weeks ago I wrote a post “<a href=\"/7-c-interview-questions-that-weed-out-the-losers/\">7 C# Interview Questions to Weed out Losers</a>” which was my most popular post yet.  As of this writing, it has received over 13,000 views.  It also got a lot of comments.</p>\n<p>While there are a lot of things I could respond to, the one I want to focus on today is what I would call, “The fallacy of concepts over terminology.” While none of the comments actually come out and say this, several imply that knowing the concept but not knowing the proper term for it is enough.  In conversations with people I’ve worked with, I’ve received similar feedback.  In fact, as recent as three years ago I actually told someone, “If you want someone who can pass some sort of test, I’m probably not your guy.  If you want someone who is an awesome programmer, I’m your guy.” But three more years of experience has changed my mind.</p>\n<h2 id=\"Knowing-the-Proper-Terms-Clarifies-Communication\"><a href=\"#Knowing-the-Proper-Terms-Clarifies-Communication\" class=\"headerlink\" title=\"Knowing the Proper Terms Clarifies Communication\"></a>Knowing the Proper Terms Clarifies Communication</h2><span id=\"more\"></span>\n\n<blockquote>\n<p>“’When <strong>I</strong> use a word,’ Humpty Dumpty said, in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’” – Through the Looking Glass, by Lewis Carroll</p>\n</blockquote>\n<p>Here are just a few examples of how knowing what a term actually means helps communication: As I’ve written before, I’ve been using Sencha’s EXTjs at my day job.  When I first started using this environment, the first thing I was told was that it uses the “MVC Architecture.”  Now, to me, MVC has a very specific meaning and more importantly implies certain qualities about how the code should be written.  Primary among them is that the Model, View, and Controller are loosely coupled.  Anyone who has used EXTjs 4 knows this is not necessarily true.  What they call the “Controller” is more accurately called a “ViewController” but even then, it isn’t really.  You can’t have a controller without having a view, which makes the whole thing quite hard to test.  This whole mislabeling thing set me back about two weeks in my attempt to learn the framework.</p>\n<p>Another example from my work place.  We’ve created our own ORM to access the DB2 database we have to work with.  Why?  Because DB2 doesn’t play nice with Entity Framework.  But here again, I was told that this code implemented a design pattern that it doesn’t really implement.  Since the number of times I have to interact with this code is trivial, it was not as costly to my learning.  But it did cause confusion.</p>\n<p>Probably the most notable misuse of a word in our industry is the word “Agile.”  As I’ve been interviewing, I’ve run into a lot of companies who call themselves “Agile” but I’ve found that what they mean by “Agile” is very different from how the Agile Manifesto defines Agile.  In fact, one of the questions I ask during the interview to companies who have promoted themselves as “Agile” is, “How do you define Agile?”  One of the first places I asked this question replied, “Oh that just means we program iteratively.” So, knowing the proper term for a concept, makes your communication clear.  But that doesn’t explain why I expect someone I’m interviewing to know the term I’m using.</p>\n<h2 id=\"Knowing-the-Proper-Term-Shortens-Communication\"><a href=\"#Knowing-the-Proper-Term-Shortens-Communication\" class=\"headerlink\" title=\"Knowing the Proper Term Shortens Communication\"></a>Knowing the Proper Term Shortens Communication</h2><p>Way back when I was first learning object oriented programming with C++, someone asked me what polymorphism was.  I couldn’t answer because I’d never heard of the word or hadn’t taken the time to find out what it means.  I can’t remember exactly.  But I had the same reaction many of you did.  “I know what virtual functions are and I know how to give a function multiple implementations by changing the signature, I just don’t know the word for it.” But you see, it is much easier to ask, “What is polymorphism?”  Than it is to ask, “What do the keywords ‘overridable’, and ‘overrides’ do?”  And then have to follow up with “what does the ‘new’ keyword do when placed in front of a method declaration?” Spoken languages have terms for the various parts of speech.  If you are a programmer, I’m sure you know about this, even if you can’t name them.  But, let’s say you were a professional writer or an editor.  You probably wouldn’t be able to even get a job if you couldn’t talk about the various parts of speech using the proper terms.  And yet, many of us expect that we should be allowed to write code without having the same ability.</p>\n<p>Which leads to my next reason.</p>\n<h2 id=\"Knowing-the-Proper-Term-Aids-in-Learning\"><a href=\"#Knowing-the-Proper-Term-Aids-in-Learning\" class=\"headerlink\" title=\"Knowing the Proper Term Aids in Learning\"></a>Knowing the Proper Term Aids in Learning</h2><p>My family is a languages family.  My wife knows English, French, Latin (from teaching the kids), and Biblical Greek.  My daughter was an English major and learned Latin during High School.  My oldest son, knows English, Latin, Greek, and a bit of German.  My youngest son knows English, Latin, a bit of Greek and German.  I barely know English well enough to get these post written every week.  Which gives me a unique perspective.</p>\n<p>What I’ve learned as I’ve watched my family play with languages is that because they know the parts of speech in the various languages, as they pick up a new language, they can talk about a word being in a particular tense, or case, or whatever and everyone knows exactly what they are saying, making it that much easier to pick up a new language.</p>\n<p>In fact, while my son was learning German in High School, he would come home and talk to his mom and sister in German and they would be able to make out most of what he was saying because they had enough back ground in other languages and when they didn’t know something they could talk about it using the terms for the various parts of speech.</p>\n<p>This was true for me as I moved from C++ to Java and then to C# and VB.NET.  Because I already knew what polymorphism was, all I needed to know was the mechanisms in the other languages that made that feature happen.</p>\n<h2 id=\"If-You-Know-the-Terminology-You-Probably-Know-the-Concept\"><a href=\"#If-You-Know-the-Terminology-You-Probably-Know-the-Concept\" class=\"headerlink\" title=\"If You Know the Terminology, You Probably Know the Concept\"></a>If You Know the Terminology, You Probably Know the Concept</h2><p>One of the complaints I got specifically accused me of asking questions that only proved that the applicant could pass a test.  And this is true.  If all I were to ask were these questions, this would be a bad interview indeed.  But here’s what I’ve found.  Most of the time, if you can answer the questions I’ve asked in that article, you are much more likely to be able to answer the questions I really care about.  “Are you a hack, or do you really know what you are doing?” The market is flooded with programmers with less than 5 years of experience being presented by recruiters who know nothing about programming.</p>\n<p>Using the metric of charity over what I see coming in for interviews, here is what I think is happening.</p>\n<p>Recruiter sees an applicant that has most of the buzzwords on his resume that the company they are recruiting for is looking for.  But they are missing a critical buzzword, so the recruiter adds this prior to passing the resume on.</p>\n<p>Having been on a lot of interviews over the years, I have to assume that this works enough of the time to make it worthwhile because there are some places that I’ve interviewed where I haven’t had to prove I was technically capable at all.  In fact, I’ve been on a few interviews where the resume they have for me doesn’t look anything like what I gave the recruiter.</p>\n<p>And so, those of us on the receiving end of this have to have some quick way of determining, “do you know anything?”</p>\n<h2 id=\"Knowing-the-Concept-Isn’t-Enough\"><a href=\"#Knowing-the-Concept-Isn’t-Enough\" class=\"headerlink\" title=\"Knowing the Concept Isn’t Enough\"></a>Knowing the Concept Isn’t Enough</h2><p>Keep in mind, I used to think that knowing the concept WAS enough.  But what I’ve come to realize is that if I know a concept but I don’t know the proper terms for it, I probably don’t know the concept as well as I could.  Sure, I can write code all day long.  But, it doesn’t mean I will write the best code that I can.  It just means that I’ll get the job done.</p>\n<p>But once I spend the time to learn not just the concept, but the words that describe the concept, I’ve become a student of my craft.  I’ve proven that this is more than a job.  I’ve become a true professional.  Anything less and I’ve proven that I’m a really good hack at best.</p>\n<p>I realize that this may offend some of you.  So, let me soften this.  I’m not saying you are a bad programmer if you don’t know the proper terms for what you are doing.  What I’m saying is you aren’t as good of a programmer as you could be.  And for those of you who might disagree, the question I have to ask is, “how do you know?”  If you are still defending not having to know this, I have to make the assumption that it is because you are happy not knowing the terms.  Meaning you have nothing to compare where you are to where I am proposing that you should be.  Why not try becoming a student of programming and seeing for yourself if what I am saying has any merit or not.</p>\n",
            "tags": [
                "programming",
                "learning"
            ]
        }
    ]
}