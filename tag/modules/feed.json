{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"modules\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/why-more-angular-modules-are-better-than-one/",
            "url": "http://davembush.github.com/why-more-angular-modules-are-better-than-one/",
            "title": "Why more Angular Modules are Better than One",
            "date_published": "2018-01-16T11:30:00.000Z",
            "content_html": "<p>I recently reviewed some Angular code that uses one module.  The AppModule. To manage the entire code base.  And, this isn’t tiny code base.  The main excuse I’ve heard for this is that the code originated during the beta cycle, prior to NgModule being added to the framework.  I call it out as an excuse because once it was added, it was clear that we needed to have more than one module.  The fact that this code base doesn’t have more than one module shows a disregard for doing things right over doing things fast.  In the best case, it shows ignorance.</p>\n<p>But, the larger question this code base raises for me is this: “Why are more modules better than fewer modules?”  After all, using one module obviously works.  Isn’t the fact that it works sufficient enough?</p>\n<p>And here are three really good reasons to use more modules. <figure><img src=\"/uploads/2018/01/2018-01-16-1.jpg\" title=\"Why more Angular Modules are Better than One\"><figcaption>Photo credit: <a href=\"//visualhunt.com/author/1d5a2d\">goodrob13</a> on <a href=\"//visualhunt.com/re/0a04dc\">Visualhunt.com</a> &#x2F; <a href=\"//creativecommons.org/licenses/by/2.0/\"> CC BY</a></figcaption></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Avoid-Component-Collision\"><a href=\"#Avoid-Component-Collision\" class=\"headerlink\" title=\"Avoid Component Collision\"></a>Avoid Component Collision</h2><p>For discussion purposes, let’s say you have an application with two routes.  Each route allows you to edit different kinds of content.  You may be inclined to create some child components in each route to assist with your functionality.  In the process of doing this, you may end up with two components that have the same name.  Both as a class and as a selector.  If you are including everything in one mega module, you will need to artificially give the components different names.  However, if each route has its own module, you can declare the components in the declaration section of each module with the same name and each route will be able to call the appropriate component.  Components aren’t shared across modules until you export the component.  In that case, you would also want the component to live in a shared module where we would give it a more meaningful, generic, name that made sense as a shared module.</p>\n<h2 id=\"Lazy-Loading\"><a href=\"#Lazy-Loading\" class=\"headerlink\" title=\"Lazy Loading\"></a>Lazy Loading</h2><p>Once you’ve created modules for each of your routes, the next logical step in your development effort will be lazy loading the module.  Lazy loading provides more advantages than just the ability to load only what you need when you need it.  That’s just the most obvious gain.  Lazy loading also provides a separate context for @Injectables.  Once again, just like having the ability to isolate the components, by using modules in conjunction with lazy loading, we have the ability to have route specific @Injectables with the same name and each route&#x2F;module will behave appropriately.</p>\n<p>There is one caveat.  You can’t provide an @Injectable in a lazy loaded module and an application level module and expect things to work correctly.  And, if you are still using a framework like NgRX 2 that needs to have access to services, you’ll need to make your services globally available.  This is one of many reasons why I believe you should upgrade to NgRX 4 as soon as is possible.  This allows you to take full advantage of the Angular Lazy Loading capabilities and all their benefits.</p>\n<h2 id=\"Cleaner-Code\"><a href=\"#Cleaner-Code\" class=\"headerlink\" title=\"Cleaner Code\"></a>Cleaner Code</h2><p>Even if you’ve never seen a major application with one module, I’m sure you can imagine what a mess that module is.  I don’t think I really need to say much more about this.</p>\n<p>For more on Angular Modules, I recommend <a href=\"//angular.io/guide/ngmodule-faq\">this FAQ that the Angular team put together</a>. <a href=\"//medium.com/@cyrilletuzi/understanding-angular-modules-ngmodule-and-their-scopes-81e4ed6f7407\">This Medium article</a> is also pretty good.</p>\n",
            "tags": [
                "angular",
                "modules",
                "ngmodule"
            ]
        },
        {
            "id": "http://davembush.github.com/dissecting-angular-2-modules/",
            "url": "http://davembush.github.com/dissecting-angular-2-modules/",
            "title": "Dissecting Angular 2 Modules",
            "date_published": "2016-12-20T12:30:00.000Z",
            "content_html": "<p>In the new world of Angular 2, and even in the world of Angular.js, you might feel like the concept of a module is the most difficult to wrap your head around.</p>\n<p>This is especially if you’ve only ever written client side JavaScript code. Once you’ve learned why you need a module, the temptation is to use one module for all your code. I am guilty of doing that myself when I first started. But, many times using one module for your entire application is the wrong thing to do because it reduces the ability to reuse your code in other modules. Once you understand why modules exist, you’ll begin to reason about how to use modules appropriately.</p>\n<figure>![](/uploads/2016/12/image-1.png \"Dissecting Angular 2 Modules\")<figcaption>Photo credit: [Sappymoosetree](//www.flickr.com/photos/bahkubean/416801559/) via [Visual hunt](//visualhunt.com) / [CC BY-ND](//creativecommons.org/licenses/by-nd/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Why-Do-Modules-Exist\"><a href=\"#Why-Do-Modules-Exist\" class=\"headerlink\" title=\"Why Do Modules Exist?\"></a>Why Do Modules Exist?</h2><p>When the Angular 2 project started, modules did not exist, even though they had existed in Angular.js. But as the RC process continued, it became obvious that modules were going to be necessary. We could have written our code without modules, but the amount of code we would need to repeat to get the same functionality would be dramatically greater.</p>\n<p>It also often becomes more complex and harder to reason about.</p>\n<p>So, what exactly do modules get us? If you’ve worked in languages in the past that have the concept of a namespace, it might help you to think of a module as a substitute for namespaces. They allow us to group similar functionality together, and specify what functionality that belongs to the module can be accessed by the outside world. For example, I recently wrote a component that all the applications in our organization will be starting out with. It is composed of multiple components, but I only want the top most component exposed to the developers who will be using it.</p>\n<p>So, modules allow us to both group code together and encapsulate code so that code that might otherwise be publicly available becomes private to the outside world.</p>\n<h2 id=\"Dissecting-Modules\"><a href=\"#Dissecting-Modules\" class=\"headerlink\" title=\"Dissecting Modules\"></a>Dissecting Modules</h2><p>You may remember that in the <a href=\"//github.com/DaveMBush/GettingStartedWithAngular2/tree/Step-4\">application we’ve been working on</a> we’ve already created a module. In fact, when you create any application using the CLI, there will always be this top-level module.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declarations: [</span><br><span class=\"line\">    AppComponent</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  imports: [</span><br><span class=\"line\">    BrowserModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    HttpModule,</span><br><span class=\"line\">    GettingStartedWithAngular2RoutingModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  providers: [],</span><br><span class=\"line\">  bootstrap: [AppComponent]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export <span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>The declarations section simply specifies the components that this module owns. In the case of our app so far, the only component it owns is the top-level AppComponent.</p>\n<p>The imports section loads modules this module is going to need available in the components it owns. Many times, the components we need access to are only needed in our templates. Prior to using modules, we would need to include our components in our TS files just so the templates could access them. By loading them in the module, we can load modules once even though we may have multiple components that are part of the module that may need them.</p>\n<p>Since our module is not using any injectables, the providers section is empty. But that is what the providers section is for. Any class that we will need to inject in the constructor of other code would be listed in this providers section.</p>\n<p>Finally, the bootstrap section has the one component this module should load. This only shows up in the top-level module. While it is needed, I’ve yet to figure out why. We’ve already loaded the module, and therefore the component and the tag for the top-level component is in our index.html file, so I can’t see the point of specifying it here yet again.</p>\n<p>You may wonder, “How does this AppModules get loaded?” Go back to the root of your app directory and look for the main.ts file. You’ll see that we loaded it in there.</p>\n<p>platformBrowserDynamic().bootstrapModule(AppModule);</p>\n<p>You might wonder why this code is not included in the application module. This is because you might not always want to use platformBrowserDynamic(). If you are using Web Workers to run your code or using Ahead of Time compile, you would use two other methods of bootstrapping the module. I’ve only mentioned three here, but there are others.</p>\n<p>The next property you are likely to see in a module declaration is the exports section:</p>\n<p>exports:  [Edit]</p>\n<p>This tells the module that has imported this module that it can use the Edit component. We didn’t need this in the app module because the app module isn’t being used by another module. It is the top most module and really can’t be used by any other module by definition.</p>\n<h2 id=\"Routing-and-Modules\"><a href=\"#Routing-and-Modules\" class=\"headerlink\" title=\"Routing and Modules\"></a>Routing and Modules</h2><p>Several weeks ago we took a look at <a href=\"/angular-2-lazy-loading/\">implementing Lazy Loading by modifying our routing module</a>. What is unique about this situation is that every time you lazy load a module, it becomes the top most module, so once again, there is no real need to export it.</p>\n<h2 id=\"When-Should-Modules-Be-Used\"><a href=\"#When-Should-Modules-Be-Used\" class=\"headerlink\" title=\"When Should Modules Be Used?\"></a>When Should Modules Be Used?</h2><p>As I said when I started, the temptation is to just put all our import statements that our application is going to need in our app module. But that seems like an extremely lazy way of writing code. And when you go to write lazy loaded modules, that’s not going to work so well for you. So, there are two ways you can approach this.</p>\n<p>First, you can just create a module for every component you write. It is probably over kill, but it would be hard to go too far wrong here. Given the choice between too many modules and not enough, I’d error on the side of too many. At least it gives you the flexibility do make necessary changes in the future.</p>\n<p>But the more reasonable approach would be one module per feature and a module for common stuff. For example, if you are writing a component library, you would probably be safe writing a module for all the components in your library so you only have to import the library module and all your component would automatically become available to you. You’ll want to at least want to have one module per route so that you can lazy load the routes if you decide that is necessary.</p>\n",
            "tags": [
                "angular",
                "javascript",
                "modules"
            ]
        },
        {
            "id": "http://davembush.github.com/vb-net-hide-module-name/",
            "url": "http://davembush.github.com/vb-net-hide-module-name/",
            "title": "VB.NET Hide Module Name",
            "date_published": "2013-08-28T13:11:12.000Z",
            "content_html": "<p><img src=\"/uploads/2009/06/misc_vol3_064.jpg\" alt=\"misc_vol3_064\" title=\"misc_vol3_064\"> Here’s a quick tip for those of you still using modules in your VB.NET applications.</p>\n<p>If you create a module and don’t want to see the module name in your intellisense, you can hide it with an attribute.  This can be extremely useful when you have a lot of modules that would show up in your intellisense code and they don’t have names that conflict with each other.</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;HideModuleName()&gt;</span><br><span class=\"line\"><span class=\"keyword\">Module</span> Module1</span><br><span class=\"line\">    <span class=\"keyword\">Sub</span> NewFunction()</span><br><span class=\"line\">        <span class=\"keyword\">Return</span></span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Module</span></span><br></pre></td></tr></table></figure>\n\n<p>You can still reference NewFunction() via Module1</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module1.NewFunction()</span><br></pre></td></tr></table></figure>\n\n<p>But Module1 will no longer show in intellisense.</p>\n",
            "tags": [
                "modules",
                "hide",
                "vb.net attributes"
            ]
        }
    ]
}