{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"types\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/javascript-types-nuance/",
            "url": "http://davembush.github.com/javascript-types-nuance/",
            "title": "JavaScript Types Nuance",
            "date_published": "2016-04-28T11:30:00.000Z",
            "content_html": "<p>I was once teaching a class on JavaScript to a group of C# developers when someone asked a very logical question, “Are JavaScript Types all derived from Object?” I loved teaching this particular group because they were actively engaged in the material.  So many times, when I teach, the students simply absorb what I say, but they don’t interact with it.  They never ask the question, “What are the implications of what is being said.” My initial instinct was to say ‘no’ based on my experience with the language.  But then as I thought about it later, I thought, “But when I use the debugger on what seems to be a primitive, don’t I see it as an object?”  And as it turns out, my instinct was right.  Not everything in JavaScript is an object.  Although there is quite a bit that you wouldn’t think was an object that is.</p>\n<p>Now that we’ve covered <a href=\"/javascript-objectswhat-you-dont-know-can-hurt-you/\">JavaScript Objects</a> and <a href=\"/javascript-fields/\">JavaScript Object Fields</a>, it is time to move on to the specifics of JavaScript types.</p>\n<p>So, why is it, when I look at some primitive values, I see them as objects?  And which types are objects and which are primitives?</p>\n<figure>![](/uploads/2016/04/image-4.png \"image\") Photo via [Visualhunt](//visualhunt.com/)</figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"A-Review-of-JavaScript-Types\"><a href=\"#A-Review-of-JavaScript-Types\" class=\"headerlink\" title=\"A Review of JavaScript Types\"></a>A Review of JavaScript Types</h2><p>The fundamental types available to us in JavaScript are:</p>\n<ul>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>object</li>\n<li>null</li>\n</ul>\n<p>However, if you use the <code>typeof</code> operator on null, you’ll get back “object” as the type.</p>\n<p>While <code>null</code> is a unique type, it makes sense for <code>typeof</code> to return “object” since the only kind of variable that could return a <code>null</code> would be an <code>object</code>.</p>\n<h2 id=\"When-is-an-object-not-and-object\"><a href=\"#When-is-an-object-not-and-object\" class=\"headerlink\" title=\"When is an object not and object?\"></a>When is an object not and object?</h2><p>There is one other common type that is a bit of an odd ball.  The function type.</p>\n<p>What makes function odd is that it is, technically it is a sub-type of object.  This is good to know, and will put you light years ahead of your peers once you realize the implications.  Because a function IS an object, you can give a function additional fields.  In fact, a common way to override a function looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> originalSubstring;</span><br><span class=\"line\"><span class=\"keyword\">var</span> substringOverload = <span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">originalSubstring</span>(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">originalSubstring = a.<span class=\"property\">substr</span>;</span><br><span class=\"line\">a.<span class=\"property\">substr</span> = substringOverload;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<p>(Note: the code above won’t really work, I’m just illustrating a point).</p>\n<p>You may have done something like the above using functions in libraries.  As long as the field is not read-only, you can do this kind of overload of a function.</p>\n<p>But, a better way, now that we know that a function is just an object, is to assign the old function as a field of the original function:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> substringOverload = <span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> substringOverload.<span class=\"title function_\">substr</span>(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">substringOverload.<span class=\"property\">substr</span> = a.<span class=\"property\">substr</span>;</span><br><span class=\"line\">a.<span class=\"property\">substr</span> = substringOverload;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"What-about-Arrays\"><a href=\"#What-about-Arrays\" class=\"headerlink\" title=\"What about Arrays?\"></a>What about Arrays?</h2><p>Another place you may not be used to thinking clearly about variable types is with Arrays.  You might think an array is its own type.  That an Array is an Array.  But in reality, Arrays are a type of Object.  In fact, if you were to run the typeof operator against a variable that holds an Array, you would see that it is an object.</p>\n<p>Once again, because you know this, you can use this information to your advantage.</p>\n<p>You could provide your array, its own implementation of each:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">each</span> = <span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"title function_\">callback</span>(<span class=\"variable language_\">this</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a.<span class=\"title function_\">each</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>This is essentially how polyfills are created.  If you write one, make sure you put in the additional code to make sure the function isn’t already implemented.  And don’t ever add a function to a native object like this without it having been declared by the standards committee as a function that is part of the spec.  Polyfills exist so that you can make older JavaScript implementations work as though they were using newer standards.  Not so we can add our own new functions to the language.  If you do, you could find yourself having a maintenance nightmare on your hands some day in the future.</p>\n<h2 id=\"Newing-a-Type\"><a href=\"#Newing-a-Type\" class=\"headerlink\" title=\"Newing a Type\"></a>Newing a Type</h2><p>You can also write JavaScript that looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someNumber = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> someString = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&#x27;abc&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> someBool = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Which will give you an Object that contains the value we passed in.  And each of those object will have Number, String, or Boolean functions available to it.</p>\n<p>But, you don’t have to new a Number, String or Boolean to get those functions.  You can get the same ability by simply assigning the value to the variable.  Under the hood, when you want to use the function that are available to all objects, the JavaScript runtime will “box” the number, string, or boolean as an object so that you can access, for example, hasOwnProperty().</p>\n",
            "tags": [
                "javascript",
                "types"
            ]
        }
    ]
}