{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"observables\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/angular-observable-secrets-revealed/",
            "url": "http://davembush.github.com/angular-observable-secrets-revealed/",
            "title": "Angular Observable Secrets Revealed",
            "date_published": "2017-08-08T10:30:11.000Z",
            "content_html": "<p>If you’ve been programming JavaScript based applications for any length of time, you’ve probably already made the progression from callback hell to promises, but just to recap.  Whenever we make any kind of asynchronous call in JavaScript, we need to provide a callback function to the call so that, when the call completes, the function can be called with any resulting data.  Function calls you may typically make that need this kind of feature are <code>setTimeout()</code>, <code>setInterval(),</code> and AJAX calls using the various libraries that support this. </p>\n<p>The problem with using callbacks is that you can end up with “Callback Hell” where you have callbacks inside of other callbacks.  Our code becomes messy and difficult to reason about. </p>\n<p>To try to flatten this situation out, promises were created.  Instead of creating a callback function and passing it into the asynchronous function, the asynchronous function returns a promise that has a function we can pass our function into.  This function can return yet another promise.  The result is that instead of having nested callbacks, all of our callbacks live at the same level. </p>\n<p>However, in the process, we lost the ability to cancel an asynchronous function using callbacks.  Most of the time, this was not a huge concern, but in the case of AJAX calls, we did end up making more request than we really needed to.  Most people never even recognized this as an issue.  But if you go and take a look at some of your older code, you will see that you have several places where the code would work more efficiently if you were able to cancel a call that was being superseded by a new call. </p>\n<p>Meanwhile, some additional functions were added to JavaScript Arrays.  Maybe you’ve seen some of them?  map(), reduce(), and filter() are three of the more common functions. </p>\n<p>What?  You haven’t seen these?  If you have and you know how they work, you can skip this next section.  But, if you haven’t, pay careful attention because this next section is critical to understanding how Observables work. <figure><img src=\"/uploads/2017/08/2017-08-08.jpg\" title=\"Angular Observable Secrets Revealed\"> Photo via <a href=\"//visualhunt.com/re/4ba464\">VisualHunt.com</a></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Array-Functions\"><a href=\"#Array-Functions\" class=\"headerlink\" title=\"Array Functions\"></a>Array Functions</h2><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>Let’s say you have a list of objects that you need to transform into another form.  In the example below, we want to transform our list of objects into a list that can be used in a dropdown list using fullName for the display and id for the value. </p>\n<p>Without using <code>map()</code>, your code might look something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = []; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; someList.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> item = someList[i];</span><br><span class=\"line\">   newArray.<span class=\"title function_\">push</span>(&#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The thing is, we do most of the code from <code>newArray = []</code> on down over and over again.  It is only the code in the <code>push()</code> that changes. </p>\n<p>What if we were to make the code into a function?  That’s what <code>map()</code> does.  It takes a function as a parameter that takes an item as a parameter.  Inside the function, we use that item to specify how we want to transform the item and the whole map() function returns the new array. </p>\n<p>The code above, turns into this.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = someList.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>Now, let’s say that for some reason, you only want to include items in the new array that include a last name that starts with ‘B’. Our old style code would look something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = []; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; someList.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> item = someList[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(<span class=\"params\">‘B’</span>) &#123;</span><br><span class=\"line\">       newArray.<span class=\"title function_\">push</span>(item);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And once again, this is code we tend to write quite a bit.  So, what if we had a function that did this for us? </p>\n<p>This is exactly what the <code>filter()</code> function is for.  So, rewriting the code above using <code>filter()</code> would look like this.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\">newArray = someList.<span class=\"title function_\">filter</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Chaining\"><a href=\"#Chaining\" class=\"headerlink\" title=\"Chaining\"></a>Chaining</h3><p>Once again, you can see that we passed in a function that takes the current item as a parameter.  The function returns true or false.  If it returns true, the item gets included in the new array. </p>\n<p>What if we want to filter AND transform the data? </p>\n<p>The temptation for programmers new to this model is to use the map and push the item into an array that was declared outside of the map. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = [];</span><br><span class=\"line\">someList.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’)) &#123;</span><br><span class=\"line\">       newArray.<span class=\"title function_\">push</span>(&#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">           item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>But that really isn’t all that much better than if we were just using a for&#x2F;next loop like we’ve been doing.  Old habits die hard. </p>\n<p>Instead, we can take advantage of function chaining. What this allows us to do is to filter and then map. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someList = [</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">Dave</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Bush</span>’&#125;,</span><br><span class=\"line\">   &#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">firstName</span>: ‘<span class=\"title class_\">John</span>’, <span class=\"attr\">lastName</span>: ‘<span class=\"title class_\">Doe</span>’&#125;,</span><br><span class=\"line\">   …</span><br><span class=\"line\">];</span><br><span class=\"line\">newArray = someList.<span class=\"title function_\">filter</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> item.<span class=\"property\">lastName</span>.<span class=\"title function_\">startsWith</span>(‘B’);</span><br><span class=\"line\">&#125;.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span>(<span class=\"params\">item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> &#123;<span class=\"attr\">fullName</span>: item.<span class=\"property\">firstName</span> + ‘ ‘ +</span><br><span class=\"line\">       item.<span class=\"property\">lastName</span>, <span class=\"attr\">id</span>: item.<span class=\"property\">id</span>&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>So much cleaner.</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>The final useful function we have available to us for dealing with common array loops is reduce().  reduce() allows to loop through an array and accumulate the items in an array into another array, an object, or a value. </p>\n<p>The reduce() function take two parameters.  The first parameter is a function.  The second parameter is the starting value for the accumulator. </p>\n<p>The function that we pass in takes three parameters.  The current value of the accumulator, the current item, and the current item index.  Most people only use the first two parameters in their function.  The function returns the new accumulator value that then gets passed into the next call to the function. </p>\n<p>So, a really simple example would be, given an array of numbers, add them all up. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = numbers.<span class=\"title function_\">reduce</span>(<span class=\"keyword\">function</span>(<span class=\"params\">sum, item</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> sum + item;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>I’ve also used this to turn an array of name&#x2F;value pairs into an object where the properties are the name and the values are the values that were paired with the names.</p>\n<h2 id=\"Events-as-Arrays\"><a href=\"#Events-as-Arrays\" class=\"headerlink\" title=\"Events as Arrays\"></a>Events as Arrays</h2><p>Now, imagine that events that fire are part of one long continuous array.  An array that never ends. If this were true listening to events would be as familiar as processing an array. </p>\n<p>This is all an observable is.  It treats everything as though it were an array, adds several other functions that give us even greater functionality, and several functions that allow us to deal with the fact that events are not only sequential, but also time based. </p>\n<p>And because events aren’t really arrays, we call this series of items a “stream.”  So, when you read about “streams” while working with Observables think, “list of items.”</p>\n<h3 id=\"Button-Click\"><a href=\"#Button-Click\" class=\"headerlink\" title=\"Button Click\"></a>Button Click</h3><p>For example, let’s say you have a button on your screen and you want to know when it is pressed.  Let’s say your button is represented by a member variable name “myButton”.  In your code, you would listen to a button click by writing code that looks something like: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"title function_\">fromEvent</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">myButton</span>,<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> </span><br><span class=\"line\">   <span class=\"comment\">/* do something in response to the click here */</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>You will notice that we used the <code>subscribe()</code> function instead of <code>map()</code>.  We still have a <code>map()</code> function.  But, <code>subscribe()</code> is how we tell the application, “we want to start listening to the stream now.”  Otherwise, <code>subscribe()</code> works just like map() does. </p>\n<p>Yes, I know what you’re thinking.  “How is that better than just having the template call an event handler?” </p>\n<p>Well, the fact of the matter is, it really isn’t all that much better.  But, here is where it does make more sense.</p>\n<h3 id=\"Debouncing-Keystrokes\"><a href=\"#Debouncing-Keystrokes\" class=\"headerlink\" title=\"Debouncing Keystrokes\"></a>Debouncing Keystrokes</h3><p>If you’ve been writing application in JavaScript for a while, I’m sure you’ve written classic debounce handlers.  You know.  Don’t actually fire this event until you are no longer receiving change events from the input field. </p>\n<p>I won’t write out the old code here.  It is relatively long, hard to follow, and therefore somewhat complicated. </p>\n<p>But here is how we handle it using Observables. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"title function_\">fromEvent</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">myInput</span>,<span class=\"string\">&#x27;change&#x27;</span>).<span class=\"title function_\">debounceTime</span>(<span class=\"number\">250</span>).<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">/* do something in response to the input field change here */</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>debounceTime(250)</code> tells the Observable to wait for 250 milliseconds to see if there is some other event that comes in and use that event instead.  That is much easier than the old way.</p>\n<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><p>While you could handle button clicks and debounce logic using old school JavaScript tricks, in Angular, it is practically impossible to make an AJAX call without using Observables.  This is because the <code>Http</code> service and the <code>HttpClient</code> that was introduced in Angular 4.3 use Observables instead of callbacks or promises to manage dealing with the data that eventually is returned from the AJAX call. </p>\n<p>Since <code>Http</code> and <code>HttpClient</code> are similar, we will continue our discussion of handling AJAX calls using <code>HttpClient</code>.  The main advantage to using <code>HttpClient</code> is that it handles parsing the response into a JavaScript object we can use.  <code>Http</code> just returns the raw Response object and parsing it out is up to us. </p>\n<p><code>HttpClient</code>, on the other hand, returns the object we would have parsed out with <code>Http</code>. </p>\n<p>NOw, assuming you’ve injected HttpClient into the class that is going to use it, a typical get might looks something like this: </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(<span class=\"string\">&#x27;/api/get-data&#x27;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span> );</span><br></pre></td></tr></table></figure>\n\n<p>So, walking through this, you may notice that some things look very similar to Promises and then, there are some other things that aren’t so much.  But trust me this gets much better.  We are just starting out small. </p>\n<p>First, what is that <code>TypeInfo</code> thing? </p>\n<p>You see, our get call is what is normally referred to as a “templated method.”  In simple terms, get doesn’t know what type it returns until you tell it.  So, we are telling it that it returns a <code>TypeInfo</code> type.  <code>TypeInfo</code> is just a name I made up.  You would create an interface that is relevant to the type of information that your AJAX code is returning. </p>\n<p>Other than that, we subscribe to the observable that get() returns and process the data. </p>\n<p>Noq, what if our get call fails? </p>\n<p>Oh! We have methods for that. </p>\n<p>First, we can trap failures with a <code>catch()</code> call. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(‘/api/get-data’)</span><br><span class=\"line\">   .<span class=\"title function_\">catch</span>(<span class=\"attr\">err</span>: <span class=\"function\"><span class=\"params\">Error</span> =&gt;</span> <span class=\"comment\">/* do something with the error */</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Next, maybe you want to <code>retry</code> the failed call before you give up. </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">httpClient</span>.<span class=\"property\">get</span>&lt;<span class=\"title class_\">TypeInfo</span>&gt;(‘/api/get-data’)</span><br><span class=\"line\">   .<span class=\"title function_\">retry</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">catch</span>(<span class=\"attr\">err</span>: <span class=\"function\"><span class=\"params\">Error</span> =&gt;</span> <span class=\"comment\">/* do something with the error */</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">x: TypeInfo</span>) =&gt;</span> <span class=\"comment\">/* do something with the data */</span>);</span><br></pre></td></tr></table></figure>\n\n<p>And because we have a <code>catch()</code>, with must have a <code>finally</code> too, right? </p>\n<p>Try doing all of that with a Promise or a Callback. </p>\n<p>Oh, and did I mention you can cancel AJAX calls using Observables?  Yep.  It’s true.  In fact, my experience has been that if you make the same call from the same service two times in a row, it will cancel the first call before it makes the second.  Pretty cool. </p>\n<p>The final thing that tends to trip people up who are learning about Observables is that nothing in the observable chain executes until you subscribe to the observable and an event happens. </p>\n<p>Once you start getting comfortable with all of the methods you have available to you, you’ll begin to see the power of using Observables over using Promises or Callbacks, even if there are similarities.</p>\n",
            "tags": [
                "angular",
                "observables",
                "RxJS"
            ]
        }
    ]
}