{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"dry\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/4-reasons-to-write-loosely-coupled-code/",
            "url": "http://davembush.github.com/4-reasons-to-write-loosely-coupled-code/",
            "title": "4 Reasons to Write Loosely Coupled Code",
            "date_published": "2016-09-27T10:30:00.000Z",
            "content_html": "<p>This past week I got into a small discussion about the importance of loosely coupled code.  Specifically, I was looking at event handler code that did nothing more than change the size of another element on the screen.  But the event handler code was in the controller which in the particular implementation we are using was the event handler portion of our Model in a MVVM architecture.  The question becomes does this code belong in the view, or does it belong in the controller? The question of where code belongs leads eventually to arguments for loosely coupled code.  If I put code in my controller that is manipulating the view, then I either need to mock out my view in order to test my controller or I have to have an instance of my view available to test my controller.  Having coded enough systems to know that both of those choices are problematic, I opt for placing the view specific code in the view.  Another place where you might place this code would be in a View Specific event handler class.  But that would only be for the purposes of clean separation.  Something we might consider doing if the View were plain HTML.  But in our particular case, the view is generated from code, so placing the handlers in that same code seems to be the most appropriate location for it.</p>\n<p>But all of this leads to a larger question.  Why should your code be loosely coupled at all? <figure><img src=\"/uploads/2016/09/image-2.png\" title=\"4 Reasons to Write Loosely Coupled Code\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/hernanpc/7115374283/\">Hernan Piñera</a> via <a href=\"//visualhunt.com\">VisualHunt.com</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA</a></figcaption></figure></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Refactoring\"><a href=\"#Refactoring\" class=\"headerlink\" title=\"Refactoring\"></a>Refactoring</h2><p>One of the main advantages of loosely coupled code is that this combined with granularity makes code refactoring easier.  Because my controller class only handles events that cause data to be manipulated and does not cause any changes to the view, I know that any changes I make to my controller will not cause any unexpected presentation layer changes.</p>\n<p>Similarly, and in this case, more importantly, any changes I make to the view will not force me to make changes to the controller class.  That is, all of the code that could be impacted by any one change happen in one and only one class.</p>\n<p>Loose coupling can also occur horizontally, and often does without us thinking too intensely about it.  Have you ever used a control from one vendor only to find another control works better?  The more easily those controls match each other’s programmable interface, the easier the job was to swap them out.  We can do the same type of thing in our own code.  The more granular the code is broken down; the easier any one part of the code can be replaced by something that works “better”.</p>\n<h2 id=\"More-Maintainable\"><a href=\"#More-Maintainable\" class=\"headerlink\" title=\"More Maintainable\"></a>More Maintainable</h2><p>But the argument might be make that this is a lot of work for something that isn’t very likely to happen.  But anyone who has been programming more than a few years on essentially the same system knows that it does.</p>\n<p>Here’s how it looks.  You start out writing a system and you care very little about coupling or not.  Hey, we’ve got code to write and very little time.  Full steam ahead and forget best practices.  And for now, let’s assume you have a small enough system that you actually pull it off.  You get the system delivered, and somehow it miraculously works.  Congratulations.</p>\n<p>A few months go by and you get a new requirement or a change request comes in for an existing requirement.  Either way, you manage to shoe horn the change in.</p>\n<p>More time goes by and a change to the last set of changes comes in.  And now you realize that what you have is a rather fragile architecture that can’t possibly sustain the new request.  A change that might have taken a month given a more loosely coupled architecture is now going to take three because of the amount of rework that is going to be required.</p>\n<p>Another way that loosely coupled code helps is when you are writing a very large system.  Let’s say the system is large.  You write this for a few months and everything seems to be going fine when you hit that first, “oops! we forgot” moment.  So you have to go back and retro fit the change into your tightly coupled code.  And then you progress some more and hit even more of those kind of changes.  Eventually, everyone learns to hate this system because it is so hard to work on and every change we make to existing code causes more and more bugs.</p>\n<h2 id=\"Cross-Platform\"><a href=\"#Cross-Platform\" class=\"headerlink\" title=\"Cross Platform\"></a>Cross Platform</h2><p>Refactoring and maintenance have some practical implications beyond just being able to work on your code.  In this world of multiple platforms, you may find yourself wanting to run some of what you’ve written on another platform.  There are multiple ways you might do this, but keeping your code isolated is going to make this easier.  Say you want to run your code on the web, as a desktop application, on the various mobile phones and tablets that are available.  Even if you do this all in the confines of HTML, JavaScript and CSS, you will most likely have different presentation layers.  If you have view specific code (to use our example again) that isn’t in the view, you’ll need to write code in the controller that detects which of the platforms you are running on.</p>\n<p>But if you’ve decided to use native components on each of the platforms, the view layer is actually going to change drastically.  And the view specific code you wrote might not even work on the new platform.  All the more reason to keep the view code isolated.</p>\n<h2 id=\"Cross-Framework\"><a href=\"#Cross-Framework\" class=\"headerlink\" title=\"Cross Framework\"></a>Cross Framework</h2><p>Or, maybe you are going to upgrade your framework.  Angular 2 just released and it is drastically different from Angular 1.  I can tell you right now, the organizations who wrote loosely coupled Angular 1 code are going to have a much easier time transitioning to Angular 2.  Or maybe you want to switch from Angular to React, or from any of the multitude of frameworks to another.  The more loosely coupled your code, the easier it will be to move.  And nowhere is this more obvious than in the fast moving JavaScript world.</p>\n<h2 id=\"Single-Responsibility\"><a href=\"#Single-Responsibility\" class=\"headerlink\" title=\"Single Responsibility\"></a>Single Responsibility</h2><p>Loosely coupled code is strongly related to the Single Responsibility principle.  You can’t have loosely coupled code unless the code follows the Single Responsibility principle.  And in the case above, putting view code in our controller actually violates both at the same time.  The controller is for manipulating view agnostic data.  The view is where your presentation layer code goes.  Of course, we could turn this around and remove the controller and put all of our code in the View.  Now that would definitely violate the single responsibility principle while giving the appearance of loose coupling.  But if we ever had to create multiple views we would quickly violate yet another principle.  Don’t Repeat Yourself.</p>\n<h2 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing?\"></a>Testing?</h2><p>Normally, I would lead off with testing.  But the argument could be made, “If I’m not going to write unit test, do I still need to do this?”  Actually, someone did make that argument.  And for now, ignoring that not writing unit test is a bad idea that I’ve written about before.  Writing unit test helps us think about these issues up front.  It isn’t that testing is the reason we write good code, although if that’s how you want to think about it I’m not going to stop you.  It is just that writing good test causes us to write good code.  Since it is the most visible benefit we tend to think of it first.  But testing isn’t at all why we do this.  We write test because it provides benefits much like loose coupling does.  Saying that we write loosely coupled code that follows the single responsibility principle so we can test would be like saying we don’t get lost so we can use our GPS.  It is the GPS that helps us to not get lost.  In the same way, it is the test that cause is to write good code.</p>\n<h2 id=\"Best-Practices\"><a href=\"#Best-Practices\" class=\"headerlink\" title=\"Best Practices\"></a>Best Practices</h2><p>I know I’ve been following best practices for so long that I often forget why I’m doing them.  They work.  I do them.  But every once in a while, I need to step back and take a look at what I’m doing and ask “Why?” once again.</p>\n",
            "tags": [
                "tdd",
                "DRY",
                "loose coupling",
                "single responsibility"
            ]
        },
        {
            "id": "http://davembush.github.com/dry-programming/",
            "url": "http://davembush.github.com/dry-programming/",
            "title": "DRY Programming",
            "date_published": "2014-05-29T16:34:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/05/DRY.png\" alt=\"DRY\" title=\"DRY\">Today I thought I’d talk to you about the programming principle known as DRY.  As you may know, DRY stands for “Don’t Repeat Yourself” and it shows up in a lot more places than you might expect.  Even when you try really, really hard to not repeat yourself, you end up repeating yourself.  You repeat yourself even when you think you aren’t.  Lots of people repeat themselves.  Do you know of any? Ok.  I think you get the point.  Just like it is silly for me to repeat myself over and over again, it is silly for you to write the same code, or perform the same steps, over and over again.</p>\n<p>To drive the point home just a little bit more.  Do you know what the acronym WET stands for?  We Enjoy Typing.  While it doesn’t capture all of what DRY is trying to combat, I think it hits about 80% of the issue.  Have you typed something that is really similar to something you already typed?</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Copy-and-Paste\"><a href=\"#Copy-and-Paste\" class=\"headerlink\" title=\"Copy and Paste\"></a>Copy and Paste</h2><p>The most obvious form of something that is WET is code that is an exact duplicate of something you already wrote some place else.  This can be something as mundane as code that is in the same class, to code that exist in multiple classes. In fact, I just ran into this today with some code I was working on.  The person who had written the code had created a local variable to hold a string that he was then passing into multiple methods.  That was good.  This allows us to change the string once instead of changing it in multiple places.</p>\n<p>However, he was doing the same thing in three different methods of the same class.  And in two other places he was using that same string as a string instead of using a variable.</p>\n<p>Since the string was a reference to a field name, it seemed to me to make more sense to create the variable as a constant member variable in the class and use it in all of the locations.</p>\n<p>Copy and paste issue solved.</p>\n<p>But what about the case where you need to do something similar but the code is in multiple classes?  In this case, what you’d probably want to do is to create a static class that will have a static property that will return the string.  Better yet, you could put the string in a resource file that you can reference from the static class.</p>\n<h2 id=\"Copy-Paste-and-Modify\"><a href=\"#Copy-Paste-and-Modify\" class=\"headerlink\" title=\"Copy, Paste and Modify\"></a>Copy, Paste and Modify</h2><p>The most difficult area in our code to detect that our code is WETter than it should be is when we create code that we’ve done the Copy, Paste, and Modify routine to.  This is because it is similar but not exactly similar.  This is where a huge chunk of our WET code resides.</p>\n<p>So as you navigate through your code, you should be looking for code that is similar but not exactly the same and you should be asking yourself this question, “Is there any way I can merge this code so that it only appears once?” One way you might  make this kind of code DRY is by creating a method that takes parameters.  The parameters will let you pass in the stuff that is different while allowing the bulk of the code that is similar to be in one location.</p>\n<p>Another way you might deal with this problem is by creating a class with virtual functions that get called by a main method.  Then you can create child classes that have overridden methods that handle the differences in functionality.</p>\n<h2 id=\"Similar-Steps\"><a href=\"#Similar-Steps\" class=\"headerlink\" title=\"Similar Steps\"></a>Similar Steps</h2><p>The hardest type of duplicate code to detect is code that has similar steps.  If you find yourself doing the same thing over and over again, you probably have an area the you either need to deal with, like we dealt with Copy, Paste, and Modify, or you may need to think about creating code that writes your code for you.</p>\n<p>This is what techniques like T4 templates were created for.</p>\n<h2 id=\"Similar-Code-in-Different-Environments\"><a href=\"#Similar-Code-in-Different-Environments\" class=\"headerlink\" title=\"Similar Code in Different Environments\"></a>Similar Code in Different Environments</h2><p>One of the most natural places to deal with duplicate code is in the area of database access.  Typically we have to create tables or stored procedures in SQL, and then to access that code we need to write code in our main development language that mirrors the SQL code.  In CSharp, we create POCOs and CRUD routines.  And then if we are working on a web site, we need to mirror that code once again in JavaScript.</p>\n<p>This is a prime candidate for code that writes code.  If you don’t already have something that will do it for you, write some code that will look at your SQL and generate the code you need from that.  DRY says there should be one place that gets modified when a change to the database occurs.  That would be the database.</p>\n<h2 id=\"Not-Just-About-Code\"><a href=\"#Not-Just-About-Code\" class=\"headerlink\" title=\"Not Just About Code\"></a>Not Just About Code</h2><p>But DRY isn’t just about code.</p>\n<p>There are things we do every day that have nothing to do with code that are costing us time and money.  In fact, they probably cost more time and money than your WET code because they take longer to perform.</p>\n<p>One place this occurs all of the time is in making sure that your code builds.  If you are still doing this manually, you are wasting your time.  If you aren’t doing it at all, that’s even worse.  You may not know for months that your code isn’t building and you will find out at the worst possible time.  And assuming that you have been practicing Test Driven Development, how are you making sure that those tests still work every time you make a change to your code? The obvious solution is a Continuous Integration server that reports back to you that there was a problem.</p>\n<p>What about error logs?  You are logging the errors that your system generates, right?  Are you checking the error log?  Manually?  Did you know you could setup a job to email those errors to you as soon as they occur?  No more checking needed, unless you don’t check your email.  In that case, have it send a message to your cell phone or IM you with the error, or at least have it send you a message telling you to check the log.</p>\n<p>So, those are some possible places to look for WET code.  Be on the lookout today for places that are WET and spend a little time DRYing things up.</p>\n",
            "tags": [
                "programming",
                "DRY",
                "best practices"
            ]
        }
    ]
}