{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"mvvm\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/thinking-in-javascript/",
            "url": "http://davembush.github.com/thinking-in-javascript/",
            "title": "Thinking in JavaScript",
            "date_published": "2017-09-05T10:30:54.000Z",
            "content_html": "<p>Over the last week I’ve gradually come to the realization that the fundamental reason why most people have trouble with JavaScript is because it doesn’t fit their mental model of how programming should be done.  This isn’t to say that most programmers don’t manage to achieve their end goal.  But if you sit back and take an objective look at the code we end up writing, you have to admit, the code ends up being quite ugly. </p>\n<p>Now, this isn’t a dig at the way we’ve been doing things.  We’ve all been doing the best we can with what we have.  But, the JavaScript world has progressed and there is a better mental model that has developed and should even be expanded which will allow us to develop more complex and feature rich applications now and well into the future. <figure><img src=\"/uploads/2017/09/2017-09-05.jpg\" title=\"Thinking in JavaScript\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/froderik/8283727226/\">freddie boy</a> via <a href=\"//visualhunt.com/re/fb4c57\">Visual Hunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\"> CC BY-SA</a></figcaption></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Where-We’ve-Been\"><a href=\"#Where-We’ve-Been\" class=\"headerlink\" title=\"Where We’ve Been\"></a>Where We’ve Been</h2><p>I’ve been saying for years that the thing that holds most programmers back is that they always want to treat whatever new thing they are using like the last thing they were using.  And nowhere has this displayed itself more apparently than with JavaScript. </p>\n<p>Take the most obvious of examples.  Everyone knows, or should know by now, that JavaScript is not really object-oriented.  And yet, we’ve been trying to force JavaScript to BE object-oriented pretty much from the beginning.  This hasn’t been such a big problem, although one could argue that by trying to make JavaScript object-oriented, we’ve prevented it from being able to do some of the things it does best. </p>\n<p>Where we really run into trouble is with the event based, and often asynchronous nature of JavaScript. Think about this.  For years, we’ve been trying to synchronize something that is inherently asynchronous.  And this is where the real trouble begins. </p>\n<p>First, we had call back. Then promises. Now Observables. Soon async and await. And while callbacks are how the asynchronous nature of JavaScript is handle under the hood, the others are attempts to tame the asynchronous beast.  Especially async and await.</p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why?\"></a>Why?</h2><p>Now, this is where we are. Constantly trying to make JavaScript be something it isn’t. But, why is this? </p>\n<p>I believe it is because we are trying to impose models onto JavaScript that were useful in our desktop and server-side applications.  MVC, MVVM, Object-Oriented, and others all grew up in a world that was both synchronous, multi-threaded, and lent themselves well to an object-oriented model.  As various frameworks have evolved, the attempt has been to take these familiar models and apply them to an asynchronous, single threaded and not really object-oriented.  From where I sit, I am amazed any of this worked at all.  It seems to me it should have failed long ago.</p>\n<h2 id=\"A-Light-in-The-Darkness\"><a href=\"#A-Light-in-The-Darkness\" class=\"headerlink\" title=\"A Light in The Darkness\"></a>A Light in The Darkness</h2><p>Hey, I’ve been stuck in the old school model too.  But, I’m starting to think there may be a better way.  I’ve written about Redux and NgRX a lot on this blog.  I’ve fielded a lot of questions on the Angular slack channel.  Most of the questions revolve around the basic question of handling multiple asynchronous calls for data as part of one action.  All of the questions presuppose you would need to make each of the calls for data and then use some method of waiting for everything to return and assemble the data before moving on.  In each case, I recommend an alternative.  What if, each call was a unique action.  When each returns, another action is fired that places the return data in the appropriate store, or sub store.  In this model, we don’t care when the data comes back.  When it comes back, we deal with it appropriately.</p>\n<h2 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h2><p>Let’s go with one of the more common examples I see. </p>\n<p>I need to make a request for a set of records.  Once I have the results, for each record in the result, I need to go get a set of child records.  Here is how I would deal with this at a very high level using NgRX.  I’m sure this would work for multiple Redux patterns but they may call things by different names.</p>\n<ul>\n<li>Fire an Action that request the main set of records.</li>\n<li>The appropriate Effect responds to the action by making an AJAX call for the data.</li>\n<li>When the AJAX call returns,<ul>\n<li>fire an Action that puts the main records in the store.</li>\n<li>for each record in the result fire an Action asking for the child record(s).</li>\n</ul>\n</li>\n<li>The appropriate Effect(s) responds to the request for child records by making AJAX calls.</li>\n<li>When the data returns fire an Action that places the data in the store.</li>\n</ul>\n<p>Since your view is listening for changes on the entities in your store, it will update as the data comes in. Even better if you setup a debounce on your listener, the screen will update only when all of the data has been retrieved.</p>\n<h2 id=\"The-Key-Concept\"><a href=\"#The-Key-Concept\" class=\"headerlink\" title=\"The Key Concept\"></a>The Key Concept</h2><p>The key concept here is that we no longer care WHEN something happens.  We only care THAT it happens.  And rather than trying to setup forkJoins() or some other mechanism to flatten this all out, our code ends up being quite simple.  Discrete bits of functionality.  And now, all our asynchronous code becomes Reactive code.  We no longer need to flatten anything out.</p>\n<h2 id=\"Server-Side\"><a href=\"#Server-Side\" class=\"headerlink\" title=\"Server Side\"></a>Server Side</h2><p>Sadly, on the server side, things aren’t quite so easy.  At best we are tied to an implementation Observables and the various methods of combining Observables.  But I could also see some kind of client&#x2F;server implementation that used a framework like SignalR or Socket.io so that as the various Observables complete, the data on the client would get updated.  An interesting way to make all of the AJAXy calls rather transparent to the user.</p>\n<h2 id=\"Taking-it-To-the-Next-Level\"><a href=\"#Taking-it-To-the-Next-Level\" class=\"headerlink\" title=\"Taking it To the Next Level\"></a>Taking it To the Next Level</h2><p>You may call me a dreamer, but what if we made a JavaScript framework that was all message driven and reactive like I’ve described above?  We’ve done it before. </p>\n<p>When Windows was first created in ran on single core CPUs.  It was essentially single threaded.  The way it worked was primarily by putting “events” on a que and then sending the events to the appropriate application that needed to know about them. </p>\n<p>If you applied this model to JavaScript and folded in what I’ve described above, you could easily have a system that appeared to be multi-threaded even though it was single threaded at its core.</p>\n<h2 id=\"Don’t-Throw-the-Baby-Out-…\"><a href=\"#Don’t-Throw-the-Baby-Out-…\" class=\"headerlink\" title=\"Don’t Throw the Baby Out …\"></a>Don’t Throw the Baby Out …</h2><p>Now, you may think I’m endorsing throwing out object-oriented JavaScript.  Actually, I think most of the View stuff we do lends itself well to object-oriented programming.  But, most of our business rules lend themselves better to the model I’ve described above.  Functional and Reactive.</p>\n",
            "tags": [
                "javascript",
                "mvvm",
                "redux",
                "MVC",
                "NgRX"
            ]
        },
        {
            "id": "http://davembush.github.com/4-reasons-to-drop-mvvm/",
            "url": "http://davembush.github.com/4-reasons-to-drop-mvvm/",
            "title": "4 Reasons To Drop MVVM",
            "date_published": "2016-07-27T10:30:00.000Z",
            "content_html": "<p>The MVVM design pattern has been around for quite a while now.  It has a lot of strengths when done correctly.</p>\n<p>But, I believe the time has come to recognize that MVVM has a lot of shortcomings that point to its demise.  Since I primarily develop web applications, I will keep this discussion centered on the use of MVVM in web applications.  The use of MVVM for desktop may or may not have these same issues.</p>\n<p>I realize that for some of you, the very suggestion of dropping MVVM will invoke a negative emotional response.  Some very smart people have quit their job at the suggestion that MVVM and its close cousin two-way data-binding, be abandoned in favor of another way.  But just for a few minutes, I would like for you to stop treating programming as a religion and consider the possibility that there may be a better way.</p>\n<p><img src=\"/uploads/2016/07/image-2.png\" alt=\"image\" title=\"image\"></p>\n<h2 id=\"History-of-MVVM\"><a href=\"#History-of-MVVM\" class=\"headerlink\" title=\"History of MVVM\"></a>History of MVVM</h2><p>MVVM was originally created by John Gossman to support the XAML syntax used to create Windows™ desktop applications and Silver Light applications.  Its main advantage has always been that it provides an easy way to decouple the View code from any business logic that might need to run.  Because of this decoupling, our applications become much easier to unit test.</p>\n<p>The next major implementation of MVVM that I can remember is <a href=\"//knockoutjs.com/\">Knockout</a>.  It is the knockout framework that introduced me to MVVM and I have to say it is also the only one I feel like actually got it right.  By that I mean that it actually did what it was advertised to do.  Maybe that’s because of all the implementations I’ve used, Knockout is the only one that ONLY implemented MVVM rather than making it part of a larger framework.</p>\n<h2 id=\"Definition-of-MVVM\"><a href=\"#Definition-of-MVVM\" class=\"headerlink\" title=\"Definition of MVVM\"></a>Definition of MVVM</h2><p>I’ve written about MVVM before where I’ve explained more completely what MVVM is.  But just so we have a working definition of what I mean when I talk about MVVM, let’s define it this way.</p>\n<p>MVVM is a design pattern that uses two-way data-binding to get data in and out of the presentation layer, referred to as the View, without the programmer needing to do any more than specifying that this should happen in the view.  MVVM is also able to have data elements and functions in the “ViewModel” track changes so that anything that is dependent on other data is automatically recalculated without the programmer having to write a lot of code to make this happen.  This creates a model that is able to respond to events in the view, but is primarily data centric rather than event centric has we have often reasoned about our applications in the past.</p>\n<p>It sounds great.  And when it works it is.  But that’s the main problem, it hardly ever works well.</p>\n<h2 id=\"MVVM-Done-Right-is-Slow\"><a href=\"#MVVM-Done-Right-is-Slow\" class=\"headerlink\" title=\"MVVM Done Right is Slow\"></a>MVVM Done Right is Slow</h2><p>If you’ve had any experience or paid any attention to the implementation of MVVM using JavaScript, you will realize that the number one problem with MVVM is that it is a memory hog and performs poorly for all but the most trivial of applications.  In fact, for all of the popularity of Angular JS, the biggest complaint has been around the implementation of the data-binding.  In a large application, you might need to loop through the data multiple times to make sure it has all recalculated correctly.  If you just use the framework and let the framework deal with your sloppy code, this can make the system incredibly slow.  If you actually pay attention to what you are doing, it takes longer to implement than if you had chosen some other design pattern.</p>\n<p>But doing that means we have not moved on to…</p>\n<h2 id=\"MVVM-is-Hard-to-Implement\"><a href=\"#MVVM-is-Hard-to-Implement\" class=\"headerlink\" title=\"MVVM is Hard to Implement\"></a>MVVM is Hard to Implement</h2><p>Recognizing that looping through the data until it stabilizes may not be a good idea, the framework designers have developed rules such as, “We’ll only run the digest cycle once.”  and “We’ll only run it when some user interaction has occurred.”  Well, OK.  That sounds good.  At least now it will be obvious that I have a problem.  But this is where the trouble begins.  If I can’t rely on my data, and ultimately my view, responding to changes in my data correctly, I am left with having to only partially implementing MVVM so that I can work around these limitations and using other means to make sure my view is updated correctly.</p>\n<p>This is to say nothing of many frameworks just not working as you would expect them to.</p>\n<h2 id=\"MVVM-is-Hard-to-Reason-About\"><a href=\"#MVVM-is-Hard-to-Reason-About\" class=\"headerlink\" title=\"MVVM is Hard to Reason About\"></a>MVVM is Hard to Reason About</h2><p>Again, in all but the most trivial of applications, and because of the optimizations that various frameworks have tried to implement, MVVM becomes difficult to implement.  As I’ve tried to explain MVVM to others and even as I’ve tried to implement it myself, I’ve found that the simple act of keeping the view stuff in the view layer and the data stuff in the data layer and making sure it all updates appropriately has me, at times tearing my hair out.  Many times this is caused by incomplete implementations.  But if being hard to implement means it is hard to reason about, maybe we shouldn’t be using it to begin with.</p>\n<h2 id=\"MVVM-is-Overkill\"><a href=\"#MVVM-is-Overkill\" class=\"headerlink\" title=\"MVVM is Overkill\"></a>MVVM is Overkill</h2><p>But it does work sometimes.  In really simple CRUD applications, it works great.  None of the problems I’ve mentioned.  And this is the great seduction of MVVM.  You try it on some small application and you get excited.  Like a gateway drug, it lures you in.  And when you finally go to implement it on some larger application, you find out that it really doesn’t scale all that well.  And on that small app you tried it on, couldn’t you have done that just as easily using another design pattern?</p>\n<h2 id=\"Where-to-Go-from-Here\"><a href=\"#Where-to-Go-from-Here\" class=\"headerlink\" title=\"Where to Go from Here\"></a>Where to Go from Here</h2><p>As I was reviewing these arguments with a co-worker this week, he asked, “Are you saying we shouldn’t be using MVVM?”  And my answer might surprise you.</p>\n<p>I said, “Given the two models we have to work within the framework we are currently using, MVVM is the best choice.” However, what we might want to consider is moving to another framework that provides a better design pattern.  There are several “One-way” design patterns that intrigue me.  The first is the basic Flux pattern that React tends to use.  Done correctly, this uses events to achieve the decoupling we all should be striving for.  At its core, it is basic MVC.</p>\n<p>The second one, which is very flux like, is RxJS.  I’m still wrapping my head around how I to use it in an application and honestly don’t know enough about it at this point to say any more than that it looks interesting.</p>\n<p>And even if we decided to move away from MVVM, I think using two way data-binding between the view and the ViewModel is good.  I just think the ViewModel shouldn’t try to re-compute the values as part of what it does.</p>\n<p>Leave that to the developer to control.  The problem is, trying to get existing systems that implement two-way data-binding to only work at that level would not work correctly.  </p>\n<h3 id=\"Other-places-talking-about-MVVM\"><a href=\"#Other-places-talking-about-MVVM\" class=\"headerlink\" title=\"Other places talking about MVVM\"></a>Other places talking about MVVM</h3><ul>\n<li><a href=\"//blogs.msdn.microsoft.com/johngossman/2006/03/04/advantages-and-disadvantages-of-m-v-vm/\">The Advantages and Disadvantages of MVVM</a> (by John Gossman himself!)</li>\n</ul>\n",
            "tags": [
                "javascript",
                "mvvm"
            ]
        },
        {
            "id": "http://davembush.github.com/javascript-mvvm-you%E2%80%99re-probably-doing-it-wrong/",
            "url": "http://davembush.github.com/javascript-mvvm-you%E2%80%99re-probably-doing-it-wrong/",
            "title": "JavaScript MVVM - You’re (Probably) Doing it Wrong",
            "date_published": "2016-04-14T11:30:00.000Z",
            "content_html": "<p>If you are using one of the many frameworks that say they are using JavaScript MVVM, you might not be using it the way it should be used. Many of my clients aren’t.</p>\n<p>This article will attempt to answer three questions.</p>\n<ul>\n<li>What is MVVM?</li>\n<li>What are the advantages of MVVM?</li>\n<li>What are good MVVM coding practices?</li>\n</ul>\n<figure>![](/uploads/2016/04/image-1.png \"JavaScript & MVVM\")<figcaption>Photo credit: [uka0310](//www.flickr.com/photos/uka0310/8038385310/) via [VisualHunt](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"What-is-JavaScript-MVVM\"><a href=\"#What-is-JavaScript-MVVM\" class=\"headerlink\" title=\"What is JavaScript MVVM?\"></a>What is JavaScript MVVM?</h2><p>The first question we need to ask before we can ever start coding is, “What is MVVM?”  The reason for this is that if you don’t understand what this design pattern is attempting to do, you’ll probably ending up making some pretty severe coding mistakes when it comes time to implement it.</p>\n<p>In the MVVM design pattern, like the MVC design pattern, the first M represents the Model and the first V represents the View.  As with MVC, the Model represents the data you are trying to manipulate.  The View represents the presentation layer.  In MVVM, there is also an entity called a ViewModel which is an object or set of objects that represent the View’s State.  This would include any data you want to present from your Model as well as ancillary states such as what elements are enabled&#x2F;disabled or visible&#x2F;hidden.  Not that these are the only items.  This is just a few examples.</p>\n<p>What makes MVVM cool is that you don’t have to worry about how data gets from the View to the ViewModel or from the ViewModel back into the View.  That all happens automatically.  Although, depending on the implementation, you might have to write a bit more code to notify the View that something changed in the ViewModel so that it knows to update itself.</p>\n<p>But, you may be left wondering, “Where do event handlers go?” Well, that is one of the things I find confusing about calling it MVVM.  Because in every implementation I’ve ever worked on, there is still a controller of some sorts.  Or, call it a ViewController.  It is the thing that responds to events in the view and updates the ViewModel as needed.</p>\n<p>So, in general, you have a View that updates the ViewModel automatically and fires events to the ViewController.  This is all specified declaratively.  When an event is fired, the ViewController responds to the event and updates the ViewModel with any state changes.  When the ViewModel changes, it notifies the View that the View should update the presentation.  When the controller needs to know about the current state of the View, it ask the ViewModel for that information because it should be reflected there.</p>\n<p><img src=\"/uploads/2016/04/image-2.png\" alt=\"JavaScript MVVM\" title=\"JavaScript MVVM\"> If you’ve ever used one of the many MVVM frameworks out there, you’ll recognize that many of them combine the ViewModel and the ViewController into one entity.  I’ve separated them out here for clarity and because I believe that if all possible, they should be maintained separately to maintain the Single Responsibility Principle.  However, I recognize that the best you may be able to do is provide to separate sections in one class.  The main point here is that any state changes to the view happen because the ViewModel was updated and not because the ViewController called into the View to make the change.</p>\n<h2 id=\"What-JavaScript-MVVM-is-Not\"><a href=\"#What-JavaScript-MVVM-is-Not\" class=\"headerlink\" title=\"What JavaScript MVVM is Not\"></a>What JavaScript MVVM is Not</h2><p>One rookie mistake with any MV* design pattern is that many programmers think that the View, ViewModel or ViewController are the only three places where code can live in this pattern.  But the truth of the matter is, the pattern only describes how to handle the organization of your presentation code.  MVVM does not specify where your business rules should be located.  But one place they should not go is in your ViewController.  The only code that should be in your ViewController is code that updates or retrieves information from the ViewModel, or code that calls out to another class to perform some sort of business rules.</p>\n<h2 id=\"Advantages-of-JavaScript-MVVM\"><a href=\"#Advantages-of-JavaScript-MVVM\" class=\"headerlink\" title=\"Advantages of JavaScript MVVM\"></a>Advantages of JavaScript MVVM</h2><p>While there are many advantages to using MVVM, the top three on my list are:</p>\n<h3 id=\"View-Refactoring\"><a href=\"#View-Refactoring\" class=\"headerlink\" title=\"View Refactoring\"></a>View Refactoring</h3><p>I’ve worked on several systems in the past where it was necessary for my code to know what more about the View that it should have.  Whenever I wanted to change the ID of an element in my view, it was necessary for me to update code in other parts of my system or the code would break.  When you are using MVVM properly, you can not only change your view however you want, but you don’t have to even have an ID if you don’t need to for some other reason (like running Selenium Tests).</p>\n<h3 id=\"Interchangeable\"><a href=\"#Interchangeable\" class=\"headerlink\" title=\"Interchangeable\"></a>Interchangeable</h3><p>In fact, if you wanted to, you could create multiple views and associate each of them with the same ViewModel and ViewController.  You might create a View for a version of you application that runs on the desktop and another View for a version that runs on a phone.  Implemented correctly, you may have state information in your ViewModel that never makes it to the View because the version of the View you are currently running doesn’t display that information.</p>\n<h3 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h3><p>For me, the most compelling reason to us MVVM is because it makes it much easier to test my application.  You only need to be able to tell the ViewController where the ViewModel is.  You can call the event handlers directly in your test and verify that they update the ViewModel correctly without ever having to create a View.  Since the View is declarative, you can trust that your framework will do what it should and leave testing the View to a larger Application level test rather than trying to unit test it.</p>\n<h2 id=\"JavaScript-MVVM-Best-Practices\"><a href=\"#JavaScript-MVVM-Best-Practices\" class=\"headerlink\" title=\"JavaScript MVVM Best Practices\"></a>JavaScript MVVM Best Practices</h2><h3 id=\"Never-Call-the-View-from-the-ViewController\"><a href=\"#Never-Call-the-View-from-the-ViewController\" class=\"headerlink\" title=\"Never Call the View from the ViewController\"></a>Never Call the View from the ViewController</h3><p>There are several ways I typically see this rule violated.  The first, and most obvious is when the view is called to retrieve or set state information instead of using the ViewModel.  But another way I typically see this violated is when programmers insist or writing event wire-up code in the ViewController.  The reason wiring up event handlers is a bad idea is because now I have to have some sort of DOM locator code in my ViewController.  This means if I change the identifier or the location of the DOM item, I have to come in and change my locator code.  One way of testing if the code you are writing belongs where you are writing it is to ask the question, “If I executed this code without the View, would it still work correctly?”</p>\n<h3 id=\"Event-Handlers-Should-Be-Light\"><a href=\"#Event-Handlers-Should-Be-Light\" class=\"headerlink\" title=\"Event Handlers Should Be Light\"></a>Event Handlers Should Be Light</h3><p>As I mentioned above, you don’t want to have any more code in your ViewController than is absolutely necessary to update the ViewModel.  This will often mean calling out to some other object to get the actual work done.</p>\n<h3 id=\"ViewModel-Should-Only-Contain-ViewState\"><a href=\"#ViewModel-Should-Only-Contain-ViewState\" class=\"headerlink\" title=\"ViewModel Should Only Contain ViewState\"></a>ViewModel Should Only Contain ViewState</h3><p>It might be tempting to put executable code in your ViewModel at times.  Resist this urge.  If you need a computed property, that’s one thing.  If you start processing business logic, you are probably headed down the wrong path.  My general test here is this.  If I need to write a test case against my ViewModel code directly to get 100% code coverage, I’ve probably coded something wrong.  Of course, you have to be writing unit test and a code coverage tool for this rule to work.</p>\n<h2 id=\"If-You-Think-You-Need-to-Violate-A-Best-Practice\"><a href=\"#If-You-Think-You-Need-to-Violate-A-Best-Practice\" class=\"headerlink\" title=\"If You Think You Need to Violate A Best Practice\"></a>If You Think You Need to Violate A Best Practice</h2><p>Finally, I want to address the issue of, “What if…” This past week, I ran into a situation where the control I was using was not setup to implement MVVM the way my framework intended.  So, this problem is fresh in my mind.  The solution is almost always to extend the component and add in the hooks you need so that you can use the framework properly.  While the temptation to just get something working will be strong, your overall productivity will suffer if you start bending the rules.  If you can’t figure out how to get the code to submit, ask for help.  You may need to break some of the rules in the extension, but at least the violations are isolated from the rest of your code in such a way that if the component ever gets fixed, you can go to one location to update your code.</p>\n",
            "tags": [
                "javascript",
                "mvvm"
            ]
        },
        {
            "id": "http://davembush.github.com/software-architecture-without-test-driven-development-is-dangerous/",
            "url": "http://davembush.github.com/software-architecture-without-test-driven-development-is-dangerous/",
            "title": "Software Architecture without Test Driven Development is DANGEROUS!",
            "date_published": "2015-01-29T12:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/01/TddImpactsSoftwareArchitecture.png\" alt=\"TDD Impacts Software Architecture\" title=\"TddImpactsSoftwareArchitecture\"></p>\n<p>I’ve had two incidents recently that have shown me how TDD impacts Software Architecture.  Both of these are with code I’m working on.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"What-Software-Architecture-Might-Do\"><a href=\"#What-Software-Architecture-Might-Do\" class=\"headerlink\" title=\"What Software Architecture Might Do\"></a>What Software Architecture Might Do</h2><p>Software architecture might specify how it is put together at a very high level.  For example, software architecture might specify that we use a three tiered approach or an n-tiered approach.  This approach places our view code is at one level, our business rules are at another level, and our data access at yet a third level.</p>\n<p>Software architecture might specify that we use MVC where our business rules are in the model, and a controller communicates between the view and the model to get data between the two.</p>\n<p>It might specify MVVM. This would have the view model take the place of the controller and manage the state information for the view.</p>\n<p>Software architecture might also tell us we should use MVP, giving the presenter the role of the controller and managing state information for the view and communicating with the business rules.</p>\n<p>But none of these patterns tell us how to write maintainable code.  They only tell us about the general software architecture.  This is like having a sketch of a house without a wiring or plumbing plan.</p>\n<h2 id=\"When-the-view-gets-in-the-way\"><a href=\"#When-the-view-gets-in-the-way\" class=\"headerlink\" title=\"When the view gets in the way\"></a>When the view gets in the way</h2><p>So, if you’ve been following this blog for a while, you may remember that I’m working with EXTjs.  Specifically, I’m working with EXTjs 4.2.  This has what Sencha calls an MVC architecture.  The problem is, what they refer to as the “Model” we would all recognize as a “Record” in a table, and their Controller is tightly coupled to their View.  That is, they call this MVC, but no one who understands what MVC is supposed to look like as a design pattern would recognize Sencha’s MVC as the real MVC design pattern.</p>\n<p>This makes the code incredibly hard to test.  The tendency is to write code that is highly dependent on the view.  The view is dependent on the DOM.  Rendering the view takes quite a bit of time.  So any test of your business rules end up taking an incredibly long time to test because they ultimately cause DOM manipulation to occur.</p>\n<p>It isn’t until you decide to borrow a bit of architecture from Angular that you realize that your business rules should be separate classes.  Angular has “Service Classes.” My Service classes are built specifically so they do not rely on anything else.</p>\n<p>By doing this, I was able to get two thirds of my code under test that run in about a second.  Prior to this, they took a half an hour.</p>\n<p>My next task was to get the view and my logic for enabling and disabling controls on the view more loosely coupled.  This was a bit more difficult because enabling and disabling controls is, naturally, a view thing.</p>\n<p>But again, taking a page from another framework, this time Knockout and Angular, I created a ViewModel.  My ViewModel holds the state of my view separate from the actual view.  When the state changes, it fires an event that actually changes the view, but this will allow me to test my enable&#x2F;disable logic, along with other code in my system, without ever instantiating the view.  Under test, the events will fire and nothing will happen.</p>\n<h2 id=\"Avoiding-Dependencies\"><a href=\"#Avoiding-Dependencies\" class=\"headerlink\" title=\"Avoiding Dependencies\"></a>Avoiding Dependencies</h2><p>Now the structure  of my code looks something like the following: View – ViewModel – EnableDisableController – EnableDisableService I could have put the EnableDisableService code in the EnableDisableController, and many people would, but what I’ve found is that if I do that, it would be nearly impossible to UNIT test my Enable&#x2F;Disable logic.  Why?  Because I would be creating all of the objects I needed for the logic in the same class the logic is in.</p>\n<p>By breaking the logic code into it’s own class that takes the ViewModel as a construction parameter, I can create my own ViewModel that looks exactly like what I need it to look like so that I can test the logic with entirely known values.</p>\n<p>These are just two of the ways that code architecture is impacted by Test Driven Development.  I’m sure there are others.</p>\n",
            "tags": [
                "tdd",
                "mvvm",
                "mvp",
                "MVC",
                "dependency injection",
                "software architecture"
            ]
        }
    ]
}