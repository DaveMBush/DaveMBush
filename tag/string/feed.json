{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"string\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/string-and-stringbuilder/",
            "url": "http://davembush.github.com/string-and-stringbuilder/",
            "title": "String and StringBuilder",
            "date_published": "2014-12-11T12:00:00.000Z",
            "content_html": "<p>A couple of weeks ago, we discussed <a href=\"/value-type-vs-reference-type/\">Value types and Reference types</a> where we said that a reference type points to the value it represents and a value type is the value it represents. This has implications when we work with the assignment operator because when you assign a reference type and change the content of what it is pointing to, both variables get changed because they are both pointing to the same location in memory.  If you do this with a value type, only the one you change sees the change because you are working with a copy.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Is-String-A-Value-or-Reference-Type\"><a href=\"#Is-String-A-Value-or-Reference-Type\" class=\"headerlink\" title=\"Is String A Value or Reference Type?\"></a>Is String A Value or Reference Type?</h2><p>So, if you’ve done any work with the String class, you might think it is a value type, because if you write this code:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> b = a;</span><br><span class=\"line\"><span class=\"built_in\">string</span> b = <span class=\"string\">&quot;def&quot;</span>;</span><br><span class=\"line\">Console.WriteLine(a);</span><br><span class=\"line\">Console.WriteLine(b);</span><br></pre></td></tr></table></figure>\n\n<p>You will quickly discover that the values that get written out are: abc def Which is not what you’d expect if String is a reference type. So, the question we need to ask is, why is String acting like a value type if it is really a reference type?</p>\n<h2 id=\"Strings-Are-Immutable\"><a href=\"#Strings-Are-Immutable\" class=\"headerlink\" title=\"Strings Are Immutable\"></a>Strings Are Immutable</h2><p>The answer is that Strings are immutable.  That is, a string never changes.  And if you are a thinking person I can already hear you saying, “Sure they change, just look at this code…”</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">a = <span class=\"string\">&quot;def&quot;</span>;</span><br><span class=\"line\">Console.WriteLine(a);</span><br></pre></td></tr></table></figure>\n<p>“See, I changed the string variable a from ‘abc’ to ‘def’” And yes, you did change the a variable.  But what did you change?  You didn’t change “abc” to “def” you change what a was pointing to.</p>\n<p>You see, “abc” is the object of type string and “def” is an object of type string.  All you managed to do was change what a was pointing to. In fact, if you write this code:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> b = <span class=\"string\">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The result is exactly the same as if you’d written:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> a = b;</span><br></pre></td></tr></table></figure>\n\n<p>Because in .NET, there is only one instance of any given string in the system.  The duplicates get optimized out.</p>\n<h2 id=\"String-Concatenation\"><a href=\"#String-Concatenation\" class=\"headerlink\" title=\"String Concatenation\"></a>String Concatenation</h2><p>Now all of this has implications when it comes to concatenation. Let’s say you write this code:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> b = <span class=\"string\">&quot;def&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> c = a + b;</span><br></pre></td></tr></table></figure>\n\n<p>What’s happening here? First we create a string object that contains “abc” and point the a variable to it.  Then we create another string object that contains “def” and point the b variable to it.  And now this is where strings get interesting because the next thing that happens is that a NEW string object is created that contains “abcdef” and we point the c variable to that new value. Now, if you think about this for a minute, you’ll understand that this is incredibly inefficient.  Creating new objects is one of the most expensive operations that anyone can do is just about every object oriented language we have available.  In fact, I can’t think of one where this is not true.  I’m just assuming there must be an exception to the rule. It would be much more efficient if we were to make string so that it wasn’t immutable.  This would mean we could skip the create new object part of the assignment and our concatenation operations would work much faster.</p>\n<h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>Enter StringBuilder.  StringBuilder is, essentially, the mutable version of the String class.  Now you can write code that looks like this:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> b = <span class=\"string\">&quot;efg&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> c = <span class=\"string\">&quot;hij&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> StringBuilder(a);</span><br><span class=\"line\">d.Append(b);</span><br><span class=\"line\">d.Append(c);</span><br><span class=\"line\"><span class=\"built_in\">string</span> e = d.ToString();</span><br></pre></td></tr></table></figure>\n\n<p>Note, at the end, we still have to convert our StringBuilder object to a String object using ToString().  So, there is a new object creation penalty there.  What this means is that you probably don’t want to use a StringBuilder unless you are appending to a string more than three times. So, there you go.  That’s the difference between String and StringBuilder, why a String looks like a value type, and when you should use StringBuilder instead of String.</p>\n",
            "tags": [
                "string",
                "reference types",
                "stringbuilder",
                "value types"
            ]
        },
        {
            "id": "http://davembush.github.com/net-string-pool-%E2%80%93-not-just-for-the-compiler/",
            "url": "http://davembush.github.com/net-string-pool-%E2%80%93-not-just-for-the-compiler/",
            "title": ".Net String Pool – Not Just For The Compiler",
            "date_published": "2009-04-22T08:34:00.000Z",
            "content_html": "<p><img src=\"/uploads/2009/04/b03b0055.jpg\" alt=\"B03B0055\" title=\"B03B0055\"> On Monday, I was corrected in my assertion that creating multiple empty strings would create multiple objects.  Turns out the compiler automatically puts all of the strings that are exactly the same in a “string pool” so that there is only ever one empty string in the entire application you’ve created.</p>\n<span id=\"more\"></span>\n\n<p>Duh! I should have known this, or at least I should have expected that this was so since it has been true with every other compiled language I’ve worked with.</p>\n<p>But what I didn’t know and couldn’t expect is that we can make use of this string pool programmatically as well.</p>\n<p><strong>Why would you want to do this yourself?</strong></p>\n<p>Keep in mind that string concatenation in .NET requires the creation of a new object.  So, code such as this,</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">&quot;abcd&quot;</span>;</span><br><span class=\"line\">String b = <span class=\"string\">&quot;efgh&quot;</span>;</span><br><span class=\"line\">a += b;</span><br></pre></td></tr></table></figure>\n\n<p>creates a new object at line 3 every time it is executed.</p>\n<p>So that if we add the following line:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"string\">&quot;abcdefgh&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>we would not be pointing to the same object.  That is, a and b would contain the same content but would be pointing to two entirely different objects.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a == b)</span><br><span class=\"line\">    Trace.Write(<span class=\"string\">&quot;A and B contain the same data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (String.ReferenceEquals(a,b))</span><br><span class=\"line\">    Trace.Write(<span class=\"string\">&quot;A and B are the same object&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>String.Intern Consolidates The Data</strong></p>\n<p>By using String.Intern() we can get both evaluations to be true.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">&quot;abcd&quot;</span>;</span><br><span class=\"line\">String b = <span class=\"string\">&quot;efgh&quot;</span>;</span><br><span class=\"line\">a = String.Intern(a + b);</span><br><span class=\"line\">b = <span class=\"string\">&quot;abcdefgh&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Now both evaluations above will be true because line 3 places the string “abcdefgh” in the pool and line 4 uses that same string from the pool to assign to b.  Where we might have created two objects, we are now only creating one and referring to it both times.</p>\n<p>You could also use String.IsInterned(string) to determine if a string has already been placed in the string pool and execute optional code based on that.</p>\n<p><strong>When Would You Use This?</strong></p>\n<p>I still stand by my statement that optimizations should be saved for last.  You would not do this if this was the only place where you were doing the concatenation.  But you might consider doing this if your concatenations were in a loop that was taking a significant amount of processing time.</p>\n<p>Other things you might also want to consider would be to consolidate concatenations on the same line and&#x2F;or using the StringBuilder class for concatenations.  Keep in mind that StringBuilder is only really useful once you get past three concatenations due to the overhead of creating the StringBuilder object vs. creating new objects during the normal concatenation process.</p>\n",
            "tags": [
                "c#",
                "vb.net",
                ".net",
                "string",
                "intern"
            ]
        },
        {
            "id": "http://davembush.github.com/c-%E2%80%9C%E2%80%9D-better-than-string-empty/",
            "url": "http://davembush.github.com/c-%E2%80%9C%E2%80%9D-better-than-string-empty/",
            "title": "C# “” better than string.Empty?",
            "date_published": "2009-04-20T08:43:00.000Z",
            "content_html": "<p><img src=\"/uploads/2009/04/arct013.jpg\" alt=\"arct-013\" title=\"arct-013\">I recently read an article that argued that “” is “Better than String.Empty”</p>\n<p>The argument is that since string.Empty doesn’t work in all situations, we should not use it at all.  He further argues that since the compiler can’t optimize code using string.Empty, the performance gains we might lose due to our lack of this optimization further supports the argument that we should not use it at all.</p>\n<p>But at what price?</p>\n<span id=\"more\"></span>\n\n<p>First, it is impressive that he took the time to evaluate the performance hit that using String.Empty can cause.  I’m pretty sure his evaluation of using String.Empty in a case statement is from his attempt to do so only to find out he couldn’t.</p>\n<p>However, he seems to have overlooked the price of not using String.Empty.  Certainly, Microsoft didn’t put that there without thinking about what they were doing.</p>\n<p>So let’s further evaluate what is happening in our code when we use “” rather than using String.Empty.</p>\n<p><strong>Consider Real World Optimization</strong></p>\n<p>In the article referenced, he does one, and only one, bench mark to prove that “” is faster than String.Empty by putting the code in a loop that could be optimized out.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>.Empty == <span class=\"literal\">null</span>) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>vs</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&quot;&quot;</span> == <span class=\"literal\">null</span>) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>But what about a real world scenario where the code is NOT optimized out?</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = String.Empty;</span><br></pre></td></tr></table></figure>\n\n<p>vs</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String x = <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>In my test, there was no noticeable difference.  Sometimes string.Empty was faster and sometimes the empty string was faster.   And I expect the reason they are about the same is because the compiler optimized out the assignment.</p>\n<p>In real life, I would expect String.Empty to take just slightly longer.  But not enough to make it worth worrying about.</p>\n<p><strong>Consider String Comparison Cost</strong></p>\n<p>Second, string comparisons are notoriously expensive in every language I’ve ever worked in.  Including the .NET languages.  Instead of arguing that we can’t using String.Empty in a case statement, we would do better to argue that using a string in a case statement is the last of the possible alternatives we might use.</p>\n<p>When evaluating for the empty string, for example, you might check the string’s length rather than checking the string itself. For other strings, you might check the first character of the string.</p>\n<p><strong>Writing Code is About Solving Problems</strong></p>\n<p>When I started my career, computers were slow and had a limited amount of memory.  Writing the smallest amount of code that performed in the most efficient way was half the struggle of writing the application.</p>\n<p>Today, neither of those issues are of primary concern.  The first order of concern is to write an application that works.  Once it is DOING what it is supposed to do, IF there are performance issues, we should do proper code evaluation to determine where the performance bottlenecks are and then, and only then, should we optimize our code for performance.</p>\n<p>Generally, using String.Empty will serve you better than using “”.  In the cases where String.Empty will not work either because of the code evaluation OR because of the performance considerations, yes, use “” instead.  But, do it because there is a supportable reason, not because you think it may produce faster code.</p>\n<p>In fact, I would argue that if your code has performance problems, the last place you should be looking is at this issue.  You’ll get negligible gains. Your real problem is more likely in file IO, including database access and network access.</p>\n",
            "tags": [
                "c#",
                "empty",
                "string"
            ]
        },
        {
            "id": "http://davembush.github.com/vb-net-char-from-string-with-option-strict/",
            "url": "http://davembush.github.com/vb-net-char-from-string-with-option-strict/",
            "title": "VB.NET - Char from String with Option Strict",
            "date_published": "2009-04-08T08:35:14.000Z",
            "content_html": "<p><img src=\"/uploads/2009/04/g04b0079.jpg\" alt=\"G04B0079\"> So here’s the question:</p>\n<blockquote>\n<p>I’m using String.Split() and need to pass in a Char or a Char array as the parameter.  If I pass in a string String.Split(“&#x2F;“) I get an error “Option Strict On disallows implicit conversions from ‘String’ to ‘Char’.”</p>\n<p>Obviously, the easiest way to fix this would be to turn off Option Strict, but I would prefer to keep it on.  So how do I pass in the Char instead of a String in this situation?”</p>\n</blockquote>\n<p>There are actually several ways to accomplish what you are trying to do.</p>\n<span id=\"more\"></span>\n\n<p>The first and most general solution would be to call the ToCharArray() method off the string.</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> strSplit() <span class=\"keyword\">As</span> <span class=\"type\">String</span> = myString.Split(<span class=\"string\">&quot;/&quot;</span>.ToCharArray())</span><br></pre></td></tr></table></figure>\n\n<p>The advantage to this method is that it will work regardless of what size the string is and it will use each character in the string as a delimiter.</p>\n<p>But what if you only have one character in your array?  Surely there is a shorter, cleaner statement we can use.</p>\n<p>As a matter of fact, there are several other options.  You could use Convert.ToChar() or Char.Parse()</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> strSplit() <span class=\"keyword\">As</span> <span class=\"type\">String</span> = _</span><br><span class=\"line\">   myString.Split(Convert.ToChar(<span class=\"string\">&quot;/&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> strSplit() <span class=\"keyword\">As</span> <span class=\"type\">String</span> = _</span><br><span class=\"line\">   myString.Split(<span class=\"type\">Char</span>.Parse(<span class=\"string\">&quot;/&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>But the easiest way to convert a single character string to a Char is simply to put a “c” after the closing quote:</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> strSplit() <span class=\"keyword\">As</span> <span class=\"type\">String</span> = myString.Split(<span class=\"string\">&quot;/&quot;</span>c)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "vb.net",
                "string",
                "char",
                "split",
                "strict"
            ]
        }
    ]
}