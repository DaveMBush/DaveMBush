{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"agile\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "url": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "title": "You Aren’t Doing Scrum If…",
            "date_published": "2020-06-20T11:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/01/YouArentDoingScrumIf.png\" alt=\"You Aren&#39;t Doing Scrum If...\" title=\"YouArentDoingScrumIf\">I’ve been frustrated lately by the flippant use of the words “Scrum” and “Agile” in our industry. </p>\n<p>Actually, I’m STILL frustrated.  I originally wrote this article January 2015.  Not only is it still true.  It is <strong>more</strong> true.</p>\n<p>Our industry has been treating Scrum and Agile as “buzzwords that mean nothing.” These words get slapped onto job requirements like the typical requirements we’ve all seen.</p>\n<ul>\n<li>Must be able to communicate</li>\n<li>Must be able to work in a team environment</li>\n<li>Must be able to work under pressure</li>\n<li>Must be able to work in an Agile environment</li>\n</ul>\n<p>What’s really funny is when I see</p>\n<ul>\n<li>Meet tight deadline</li>\n<li>Expert in Agile</li>\n</ul>\n<p>together in the same job request.</p>\n<p>And even if it doesn’t show up in the job description.  Once you get into the organization, you find out they are no different than any other organization.  All those promises about running “Agile” or “Scrum” as a well of figuring out how long a project will take fly right out the window as soon as a manager wants something done by a specific date.</p>\n<p>If management ain’t Agile, ain’t no one Agile.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Really-Do-you-know-what-you’re-saying\"><a href=\"#Really-Do-you-know-what-you’re-saying\" class=\"headerlink\" title=\"Really?  Do you know what you’re saying?!\"></a>Really?  Do you know what you’re saying?!</h2><p>Many people even use the words “Agile” and “Scrum” interchangeably.  Most because they really do think they are the same thing.</p>\n<p>I’m finding that what most people mean when they use these words is, either, “we work really fast”, “we work iteratively”, or “we don’t really have a plan.”</p>\n<h2 id=\"So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\"><a href=\"#So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\" class=\"headerlink\" title=\"So, the first thing we need to clarify is, what is Scrum and what is Agile.\"></a>So, the first thing we need to clarify is, what is Scrum and what is Agile.</h2><p>Agile is a set of values.  It is what we believe about software development specifically and, I would argue, also impacts how we view life.  You might have other beliefs that live on top of Agile, but these beliefs will have an impact on how you manage the software development process specifically and your organization in general. Check out the <a href=\"//www.agilemanifesto.org/\">Agile Manifesto</a>.  This is what it means to be Agile.</p>\n<p>In contrast to this, Scrum is a methodology that helps an organization BE agile.</p>\n<p>Now here is where things get tricky for some people.  They read in the manifesto that we should value “Individuals and interactions over processes and tools” and think that they can make Scrum be whatever they want it to be because, they would say, “we don’t value processes and tools”.</p>\n<p>But the Agile Manifesto never says that.  It says we value individuals and interactions MORE than, not INSTEAD of, processes and tools.</p>\n<p>So, yes, you can adapt and modify Scrum to fit your situation.  You may need to.  But there are some specific elements of Scrum that you simply can’t ignore because to do so would mean either that you are no longer Agile or you are not implementing Scrum.</p>\n<h2 id=\"And-so-you-aren’t-doing-Scrum-if\"><a href=\"#And-so-you-aren’t-doing-Scrum-if\" class=\"headerlink\" title=\"And so, you aren’t doing Scrum if:\"></a>And so, you aren’t doing Scrum if:</h2><h4 id=\"You-have-deadlines-especially-if-you-have-“tight-deadlines”\"><a href=\"#You-have-deadlines-especially-if-you-have-“tight-deadlines”\" class=\"headerlink\" title=\"You have deadlines, especially if you have “tight deadlines”\"></a>You have deadlines, especially if you have “tight deadlines”</h4><p>“Now wait a minute,” you say, “I heard that Scrum has these things called ‘Sprints’ that are a fixed length.  Don’t those qualify as ‘deadlines?’” Well, yes and no.  You see, I don’t think what Scrum treats as a “deadline” is what most managers mean by “deadline.” At the end of the day you’ll get to the end of the Sprint and you’ll show what you’ve got.  The GOAL is to have a complete set of code that you wouldn’t be embarrassed to show to another programmer.  You should have only selected what could reasonably get done in the timeframe of a sprint so that all that needs to be done to complete the task could get done.</p>\n<p>One of the confusions is that somewhere along the line we were told that at the end of each sprint we should have a “shippable unit of software” and we’ve confused that with “a viably marketable product”  All that shippable means is, “if the customer thinks what you’ve completed so far is something they can use, you would not respond with, ‘but it still needs…’” This ties in with the other way you know you aren’t doing Scrum</p>\n<h4 id=\"You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\"><a href=\"#You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\" class=\"headerlink\" title=\"You aren’t doing scrum if you don’t have a “definition of done.”\"></a>You aren’t doing scrum if you don’t have a “definition of done.”</h4><p>And once again, there is confusion.  To most people, the “definition of done” is “I can ship this code.”  But that may not be appropriate.  You’re definition of done during your first sprint may be “a set of stories that begin to describe the application we are trying to build.”  As you are learning scrum, you’re definition of done may be as simple as, “all of the code we’ve written so far have Unit Test, appropriate documentation, and we’ve learned something of how long a story point will take our team.” Definition of done doesn’t always have to mean “I’ve written code I can ship.”</p>\n<h4 id=\"You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\"><a href=\"#You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\" class=\"headerlink\" title=\"You aren’t doing Scrum if you HAVE to work more than 40 hours a week.\"></a>You aren’t doing Scrum if you HAVE to work more than 40 hours a week.</h4><p>One of the benefits of Scrum is that it allows us to pace ourselves.  We no longer scramble to get stuff done.  We work consistently toward the goal.  But it isn’t a race.</p>\n<p>I have a rule.  If I tell you something will be done by a set time, I’ll bust my butt to make that happen.  If you tell me when it will be done, good luck with that.</p>\n<p>Of course, even when I tell someone when something will be done, I pad the estimate with enough hours that I never work more than 45 hours a week.  There is one day, in the 26 years I’ve been doing this where I worked longer than 12 hours.</p>\n<p>In fact, I had one manager who called me into his office and asked me to come in on Saturdays.  I was already working 10 hour days 5 days a week!  Talk about getting blood out of a turnip! I looked him straight in the eye and said, “I have 50 hours a week in me.  I’d prefer to give them to you Monday through Friday.  But if you want me to come in on Saturday, I can do that, but you are still only going to get 50 hours a week.” Needless to say, I never came in on Saturday.</p>\n<h2 id=\"I-could-go-on…\"><a href=\"#I-could-go-on…\" class=\"headerlink\" title=\"I could go on…\"></a>I could go on…</h2><p>But I won’t</p>\n",
            "tags": [
                "agile",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/what-if-unit-testing-wasn%E2%80%99t-necessary-notdd/",
            "url": "http://davembush.github.com/what-if-unit-testing-wasn%E2%80%99t-necessary-notdd/",
            "title": "What If Unit Testing Wasn’t Necessary? #noTDD",
            "date_published": "2018-10-06T10:30:05.000Z",
            "content_html": "<p>I recently read (yet another) post proposing that <a href=\"//blogs.msdn.microsoft.com/ericgu/2017/06/22/notdd/\">TDD “doesn’t work” and that we shouldn’t use it, or should use it very little</a>. What was shocking about this article wasn’t the content, but the fact that it is hosted on a Microsoft site.</p>\n<p>While I’m not entirely on board with throwing out TDD, the one thing I will agree to is that learning TDD is difficult. I am also willing to admit that, to a large extent, TDD is broken. If you’ve been following my post for a while, this SHOULD be shocking news.</p>\n<p>And so, I’ve been thinking.</p>\n<p>Maybe we’ve been asking the wrong question.  Maybe, instead of asking “How do we encourage people to implement TDD?”  We should be asking, “How do we make TDD either unnecessary, or trivial to implement?”</p>\n<figure>![](/uploads/2017/06/2017-06-27.jpg \"What If Unit Testing Wasn't Necessary? #noTDD\")<figcaption>Photo credit: [abraham.williams](//www.flickr.com/photos/4braham/5867328365/) via [VisualHunt.com](//visualhunt.com/re/0e2a0e) / [ CC BY-SA](//creativecommons.org/licenses/by-sa/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Benefits-of-TDD\"><a href=\"#Benefits-of-TDD\" class=\"headerlink\" title=\"Benefits of TDD\"></a>Benefits of TDD</h2><p>So, let’s review why we think TDD is a good idea. One of the first reasons that you’ll find is that when TDD is done correctly, it encourages loose coupling of code. In fact, one of the things that make TDD hard to learn is that our code tends to be SO tightly coupled that it can’t be tested. There are whole books about how to decouple legacy code so we can get tests around them. There are problems with this, but we’ll get to those in a bit.</p>\n<p>The next major benefit of TDD is that it allows us to refactor our code without worrying about breaking anything. This is the feature I like the most. I was working on a system recently where the requirements were being “leaked” to me a bit at a time. I’d get something done and it would be “oh, I forgot to tell you about…”  </p>\n<p>Arrrgh.</p>\n<p>I was able to add the new code up until the last, “Oh, I forgot…”  And that broke my whole pattern. But it forced a much better architecture.</p>\n<p>Now in the old days, before I started writing tests, I would have been really nervous about tearing the code apart and putting it back together again. What if I broke something that already worked? But, because I had a large suite of tests around this code, I could refactor, run the tests, and fix the tests until I was back to everything working. Without the tests, I would not have known that I broke anything.</p>\n<p>BTW, no one has found any bugs in this code yet and it has been almost a year since I wrote it.</p>\n<p>Related to refactoring, by having a suite of tests in place, we can be reasonably sure that, as we add new features, we aren’t breaking any existing features.</p>\n<p>Next, TDD forces, or it should force, incremental coding.</p>\n<p>I was surprised when I found out that people don’t program incrementally. I always write just enough code to move the project along and then test it. But I know people who write code for hours and even days before they run any of it. And then, they can’t figure out where they broke the code. TDD done correctly, doesn’t let this happen.</p>\n<p>And finally, once you’ve learned how to test, TDD actually increases the speed with which you can produce quality code. I know a guy who brags about how fast he can code. But I also know he’s only counting the time until he said he was done, not the time it took him to fix all the bugs he found. Is he really any faster than any other programmer? It is hard to judge. But studies have shown that using TDD leads to greater over all speed and less technical debt. Something to consider.</p>\n<h2 id=\"Disadvantages-of-TDD\"><a href=\"#Disadvantages-of-TDD\" class=\"headerlink\" title=\"Disadvantages of TDD\"></a>Disadvantages of TDD</h2><p>But for all those benefits, there are still some major problems with TDD as a practice. </p>\n<p>The first and most looming of all, is the fact that using TDD introduces A LOT of friction into the programming process. As an exercise, I wrote a demo application using TDD while learning a new framework. I knew the language and the testing framework, I was just learning a new programming framework. The problem was I not only had to learn the new framework, but the framework has its own helper functions for testing that I also had to learn.</p>\n<p>I would say this friction is what holds most people back and is often voiced as, “TDD slows down my programming.”  Which is true until you’ve learned it all.</p>\n<p>The tendency with TDD is to try to get 100% code coverage. This often lulls us into the belief that we’ve tested everything that can be tested. But the problem is, because our code often has hidden parameters, we can’t always be sure we’ve written enough tests to be sure that we’ve covered all the possible ways those parameters show up. So, the fact is, we can’t be sure we have 100% coverage of the situations our code may run into even if we have 100% coverage of our code.</p>\n<p>The next two disadvantages impact relatively new programmers. That is, people who have been programming for less than 5 years. The problem is, that’s half of the programmers available to the market. After 5 years, you’ve either been promoted to management where you eventually forget how to program or, at the very best only know what you knew when you were promoted, or you’ve moved on to a new career. And then there are people like me who can’t stop coding.</p>\n<p>The problem with programmers who have less than 5 years of experience is that they don’t have any concept of design patterns and they know nothing of architecture. And unless you work in an organization that has senior level programmers with more than 10 years of experience, you aren’t likely to know it is even something you need to learn. And here is the problem. It is nearly impossible to implement TDD if you don’t have a broad understanding of these two subjects. If you have less than 5 years of experience, you are still focused on the basic problem of naming things, keeping your code DRY, and making sure you are implementing the single responsibility principle.</p>\n<p>And finally, there is simply nothing that is making you write tests. Your code will compile and run just fine without them. The syntax of your language really doesn’t care. So given all the detractors, it is really easy to just not write them at all. There, I’ve said it. Yes, we SHOULD use TDD, but it is impractical to expect any but the most seasoned programmers to use this methodology. And by then, they may not need them as much.</p>\n<h2 id=\"What-Tests-Aren’t-Needed\"><a href=\"#What-Tests-Aren’t-Needed\" class=\"headerlink\" title=\"What Tests Aren’t Needed\"></a>What Tests Aren’t Needed</h2><p>But what if we could write code that didn’t need to be tested? Well, generally any code you can look at and be sure you know what it does and what you can expect is code you don’t have to test. Code with a cyclomatic complexity of 2 or lower, which still allows for a condition or two. Code that is:</p>\n<ul>\n<li>Small.</li>\n<li>No conditions</li>\n<li>No hidden parameters</li>\n<li>No side effects</li>\n</ul>\n<p>By “small” I’m talking about code that is, ideally, 5 lines or fewer with the occasional 10 lines in the rarest of instances. </p>\n<p>No hidden parameters. This is a big one. Think about code you’ve recently written. If you are writing Object-Oriented code, you typically have a method that takes a parameter or two (maybe more) and then accesses a member variable and may even create a new object in the middle of the function. The reason we have Dependency Injection is to give us the ability to inject mock objects into our tests so that we can write test against something stable and known rather than these hidden parameters that are constantly changing. </p>\n<p>“No side effects” is a specific instance of a hidden parameter. Anyone try to test code that accesses a database? What if all the code you wrote that had some side effect was isolated to a specific area of your program? In that case, it would reduce the number of tests you would need to write to just that area. And if you wrote that code correctly, the tests would be trivial to write.</p>\n<h2 id=\"I’ve-Fallen-in-Love-…\"><a href=\"#I’ve-Fallen-in-Love-…\" class=\"headerlink\" title=\"I’ve Fallen in Love …\"></a>I’ve Fallen in Love …</h2><p>And this is why I’ve fallen in love with the concepts behind Functional Programming.</p>\n<p>In Functional Programming you have a series of functions that you chain together. Much like fluent programming in the Object-Oriented world, the return value of a function becomes the input for the next function. Each function does just one thing, so they implement the Single Responsibility principle probably better than any class you can possibly write. Each function only works on the parameters it has been given, so you don’t need to worry about hidden parameters and the function is not allowed to generate a side effect.  Even your conditions are handled by functions that filter the data before passing it on. This all makes your code REALLY easy to test if you decide you need to test it at all.</p>\n<p>Of course, no one ever said we couldn’t have side effects. Those are all isolated to specific code that is super easy to test.</p>\n<p>If this is all new to you, I suggest you take a look at the <a href=\"//reactivex.io/\">ReactiveX</a> and start learning this library in the language of your choice.</p>\n<p>For me, the gateway drug into the Functional world has be NgRX and the Flux&#x2F;Redux pattern which is based on RxJS a JavaScript implementation of ReactiveX.</p>\n",
            "tags": [
                "tdd",
                "agile",
                "noTDD"
            ]
        },
        {
            "id": "http://davembush.github.com/how-you-do-anything/",
            "url": "http://davembush.github.com/how-you-do-anything/",
            "title": "How you do Anything ...",
            "date_published": "2018-02-20T11:30:35.000Z",
            "content_html": "<p>I’ve been programming now for 30 years. Over those thirty years, and more so over the last five to ten years, I’ve become increasingly frustrated by the attitude of managers and programmers alike toward programming. </p>\n<p>One programmer I know is pretty vocal about this attitude.  All he seems to care about is how fast he can write the code.  “I got that application done in a month!”  And then he’ll complain about how it is everyone else’s fault that he spent the next four months fixing bugs. </p>\n<p>And it is no wonder he has this attitude.  Most of the managers I’ve worked for will acknowledge that there is a lot of technical debt, but the pressure of getting the code written always outweighs the pressure of the debt. </p>\n<p>I’ve said for years that I’m not at all surprised that software has bugs.  What surprises me most is that any of our code works at all.  If we are honest about our code, we recognize that our code is worse than a store front on the wild west.  A nice facade on the front that everyone sees (if we are lucky) but look behind the facade and the store is barely standing up because the design, architecture and lumber is so bad. </p>\n<p>But, if it is true that “How you do anything is how you do everything.”  shouldn’t we spend a little time practicing quality in the not so obvious places so that we can get in the habit of quality?  Maybe a culture of quality will rub off into our code and produce code that really does get written quickly and has very little technical debt.  Not just in the area of bugs, but in flexibility, architecture, and design. </p>\n<p>So, what could we change in our programming practice that wouldn’t require persuading a manager to make a change in how the whole organization worked? <figure><img src=\"/uploads/2018/02/2018-02-20.jpg\" title=\"How you do anything...\"> Photo on <a href=\"//visualhunt.com/re/cecba2\">Visualhunt</a></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"How-do-you-Dress\"><a href=\"#How-do-you-Dress\" class=\"headerlink\" title=\"How do you Dress?\"></a>How do you Dress?</h2><p>When I first started programming, I had to wear a suit to work.  I forgot my tie one day and actually got reprimanded.  This, despite the fact that the programmers were tucked away in a back room that you had to know existed to get to.  That is, there was no way one of the customers our business worked with was going to find us.  I hated it. </p>\n<p>The pendulum has in the opposite direction.  I’ve been on several interviews where I’ve explicitly been told to NOT wear a suit. </p>\n<p>But I do wonder.  Does how we dress have an impact on our code?  If we don’t care much about how WE look, might we not care that much about what our code looks like?  Does it matter?  I think it might. </p>\n<p>Might it also subconsciously impact other’s view of the quality of code you produce?  You know the adage.  Always dress just below your manager.  But what if your manager dresses like a slob?  Currently, my signature work clothes are black jeans, button down shirt and a sweater.  But, I’m thinking of bumping it up a notch.</p>\n<h2 id=\"What-does-your-desk-look-like\"><a href=\"#What-does-your-desk-look-like\" class=\"headerlink\" title=\"What does your desk look like?\"></a>What does your desk look like?</h2><p>There was a guy I worked with early on in my career who always left his desk in a condition that looked like no one had worked at the desk in months.  Everything was put away.  Several years ago, I decided to take on that habit. </p>\n<p>Funny story.  A couple of gigs ago, a manager from three levels up came down to visit after I had left for the day.  She looked at my desk and said, “Does anyone work here?”  My manager said, “YES!!! Don’t touch anything!”  Guess she was hunting for stray equipment. </p>\n<p>I would say, this simple act was the pivot point for me when I started to care more about my code beyond “Does it work?” </p>\n<p>There is something about working in a clean area slightly dressed up.  Other parts of your life follow along for the ride.</p>\n<h2 id=\"Linters\"><a href=\"#Linters\" class=\"headerlink\" title=\"Linters\"></a>Linters</h2><p>One of those areas is what your code looks like.  A linter can be configured to enforce style rules on your code.  And can also catch dumb mistakes.  The more I use linters, the more convinced I am everyone should use one. </p>\n<p>Here is some of the ways you will benefit, even if you are the only one using a linter.</p>\n<ul>\n<li>Your code will always follow the same format.  This will make the code easier to read and understand.</li>\n<li>As I mentioned, some rules help catch dumb mistakes before you even run the code.</li>\n<li>Just like a clean desk feels inviting, well formatted code feels inviting.  The converse, poorly formatted code, adds to the stress level of working on the code.</li>\n</ul>\n<h2 id=\"Learn-Your-Tools\"><a href=\"#Learn-Your-Tools\" class=\"headerlink\" title=\"Learn Your Tools\"></a>Learn Your Tools</h2><p>I am amazed at how many places I’ve worked where they expect you to learn a particular tool on the fly.  No training.  “We are now using X on this next project.  Download it and start using it!”  And then they wonder why the project is such a disaster.  Bugs everywhere. </p>\n<p>Want to look like a rock star?  Want to be the guy the boss ask “what should we do?”  Be the guy who knows that new tool better than anyone else. </p>\n<p>In the process, you’ll also be the guy who uses the tool the way the people who developed that tool intended it to be used. </p>\n<p>Here’s a truth I’ve observed.  Everyone wants to use whatever tool they’ve just started using like the last tool they used.  And then, when it doesn’t, the new tool “doesn’t work.”  This one truth has done more to hold our industry back than any other one thing I can point to.</p>\n<h2 id=\"Design-Patterns\"><a href=\"#Design-Patterns\" class=\"headerlink\" title=\"Design Patterns\"></a>Design Patterns</h2><p>Learn the basic design patterns for your environment.  But go beyond learning the pattern.  Learn why the pattern exist.  What problem does it solve?  Be able to recognize counterfeits.</p>\n<h2 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h2><p>Along with Design Patterns, learn the basics of Architecture.  Here’s a hint.  All good architecture answers the question, “How can I write code that is not dependent on any other code?”  This is one of the reasons I love Functional Programming.  By design, Functional code is not dependent on other code.  Dependencies are passed into the function.  But you can achieve similar objectives using Object Oriented programming languages or even Procedural languages.</p>\n<h2 id=\"Single-Responsibility\"><a href=\"#Single-Responsibility\" class=\"headerlink\" title=\"Single Responsibility\"></a>Single Responsibility</h2><p>Granular is better than Monolithic!  Don’t be afraid to split things up.  Use components.  Compose classes of other classes.  Components of other components.  And most important of all, don’t create a Utils class of any kind.  In some languages this is easier than others.  But if you can, any method you have in a Utils class should be a function in its own file.  If you can’t do that, maybe each function belongs in its own class unless there is a strong argument for putting them together in a class that can be reasonably named in a way that obviously groups those methods. </p>\n<p>Another pet peeve of mine is putting multiple classes or interfaces in one file. Split them up!  Don’t make me go hunting for the source of a class. </p>\n<p>The ONLY time you might be excused from splitting things up is if the only place the code is being used is in the file’s main class.  But once you make that class available to the outside world, out it comes.</p>\n<h2 id=\"Alternate-Languages\"><a href=\"#Alternate-Languages\" class=\"headerlink\" title=\"Alternate Languages\"></a>Alternate Languages</h2><p>This should go without saying.  But the more languages you learn, the better programmer you will become.  I remember when I started learning C++, I had a hard time understanding references.  And then I started learning Clipper (a dBase III compiler) and something they said made references make sense suddenly. </p>\n<p>And this has been my experience all along.  Every new thing I learn helps me see problems in a slightly different perspective.  Making my code in every language I know that much better.</p>\n<h2 id=\"Code-Reviews\"><a href=\"#Code-Reviews\" class=\"headerlink\" title=\"Code Reviews\"></a>Code Reviews</h2><p>So far, everything I’ve mentioned is something you can do on your own.  This last one will require at least one other person.  Maybe you can buddy up with someone at work for this. </p>\n<p>It amazes me that in 30 years of programming, only three of those years have been in an environment where my code was ever reviewed by someone else.  But getting another set of eyes on your code is helpful if for no other reason than someone else has had to try to understand what you did while you still remember instead of waiting years and you’ve forgotten or moved on.  None of us are as smart as all of us.  Take advantage of another pair of eyes on your code, even if that’s not a formal thing where you currently work.</p>\n",
            "tags": [
                "agile",
                "best practices",
                "extreme programming"
            ]
        },
        {
            "id": "http://davembush.github.com/humpty-dumpty-and-programming/",
            "url": "http://davembush.github.com/humpty-dumpty-and-programming/",
            "title": "Humpty Dumpty and Programming",
            "date_published": "2017-12-05T11:30:32.000Z",
            "content_html": "<p>I’ve noticed a pattern in the programming world at large both with programmers and with managers.  We define things how we want them to be for our organization and not how they are.  We are like Humpty Dumpty who says, “When I use a word … it means just what I choose it to mean – neither more nor less.” </p>\n<p>There are two places where I see this pattern manifesting.  The Agile movement and Design Patterns. <figure><img src=\"/uploads/2017/12/2017-12-05.png\" title=\"Humpty Dumpty and Programming\"> Photo by <a href=\"//visualhunt.com/author/f31767\">aturkus</a> on <a href=\"//visualhunt.com/re/b4881b\">Visualhunt</a> &#x2F; <a href=\"//creativecommons.org/licenses/by/2.0/\"> CC BY</a></figure></p>\n<span id=\"more\"></span> \n\n<h2 id=\"Agile\"><a href=\"#Agile\" class=\"headerlink\" title=\"Agile\"></a>Agile</h2><p>Longtime readers are familiar with my rants against the failure of Agile.  Ever job interview I go to eventually ends up asking the same question. </p>\n<p>“Have you ever worked in an Agile organization before?” </p>\n<p>I have a lot of issues with this question, but my answer is always the same.  “I’ve worked in several organizations that call themselves Agile, but I’ve yet to work in one that really is.”  And there is the problem.  Even if I say I’ve worked in an Agile organization, there is no possible way you can be sure I’ve worked in an Agile organization that defines Agile the way you describe Agile.  So, why even ask the question? </p>\n<p>It is like Humpty Dumpty trying to explain the meaning of the poem <a href=\"//www.jabberwocky.com/carroll/jabber/jabberwocky.html\">Jabberwocky</a>. We define Agile with the bits we like and ignore the bits we don’t like or don’t understand, like the 4 blind men “looking” at an elephant and then wonder why it doesn’t really work for our organization. </p>\n<p>Next time someone ask me that question, I may just answer the question with another question, “Why do you ask?” or “How do you define ‘Agile’?” </p>\n<p>Seriously! What’s the point of asking the question when it doesn’t tell you anything about the applicant you are interviewing?  Agile has become such a major buzzword that I doubt you’ll find any applicants that haven’t worked in an organization that calls itself “Agile.”</p>\n<h2 id=\"Design-Patterns\"><a href=\"#Design-Patterns\" class=\"headerlink\" title=\"Design Patterns\"></a>Design Patterns</h2><p>The more popular the design pattern, the more likely we are to see the exact same issues in our programming.  Currently, we can most clearly see this in the MV* design pattern.  Here again, people are using the design pattern based on what they imagine it to be. </p>\n<p>In an article I wrote several months ago, someone recently commented about MVVM, “Isn’t that the way MVVM works? views don’t have business login, only pure “view” logic, the ViewModel is the one having business logic.” </p>\n<p>This is a common misconception.  That the ViewModel, or the Controller, or the Presenter (MVP) are where our business logic go.  This completely ignores the fact that MV* is a View layer design pattern.  The View part of the MV* is the part within the larger View layer that is responsible for rendering state.</p>\n<h2 id=\"A-Community-of-Hacks\"><a href=\"#A-Community-of-Hacks\" class=\"headerlink\" title=\"A Community of Hacks?\"></a>A Community of Hacks?</h2><p>Are we just a community of hacks?  I think maybe we are. All we care about is that we’ve shipped some code. We, largely, don’t care about our craft.  If we were artist, we starve.  Not because artist starve (which is a myth by the way) but because the code we produce is so crappy, no one would consider it valuable. </p>\n<p>If we built houses, we’d never get past the building inspectors.  If we were architects, the houses would never get built because the plans are too confusing. </p>\n<p>The blessing and the curse of programming is that we can change things quickly.  Because we can change things quickly, this has us believing there is no need to be careful. </p>\n<p>Each year we need more and more programmers to work on code because the codebase becomes crappier each year.  No one cares.  In the 30 years I’ve been programming, I’ve only had my code reviewed as a practice in two organizations.  That alone should tell you something about the state of our code.  And for all the claims about being Agile, none have used any best practices that grew out of Extreme Programming!</p>\n<h2 id=\"What-If\"><a href=\"#What-If\" class=\"headerlink\" title=\"What If?\"></a>What If?</h2><p>In previous post I’ve explored both sides of the technical interview process.  Up until recently, the technical interviews focused on the language, the framework, the tools.  And we try to develop an interview process that assures us that the applicant can actually use those tools.  Then when we hire them, and they can’t actually code. We wonder why? </p>\n<p>What if we got beyond tools to how people think?</p>\n<h2 id=\"Code-Puzzles\"><a href=\"#Code-Puzzles\" class=\"headerlink\" title=\"Code Puzzles\"></a>Code Puzzles</h2><p>Recently, I’ve been challenging myself with coding puzzles that are typically used at places like Google, Facebook and Amazon.  Problems that get at issues such as BigO notation, Binary Trees,  Memoization and much more.  I’m doing this for several reasons.  First, working on problems like this reminds me that I’m really not all that smart.  Oh, I can get by, but I don’t challenge myself to produce the best code possible.  Maybe the rant above is more about me than the industry, but I don’t think so.  I think I’ve risen (or more accurately, sunk) to the level of the people I’m surrounded by who themselves are only as high as the people they’ve been working with. </p>\n<p>I’m also doing these problems because being able to do them will inform my code.  Maybe I’ll never actually need to know about depth first vs breath first searches of a binary tree, but if I can do those problems, I will have additional tools in my toolbox when I code the mundane things.  </p>\n<p>And finally, these kinds of problems almost always have edge cases I don’t see.  I really need to get better at discovering edge cases before my clients do. </p>\n<p>And now, here’s the big question.  If these are the kind of questions that Google, Facebook, Amazon and others are using, what do they know that other companies don’t?  Could it be that hiring programmers that can answer these kinds of questions not only ensures that the quality of the code is better, but is actually cheaper in the long run?  Why not hire programmers who are a dime a dozen and can get the job done, but produce crappy code in the process?  I mean, if code quality doesn’t matter like most of our industry thinks, why do these successful companies not just go hire warm bodies?</p>\n<h2 id=\"The-Advantage\"><a href=\"#The-Advantage\" class=\"headerlink\" title=\"The Advantage\"></a>The Advantage</h2><p>The advantage to hiring based on how people think rather than on what tools they know is that when the tools change, it won’t matter to the developer who can think through these tougher issues.  On the other hand, those who can’t won’t be able to grasp some of the newer concepts that show up in newer tools.  I’ve seen this first hand as I’ve tried to explain NgRX, RxJS and Functional Programming generally to some of my peers.  Are they difficult concepts.  Sure they are! Are they worth learning? Absolutely!</p>\n<h2 id=\"Be-Intentional\"><a href=\"#Be-Intentional\" class=\"headerlink\" title=\"Be Intentional\"></a>Be Intentional</h2><p>So, what’s the point of all of this?  Mostly, be intentional. Don’t coast. Learn everything you can about your craft. </p>\n<p>Do you really know what MVC, MVVM, MVP, etc are and how they work? Or, are you just working off of what someone else has told you? </p>\n<p>Do you really know what Agile is? </p>\n<p>How many design patterns do you know that aren’t the hot new trend? </p>\n<p>Could you code your way out of an interview with Google, Facebook or Amazon? </p>\n<p>Where do you want to be with your career next year?  In 5 years? </p>\n<p>Are you average or striving to be awesome? </p>\n<p>Join me on the journey!</p>\n",
            "tags": [
                "programming",
                "agile",
                "design patterns"
            ]
        },
        {
            "id": "http://davembush.github.com/the-myth-of-sloppy-code/",
            "url": "http://davembush.github.com/the-myth-of-sloppy-code/",
            "title": "The Myth of Sloppy Code",
            "date_published": "2016-10-18T10:30:00.000Z",
            "content_html": "<ul>\n<li>Tightly coupled code runs faster.</li>\n<li>Tightly coupled code is easier to write.</li>\n<li>Test Driven Development increases development time.</li>\n<li>Test Driven Development negatively impacts code design.</li>\n<li>Knowing the names of design patterns isn’t important as long as you can use them.</li>\n<li>All my customer cares about is how soon they can have the product, not how clean the code is.</li>\n</ul>\n<p>All of these statements, and others like them, are excuses for not writing code correctly. And you know what an excuse is, right?</p>\n<blockquote>\n<p>The skin of a reason stuffed with a lie.</p>\n</blockquote>\n<figure>![](/uploads/2016/10/image-1.png \"The Myth of Sloppy Code\")<figcaption>Photo credit: [dynamosquito](//www.flickr.com/photos/dynamosquito/5866244470/) via [Visualhunt.com](//visualhunt.com) / [CC BY-SA](//creativecommons.org/licenses/by-sa/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>  \n\n<p>Now, I could go through and argue each of the points above. But today, I want to look more at the attitude behind these statements.</p>\n<h2 id=\"It’s-All-in-Your-Head\"><a href=\"#It’s-All-in-Your-Head\" class=\"headerlink\" title=\"It’s All in Your Head\"></a>It’s All in Your Head</h2><p>Man is a funny being. We make decisions with our hearts and justify the decisions with our brains. Once you know this, you can hack it to your favor. But how does this relate to what we’ve been talking about? It is really quite simple. All of the best practices I’ve mentioned above require work to learn. We would rather not invest the time to learn how to do these well, and so rather than just saying, “this is not where I choose to spend my time right now” we say things like, “my management won’t let me do that” or “my way is more efficient” or at times, we even resort to vilifying the practice.</p>\n<p>I have the same issue when I try to convince management that their process needs to change. It took seven years for me to get one company to move their project management system from email to project management software. Why? Because what they were doing “worked” and they couldn’t see that doing something different would work better in any way.</p>\n<h2 id=\"A-Skin-of-a-Reason\"><a href=\"#A-Skin-of-a-Reason\" class=\"headerlink\" title=\"A Skin of a Reason\"></a>A Skin of a Reason</h2><p>So, let’s look at the parts of these myths that are true.</p>\n<p>First, it is true that while you are learning how to use any one of these best practices, it will in fact, take you longer to write your code. Tightly coupled code is easier to reason about and one could argue is therefore easier to write. Test Driven Development is one of the most difficult things to learn. And just like the myth that Agile&#x2F;Scrum&#x2F;Kanban doesn’t work, the myth that Test Driven Development doesn’t work is largely based on misconceptions about what Test Driven Development is. Initially, it will impact the time it takes for you to write your code. But the more interesting argument to me is that testing negatively impacts design. If you mean that you can’t use the design you are used to using and that design involves writing tightly coupled code. Yeah, I guess it does.</p>\n<p>Implementing design patterns is better than not. It is true. But that doesn’t mean you shouldn’t learn the names.</p>\n<p>Yes, your customer cares about how fast you can get the project done. But, that isn’t all they care about.</p>\n<h2 id=\"The-Lies\"><a href=\"#The-Lies\" class=\"headerlink\" title=\"The Lies\"></a>The Lies</h2><p>Just because something takes longer while you are learning how to do it, doesn’t mean it will always take longer. It probably took you a while to learn how to program proficiently too. That didn’t stop you did it? Does it take you as long to program now as when you first started? Of course not! Let’s look at this from another angle. As you’ve learned multiple languages, would you say that it made you a better or worse programmer? Unless you have a very strange perspective, you will probably answer better. Was the new language hard to learn? Of course. Did it take you longer to code using the new language than one you knew previously? Of course. Would you say the result of being proficient in both has made it easier or harder to code in both? Easier, right? Tightly coupled code is easier to write, but as the application grows, tightly coupled code becomes harder to add to and harder to maintain. It lends itself to code duplication and is more likely to be the code base that needs to be rewritten first.</p>\n<p>Tightly coupled code is also the hardest to tests and is probably the reason you don’t want to write test for your code. Because you write tightly coupled code, testing is MUCH harder than it should be. This leads you to have a firm belief that writing tests is hard as well. A vicious cycle.</p>\n<p>And if you believe that tightly coupled code is a proper design, you will believe that tightly coupled code hinders design. But in fact, writing tests will force you to write loosely coupled code. So, instead of hindering design, it actually helps it.</p>\n<p>I used to think not learning the correct names for design patterns didn’t matter. But the advantage of knowing the proper name for things is that we can all talk about something using the name rather than trying to explain what that thing is with lots of words. It saves time. But, there is another much more subtle reason why you need to learn the proper name for things. You might be calling a design pattern you are using by an incorrect name and confusing the people you are communicating with. And, finally, learning the names for all of the design patterns will expose you to design patterns you aren’t aware of, broadening your horizons.</p>\n<p>This last one is, or should be the most obvious. Getting the project done quickly isn’t ALL your customer cares about. It might be a relatively high priority, but I can assure you, if you explain to them that getting the project done as fast as possible will mean you have to rewrite the code if they want any changes, you’ll quickly find out that redoing work they’ve already paid for doesn’t sit well with them either.</p>\n<h2 id=\"Benefits\"><a href=\"#Benefits\" class=\"headerlink\" title=\"Benefits\"></a>Benefits</h2><p>It is a sad, sad truth that by convincing yourself that not investing in these best practices really is best for you and the clients you work for, you’ve also limited yourself to the quality of client you can work for. The places that pay well expect you to know how to do this stuff. They believe in good design. They believe in testing. They know how to implement design patterns.</p>\n<p>And guess what, these places also pay better too. It raises you beyond the level of “commodity programmer” and into the level of “rare gem” How do I know? This past year I’ve been doing a lot of interviewing. For various reasons, I decided to interview for jobs that pay 25% better than what I currently make. In the beginning, I did this because I figured it would expose me to people more like myself who wanted to be better. In the process, I discovered that the interview process is a little harder, but not impossible. I figured out what I still need to learn. And, I managed to beat my goal. Time to notch it up a bit more.</p>\n<h2 id=\"Are-You-Dead\"><a href=\"#Are-You-Dead\" class=\"headerlink\" title=\"Are You Dead?\"></a>Are You Dead?</h2><p>You hear stories all the time about people who can’t find work in our industry. When you ask, you find out that all they know is something that was hot 10 years ago or longer. Well, of course you can’t find a job. And it is no wonder the last company got rid of you. You provide no value.</p>\n<p>This past week I heard someone tell me the equivalent of, “I’m not going to learn anything new. Every time I do, it ends up being hot for a few years and then it is gone.” I was stunned. I fear for this guy. You might as well say, “I’m planning to retire in 10 years or less.” because that is what will happen to you. Worse, if you stop learning completely, you could end up with dementia or worse.</p>\n<p>My plan is to program until I’m at least 75. Longer if I stay healthy enough. Even if I could retire, I won’t. What would I do? I love programming. I love mentoring other programmers. I love learning new stuff.</p>\n<h2 id=\"Do-hard-stuff\"><a href=\"#Do-hard-stuff\" class=\"headerlink\" title=\"Do hard stuff\"></a>Do hard stuff</h2><p>And so what’s the point of all this? Do hard stuff. It will make you a better programmer.</p>\n",
            "tags": [
                "tdd",
                "agile",
                "design patterns"
            ]
        },
        {
            "id": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "url": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "title": "8 Reasons Johnny Does Not Write Bug Free Code",
            "date_published": "2016-09-20T10:30:00.000Z",
            "content_html": "<p>There have been a number of things that have occurred over the last week that have prompted this particular post.  And for anyone I work with, this is not an indictment of our work place so much as it is an indictment of our industry.  PLEASE don’t take this personally.</p>\n<p>Some of those reasons will show up in this article.  But the question we need to examine today is why is it so hard to write bug free code.  And I’m not even talking about perfection.  Why is it that we miss the simple stuff?  The stuff that once it is found, we think, “how could we have missed that?!”.  I’m perfectly aware that all code has bugs some just haven’t been found yet.  I’m also aware that no matter how hard I try, the stupid bugs always make their way past my desk.</p>\n<figure>![](/uploads/2016/09/image-1.png \"8 Reasons Johnny Does Not Write Bug Free Code\")<figcaption>Photo credit: [~Pawsitive~Candie_N](//www.flickr.com/photos/scjn/3450910519/) via [Visualhunt](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"No-Training\"><a href=\"#No-Training\" class=\"headerlink\" title=\"No Training\"></a>No Training</h2><p>Certainly not the only reason.  But at the same time I think this is a core reason.  Our industry really sucks when it comes to teaching computer science.  So much so, that I’ve written articles about how, for the most part, you don’t need a college education to become a programmer.  Maybe if we taught what programmers don’t already know how to do, a college education would be valuable.</p>\n<p>But what do we do instead?  We teach programmers how to program.</p>\n<p>Dumb! I think back to my education.  Here’s a basic summary of what I learned:</p>\n<ol>\n<li>COBOL, dBase III, JCS, CICS syntax.</li>\n<li>Break your code into functions</li>\n<li>A bit on how to do requirements analysis.</li>\n</ol>\n<p>Guess what?  I could have learned all of that on my own.  How do I know that?  Because I had already taught myself, Basic and C before.  I taught myself every language I’ve learned since.  I was already writing structured code, and still do.  And how we gather requirements has changed and somehow I managed to learn that on my own.  Programming is a learning profession.  It is one of the things that makes it attractive to me.</p>\n<p>But what didn’t I learn?  At no point did anyone ever teach me how to break my own code.  And while Test Driven Development wasn’t a thing when I was going to school.  I doubt they are teaching it today.  (Let me know if your school did or is.)</p>\n<h2 id=\"Happy-Path-Specs\"><a href=\"#Happy-Path-Specs\" class=\"headerlink\" title=\"Happy Path Specs\"></a>Happy Path Specs</h2><p>So, the programmers have no training.  But it isn’t just a programmer problem.</p>\n<p>When is the last time you got a specification from whoever creates them in your organization that had any more than a happy path set of requirements?  But, certainly there are things the system should not do.  I recently had to go asking for required fields and maximum field lengths in an application I was working on.  And that’s the simple stuff.</p>\n<h2 id=\"Not-My-Job\"><a href=\"#Not-My-Job\" class=\"headerlink\" title=\"Not My Job\"></a>Not My Job</h2><p>If you have a QA department, you might be tempted to leave testing to QA.  My personal goal is to make sure QA doesn’t find anything.  At least, not something really obvious.</p>\n<p>But I know that some programmers get sloppy about testing their code if they know the safety net of QA exist.</p>\n<p>There is also the problem of QA believing they are the only ones who test.  Strange, but true.  When QA found out I was writing unit test for a pretty complex piece of logic, I was asked, “Then what will be left for me to do?!”  Strange but true.</p>\n<p>But what if we started working as teams?  For example, what if I could get QA to help me develop my test plan?  What if developing software was a WE activity instead of several silo developers each doing their own thing?</p>\n<h2 id=\"Batch-Programming\"><a href=\"#Batch-Programming\" class=\"headerlink\" title=\"Batch Programming\"></a>Batch Programming</h2><p>This is one I really don’t understand.  But I know programmers who will write code for hours prior to running it.  Even if you did remember everything you coded, how can you possibly know where a bug is located if you wait that long?  You should be running your code every time you have something different that can be run so that you know what change caused a problem.  And don’t tell me you test every possible condition.  I know you don’t.</p>\n<p>Programmers who program like this are “Debbie Done” programmers.</p>\n<p>Why “Debbie Done”? There is this story about a programmer who used to work at one of the companies I worked at in the past.  She considered code done if it compiled and linked.</p>\n<p>I’m not as good at testing as I would like (yet) and I’m always embarrassed when someone finds a problem with my code.  So, I was shocked one day when I found out that a project manager wanted to give me some work because my code “always works.”  I knew that wasn’t true.  But when I reflected on what he was saying I realized that the difference in how I code and the other programmers he was comparing me to is that I write for a few minutes and then make sure that works before I continue on.</p>\n<h2 id=\"We-Don’t-Plan-to-Test\"><a href=\"#We-Don’t-Plan-to-Test\" class=\"headerlink\" title=\"We Don’t Plan to Test\"></a>We Don’t Plan to Test</h2><p>Ah.  And here we get a little closer to the truth.</p>\n<p>What do I mean by planning to test? For any spec you are working on, you should have, written out or coded, a repeatable set of steps that ensures that your code does what it should and doesn’t do what it shouldn’t.  This is what test driven development attempts to steer us toward.  I’m not going to go off on a rant about TDD again here.  But I will tell you that either having a written out test plan prior to coding enables me to ensure that my code does what the people who gave me the specification think it should.  It also forces me to think about ways I might break the code.  I know my code is delivered with less bugs because of this process.  Hopefully, I’ll get better at thinking of how to break my own code.</p>\n<p>Having a plan helps with the Debbie Done programmer as well as people who code more like me.</p>\n<p>Even though I code&#x2F;test incrementally, I still only test the code right after I’ve written it.  Once I think it is working, I don’t go back, even though something else I’ve written may have changed how the code is working.  Having repeatable tests has save me several times.</p>\n<h2 id=\"We-Don’t-Know-what-we-Don’t-Know\"><a href=\"#We-Don’t-Know-what-we-Don’t-Know\" class=\"headerlink\" title=\"We Don’t Know what we Don’t Know\"></a>We Don’t Know what we Don’t Know</h2><p>Even if we do everything right, we are still going to miss stuff.  One person can’t possibly figure out all that might go wrong.  It is how we deal with the problems once they are revealed that becomes the issue.  This is where we would, ideally, have the team come up with the test scenarios.</p>\n<h2 id=\"Shame-Driven-Development\"><a href=\"#Shame-Driven-Development\" class=\"headerlink\" title=\"Shame Driven Development\"></a>Shame Driven Development</h2><p>I actually heard a project manager say, “Shame on the developer if QA finds bugs.” Really?!  What about “Shame on the BA for not including that item in the requirements.”?  What about “Shame on the product owner for not mentioning it.”? Or what about no shame at all? While shame is a powerful motivator in the short term, it is a sure way to make sure your developers leave.</p>\n<p>That you only retain highly dysfunctional programmers.  Or that you can only retain programmers who can’t really code.</p>\n<p>Shame based development can only lead to even more bugs.  Not fewer.</p>\n<p>At some point I should probably write about the dangers of a shame based culture.   If your organization is using shame to manage personnel.  Get out!</p>\n<h2 id=\"Long-Hours\"><a href=\"#Long-Hours\" class=\"headerlink\" title=\"Long Hours\"></a>Long Hours</h2><p>Another way you can kill the overall effectiveness of your team is to make sure everyone works more than 45 hours a week for months or years at a time.  One of two things will happen, if not both.</p>\n<p>The code will suffer.  Want to introduce more bugs?  Keep everyone working overtime.  A week here or there is a different story.</p>\n<p>If the code doesn’t suffer, then you are likely to find a lot more socialization, social media activities, and just plain goofing off occurring.  People just can’t work that many hours.  Just because someone is at work for 10 hours doesn’t mean they are working 10 hours.  But hours are easy to measure, so this terrible practice continues.</p>\n<h2 id=\"We-Can’t-Fix-Everything\"><a href=\"#We-Can’t-Fix-Everything\" class=\"headerlink\" title=\"We Can’t Fix Everything\"></a>We Can’t Fix Everything</h2><p>I’m in a unique position in that I’m currently functioning as a Scrum coach.  This allows me to influence all the areas I’ve discussed.  As programmers, you can only influence your own stuff.  So, my recommendation to you is to concentrate on what you have control over.  Create a test plan prior to writing code.  Once you’ve learned how to do that, work on learning how to code those test so you don’t have to run them manually over and over again.  Do this slowly.  Maybe start with just one test.  Squeeze it into the cracks of your regular work.  Learning to test and learning to code test takes time, but it will make you a better programmer and will ultimately make you a more reliable and faster programmer.  Someday you might just hear that they want to give you an important job because “Johnny’s code always works.”</p>\n",
            "tags": [
                "tdd",
                "code",
                "agile",
                "scrum",
                "bug"
            ]
        },
        {
            "id": "http://davembush.github.com/3-reasons-agile-will-not-succeed/",
            "url": "http://davembush.github.com/3-reasons-agile-will-not-succeed/",
            "title": "3 Reasons Agile Will Not Succeed",
            "date_published": "2016-06-09T10:30:00.000Z",
            "content_html": "<p>I’ve written about <a href=\"/categories/Agile/\">Agile</a> and <a href=\"/tags/scrum/\">Scrum</a> before and most of my regular readers know that I am a huge fan.  But recently I am starting to believe the Agile movement is doomed.  In fact, the most common response to my enthusiasm for Agile and Scrum is, “Yeah, we tried that once and it was a complete failure.”  Which seems odd to me because in every instance where I’ve been able to implement it, it has worked beautifully.  </p>\n<p>So why would I say Agile Will Not Succeed?</p>\n<p>The buzz around Agile has become so loud that Agile has moved from strictly a software development thing, to all corners of the business world.  And yet, as much as I believe Agile is the right way to develop software, as a movement, it is doomed for failure. </p>\n<p>Why?</p>\n<figure>![](/uploads/2016/06/image.png \"3 Reasons Agile Will Not Succeed\")<figcaption>Photo credit: [Tim Evanson](//www.flickr.com/photos/timevanson/9325191852/) via [VisualHunt](//visualhunt.com) / [CC BY-SA](//creativecommons.org/licenses/by-sa/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Reminder-Agile-Isn’t-a-Method\"><a href=\"#Reminder-Agile-Isn’t-a-Method\" class=\"headerlink\" title=\"Reminder - Agile Isn’t a Method\"></a>Reminder - Agile Isn’t a Method</h2><p>This is the surest sign that a movement is struggling.  It has become so popular that people are using it without knowing anything of what they are doing.  The surest sign you’ve walked into an organization where Agile is doomed is if they say something along the lines of “We do Agile.”</p>\n<p>Why is this a clear sign? </p>\n<p>Because you can’t DO Agile.  You can only BE Agile.  <a href=\"//www.agilemanifesto.org/\">Read the Agile Manifesto</a>.  There is nothing there about how to implement Agile.  It simply isn’t a methodology.  So, when an organization says to me they are “Doing Agile” it tells me right away that they have no idea what it means to be Agile.</p>\n<h2 id=\"‘Doing-Agile’-for-the-Wrong-Reasons\"><a href=\"#‘Doing-Agile’-for-the-Wrong-Reasons\" class=\"headerlink\" title=\"‘Doing Agile’ for the Wrong Reasons\"></a>‘Doing Agile’ for the Wrong Reasons</h2><p>One of the outcomes of implementing an Agile process is that code tends to get developed faster.  Unfortunately, this has become the main selling point of moving toward Agile.  I get it, every shop I’ve worked in has been under some sort of development pressure to get stuff done.  So it is easy to look at faster delivery as the main reason why you would use an Agile method. </p>\n<p>But, speed is a side effect.  In fact, it is only a long term side effect.  Initially, as you move toward being Agile, you will probably end up being slower.  You might have to lay people off because they only know how to work on their own while true Agile requires teamwork.  The more mature your team, the harder it will be to switch.</p>\n<p>So, if you shouldn’t move toward Agile because of speed, why should you? Well, two of the main reasons for me are: visibility, flexibility, and predictability.</p>\n<p>I was once told the story of how plumbers plumb a new house.  The first day they come in and hang all the pipes in hangers.  By the time the owner comes by that evening, everything is hung and it looks like they are practically done.  They now have two weeks to get it all soldered together before the owner comes by again. This is why most Agile methods require short sprints.  The more you can show the customer the progress you are making, the less nervous they will get and the more likely you are to be left alone to do your job.  However, it will take time because the customer has been burned too often in the past, so it may be a while before they learn to wait for the sprint reviews.</p>\n<p>But there is an added advantage to being visible that is a huge win for everyone.  By letting the customer see the progress you are making, he is able to make tweaks along the way.  I’ve learned over the years that no one really knows what they want until they see it.  But letting them see it often and make tweaks along the way saves me from having to do a complete rewrite when I am “done.” And agile adds predictability that isn’t available using older methods.  It doesn’t let you say up front how long a project will take.  Estimates are still rather futile.  You’ll never know less about a project than the first day you try to provide an estimate.  But, as you progress, you will know roughly how much effort the remaining project will take and how much time that much effort will take on average.  The project becomes predictable using statistics generated by the project.</p>\n<h2 id=\"You-Aren’t-Fully-Committed\"><a href=\"#You-Aren’t-Fully-Committed\" class=\"headerlink\" title=\"You Aren’t Fully Committed\"></a>You Aren’t Fully Committed</h2><p>In my last interview, I was asked if I had any experience with “Agile.”  I really need to learn to qualify that question.  I answered, “<a href=\"//www.scrumalliance.org/community/profile/dbush2\">I have my Scrum Master certification</a>, but I’ve yet to work in a truly Agile environment.”  And yet, I have worked in environments that call themselves “Agile”  But these are all environments that Carl and Richard over at <a href=\"//dotnetrocks.com/\">DotNetRocks</a> call “Scrum But…”.  “Agile But…”?  And at another place, we called it “Scrummerfall”.  The idea is the same, rather than doing either Scrum or Kanban, they take the parts they’ve heard about that they like and merge them into what they are currently doing.</p>\n<p>Of course, they weren’t fully committed to the process they were using either, so it shouldn’t work any worse.  But it often does.</p>\n<p>One of the most obvious points of failure is with project management.  I’ve seen it all.  Scrum masters who are still trying to function as project managers and organizations that have skipped the scrum master role and left the project managers.  Stand ups that last an hour.</p>\n<p>Or how about this one.  Teams trying to estimate stories instead of task.</p>\n<p>I went on one interview that had the following bullets in the job request I was sent:</p>\n<ul>\n<li>Must be able to work in an Agile environment</li>\n</ul>\n<p>followed three points later by</p>\n<ul>\n<li>Must be able to work under tight deadlines.</li>\n</ul>\n<p>Talk about an oxymoron! When I asked what “Agile” meant to him (the owner of the company) he said, “Oh, that just means we do iterative development.” Here’s the deal.  If you are going to say you are going to implement Agile, at least learn enough about it to know what the word means!  You might decide it isn’t for you.  That’s fine.  Doing something simply because it is the “In” thing to do is never a good reason to do something.</p>\n<h2 id=\"Management-Has-No-Clue\"><a href=\"#Management-Has-No-Clue\" class=\"headerlink\" title=\"Management Has No Clue\"></a>Management Has No Clue</h2><p>In my current job, I was told that some boss several levels up who I’ve still not met has declared our project to be a “Waterfall project” because “we already know what this is supposed to do.” As soon as I heard that, I said, “Someone doesn’t know what Agile is.” Here is why this sounds right.  The project I am working on is a rewrite from a very old platform to a web application.  In principle, from that definition, it sounds like a known entity.  However, simply because the GUI has changed there are things that were done on the old platform that make no sense on the new platform.</p>\n<p>But it gets worse.  The application is being expanded to include other business units with additional requirements.  So, we only partially know all this is supposed to do.</p>\n<p>If we were using true Waterfall, we would have to design the whole thing up front.  This project is due in a little less than a year.  Tell me what on the web doesn’t change in a year?</p>\n<h2 id=\"Agile-Will-Not-Succeed\"><a href=\"#Agile-Will-Not-Succeed\" class=\"headerlink\" title=\"Agile Will Not Succeed\"></a>Agile Will Not Succeed</h2><p>So, what’s the point?  People love their perceptions.  Not reality.  What Agile set out to do was nobel, and for the most part, right.  But people are lazy.  They get a snippet of the truth here, a snippet of the truth there, ignore a snippet, paste in a snippet (here a snippet, there a snippet, everywhere a snip of snippet).  And that becomes their truth, while not being THE truth.  We do it with everything we believe.  Agile has reached that point of group think that it can now be classified as “religion.”  It now has so much group think weight that I’m not sure even those who started the movement can clearly articulate what it IS anymore.</p>\n",
            "tags": [
                "agile",
                "failure",
                "kanban",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/how-to-be-personally-agile/",
            "url": "http://davembush.github.com/how-to-be-personally-agile/",
            "title": "How to be (Personally) Agile",
            "date_published": "2015-11-19T13:30:00.000Z",
            "content_html": "<p>When I first wrote down the idea for this post, I was originally thinking about how we might use agile development practices in a work place that practices Water Fall or worse.  But since then, I’ve expanded my thinking to include the concept of using agile everywhere, including where it “isn’t allowed.” Here’s what I’m talking about.  What does your work environment look like?  Many of the places I end up working either are using no formal process at all, or weakly attempt some form of Scrum or Water Fall.  In fact, my current major gig has a “project manager” (I use the term loosely) that manages our project with MS Project.  There is not even a formal issue tracking system.  And this is at a very LARGE organization that SHOULD know better.</p>\n<p><img src=\"/uploads/2015/11/image1.png\" alt=\"image\" title=\"image\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Agile-in-an-Anti-Agile-Environment\"><a href=\"#Agile-in-an-Anti-Agile-Environment\" class=\"headerlink\" title=\"Agile in an Anti-Agile Environment\"></a>Agile in an Anti-Agile Environment</h2><h3 id=\"Kanban-Board\"><a href=\"#Kanban-Board\" class=\"headerlink\" title=\"Kanban Board\"></a>Kanban Board</h3><p>Now, I’m not saying I’m the most organized guy on the planet.  In fact, in an environment like this, it would be easy to just go with the flow.  But I know me well enough to know that if I don’t have a place to keep track of the task I need to accomplish, something will fall through the cracks.  So, I got permission to use <a href=\"/trello\">Trello</a> along with the <a href=\"/plusForTrello\">Plus for Trello</a> plugin on Chrome so that I can at least track the task that have been assigned to me.</p>\n<p>Trello, for those who don’t know, allows you to setup a basic Kanban board and configure it any way you would like.  From the basic, “To do”, “In Progress”, “Done” format to something more in line with your actual work flow.  For this project, I have “Back Log”, “On Hold”, “Up Next”, “In Progress”, “Done This Week” and “Done”.  Yeah, that’s a lot of columns.  But I want to be able to keep track of where my task are at that level.  The beauty of Trello is that you can configure it however you want.</p>\n<p>Plus For Trello builds on that and allows you to add estimates to each of your Trello Cards.  While they refer to the estimate as “hours” I just translate that to “Effort Points” and track how much effort I think I’ve completed rather than how many hours I’ve actually worked.</p>\n<p>Between the two, I can track how far along in the project I am, how many effort points I tend to complete each week, and I’m the only one on the team who can give a reasonable guess as to when I will be done with this project I am working on.  And when I need to change the estimates, I can show when they changed and why.</p>\n<h3 id=\"Productivity-Hacks\"><a href=\"#Productivity-Hacks\" class=\"headerlink\" title=\"Productivity Hacks\"></a>Productivity Hacks</h3><p>But agile isn’t just about Kanban boards and accurate estimates.  Agile is about becoming better.  So, what are some ways you can become better at work without being any more disruptive than you have to be?  Here are some ways that have been effective for me:</p>\n<ul>\n<li><p><strong>Use the Pomodoro technique</strong></p>\n<p>The <a href=\"/pomodoro\">Pomodoro</a> technique is a technique that has you highly focused on the task at hand for 25 minutes at a time.  No interruptions for email, social media, coffee.  That’s for the breaks or their own Pomodoro.  After 25 minutes of work, you get a 5 minute break.  Sometimes I just sit in my chair and close my eyes.  Kind of a mini nap.  The routine has you do 4 Pomodoros and then rest for 15 minutes instead of 5.  If you take a lunch, you should take your lunch break during one of the longer Pomodoros.</p>\n</li>\n<li><p><strong>Avoid Distractions</strong></p>\n<p>I don’t know about you, but the last time I had the luxury of an office was 2.5 years ago when I was working from home.  I miss those days.  But now I close my virtual door by putting on headphones and listening to <a href=\"//t.co/EgPhHCQqLE\">this Pandora station that I created</a>.</p>\n</li>\n<li><p><strong>Batch E-mail</strong></p>\n<p>As I said before, don’t check email while you are working.  I check mine during the Pomodoro breaks.  If you get more than what you can handle during the breaks you should create a Pomodoro for them.</p>\n</li>\n<li><p><strong>Schedule Your Day!</strong></p>\n<p>OK, this may or may not work for you depending on your environment.  But, it is worth a try.  Personally, I know that my best hours are in the morning and that I start losing my concentration around 1:30.  I start my day at around 7am.  Ideally, if you want me to be productive, you won’t schedule meetings prior to 1:30.  So, I went into outlook and scheduled myself as “Busy” from 7am to 1:30pm.  Now when someone looks to see when I am available, they will see that I am available from 1:30 to 3:30.</p>\n<p>You might object that this is not being honest.  But I would argue that it is if you honestly believe that keeping appointments with yourself is as important as keeping appointments with other people.  It is just a matter of perspective.</p>\n</li>\n<li><p><strong>Turn Off Your Phone</strong>!</p>\n<p>OK, I’m assuming you are all programmers and not sales people.  But, I would go so far as to say that the only time you should answer your phone is when you have an appointment.  I stopped answering my phone YEARS ago.  Most of the calls that I got were either sales calls or recruiters.  Then I finally got smart and created a silent ring tone for my phone.  That is my default ring tone.  And my default vibrate pattern is no vibration at all.  I don’t even know that my phone rang until I look at my phone and it says I have a missed call.</p>\n<p>But, I can hear you say, I might miss something important.  Well, yes, there are calls that I don’t want to miss.  For those, I assign real ring tones.  Everyone in my family and some VERY close friends, all get a real ring tone that makes a sound.</p>\n<p>What about potential clients?  Well, first I schedule the call via email, if I even determine it is necessary, and second I ask for the number they will be calling from so that I can assign a ring tone to that number.</p>\n<p>I wish I could do something similar with my desk phone at work.  I answered it yesterday only to have it be a sales call.  I should have known better!</p>\n</li>\n</ul>\n<p> </p>\n<h2 id=\"Agile-Home\"><a href=\"#Agile-Home\" class=\"headerlink\" title=\"Agile Home\"></a>Agile Home</h2><p>There is a whole course on PluralSight about being an Agile Family.  I’m not talking about that.  I’m talking about being personally Agile at home just like I am suggesting that you can be personally Agile at work, regardless of the environment.</p>\n<h3 id=\"Kanban-Again\"><a href=\"#Kanban-Again\" class=\"headerlink\" title=\"Kanban Again\"></a>Kanban Again</h3><p>Yep, I use Trello at home too.  But not the Plus for Trello plugin.  At least not yet.  I have a list that keeps track of my exercise rotation.  I have a list for Saturday.  I have a list of chores I need to do.  I have others, but those are the ones that I use regularly.</p>\n<h3 id=\"Schedules\"><a href=\"#Schedules\" class=\"headerlink\" title=\"Schedules\"></a>Schedules</h3><p>I schedule my whole day.  This probably sounds more extreme than it is.  I was finding that not having a schedule, especially after work, was actually preventing me from getting stuff done that I really wanted to get done.</p>\n<p>Here are tips for scheduling:</p>\n<ul>\n<li><strong>If you really want something to get done, schedule it.</strong></li>\n<li><strong>Don’t schedule every last minute</strong>. For example, I know it generally takes me 45 minutes to get home.  But I also know bad traffic could make that longer.  So I don’t plan the next activity after work until 4:45.</li>\n<li><strong>Schedule your Kanban list</strong>. I’m assuming your Kanban list are projects that you want to get done.  Well, if you really want them to get done, when are you going to work on them?</li>\n<li><strong>Don’t try to do too much</strong>. Once I started scheduling, I realized I was trying to accomplish way more than was physically possible.</li>\n</ul>\n<p>Schedules are a great way for you to determine, ahead of time, what is most important to you.  Once that decision has been made, it is just a matter of execution.  If there are other things you’d like to be able to do, put them on the back log.</p>\n<h2 id=\"The-Point\"><a href=\"#The-Point\" class=\"headerlink\" title=\"The Point\"></a>The Point</h2><p>So what’s the point of all of this?  Don’t wait on someone else.  You can be agile even if&#x2F;when others aren’t.</p>\n",
            "tags": [
                "agile",
                "productivity"
            ]
        },
        {
            "id": "http://davembush.github.com/tdd-gamification-turning-test-driven-development-into-a-game/",
            "url": "http://davembush.github.com/tdd-gamification-turning-test-driven-development-into-a-game/",
            "title": "TDD Gamification - Turning Test Driven Development into a Game",
            "date_published": "2015-04-23T10:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/04/ge-gam-018.jpg\" alt=\"ge-gam-018\" title=\"Test Driven Development Gamification\"></p>\n<p>When I was in college, there were some guys I hung out with who played this game called “Questions” which they got from some book.  <a href=\"//en.wikipedia.org/wiki/Questions_(game)\">Actually, it was a play</a>. Anyhow, the basic rules are:</p>\n<ul>\n<li>You can’t answer a question with a statement</li>\n<li>You can’t hesitate or make a false start</li>\n<li>You can’t repeat a question that has already been used</li>\n<li>You can’t ask a rhetorical question</li>\n<li>You can’t ask an unrelated question.</li>\n</ul>\n<p>There was also <a href=\"//dotnetrocks.com/default.aspx?showNum=1111\">this podcast at DotNetRocks</a> where they were talking about a beer app and how they had added game elements to the app by adding badges for various types of beer to get you out of your comfort zone.  Maybe there is one for “My first beer that I liked” because I’ve yet to find something I like.  But give me a good Merlot! All of this got me to thinking about how we might turn Test Driven Development into something of a game. There are several people who have already addressed the Gamification of TDD</p>\n<span id=\"more\"></span>\n\n<h2 id=\"TDD-and-the-Gamification-of-Testing\"><a href=\"#TDD-and-the-Gamification-of-Testing\" class=\"headerlink\" title=\"TDD and the Gamification of Testing\"></a><a href=\"//effectivesoftwaredesign.com/2011/11/21/tdd-and-the-gamification-of-testing/\">TDD and the Gamification of Testing</a></h2><p>This article talks mostly about how TDD has many elements of good gaming inherent in it.</p>\n<ul>\n<li>Because it makes testing more like programming.  Well, what he actually says is that it raises testing to the level of complexity the programmer is familiar with.  But in reality, I think this is because it makes testing something that can be coded.</li>\n<li>Because TDD is measurable.  The test either succeeds or fails.</li>\n<li>Because TDD gives you immediate feedback.  Or at least a well written test gives you immediate feedback.</li>\n</ul>\n<h2 id=\"TDD-The-Gamification-of-Programming\"><a href=\"#TDD-The-Gamification-of-Programming\" class=\"headerlink\" title=\"TDD: The Gamification of Programming\"></a><a href=\"//benvanik.tumblr.com/post/20702406947/tdd-the-gamification-of-programming\">TDD: The Gamification of Programming</a></h2><p>This article provides an interesting perspective of someone trying to program using TDD for the first time.  You get the normal complaints, like “this takes too long” along with acknowledgement of some of the benefits.  But what he realizes is that the process has made programming more like a game than about the creative problem solving most of us got in to programming for in the first place.</p>\n<h2 id=\"Gamify-TDD\"><a href=\"#Gamify-TDD\" class=\"headerlink\" title=\"Gamify TDD\"></a><a href=\"//www.tdddev.com/2014/09/gamify-tdd.html\">Gamify TDD</a></h2><p>This is the first article I found that, instead of saying that TDD is already a game, like the two above, actually ask how we might formally turn TDD into a game because it already has many elements of a game.  But he never actually says HOW he would do that.</p>\n<h2 id=\"TDD-Gamification\"><a href=\"#TDD-Gamification\" class=\"headerlink\" title=\"TDD Gamification\"></a>TDD Gamification</h2><p>Putting this all together.  Here is how I would actually make TDD into a game.</p>\n<h4 id=\"The-rules\"><a href=\"#The-rules\" class=\"headerlink\" title=\"The rules:\"></a>The rules:</h4><ul>\n<li>The game is played in pairs.  (Paired programming)</li>\n<li>Game starts when programmer 1 writes the first test.</li>\n<li>Once a failing test is written, programmer 2 writes JUST ENOUGH to make the test succeed.</li>\n<li>Once a test succeeds, programmer 2 writes another test, and programmer 1 writes just enough to make it succeed.</li>\n<li>Play alternates until no one can think of another test that will force more code to be written.</li>\n<li>Programmer loses points if he is caught writing more code than is necessary to pass the test.</li>\n<li>Programmer loses points if he is caught writing code that has dependencies embedded in it.</li>\n<li>If a dependency is required, the test writer and the code implementer will collaborate in the method of dependency injection to be used.</li>\n<li>All points lost by one programmer go to the programmer who caught the mistake.</li>\n</ul>\n<h4 id=\"Embellishment\"><a href=\"#Embellishment\" class=\"headerlink\" title=\"Embellishment:\"></a>Embellishment:</h4><p>If code is found to have a bug in production, both programmers responsible for the code loose a point, regardless of how many lines of code are impacted.  One point per recorded bug.</p>\n<p>I’m assuming that most shops have more than 2 programmers.  On any given day, programmers would be paired up for the day of programming.  They are responsible for turning out bug free code.  Because we are tracking the code over the long term, we will be able to see just how effective each programmer is at eliminating bugs.</p>\n<p>In fact, if you are in an environment that can’t quite stomach having your programmers paired up, I would suggest keeping track of the code that wasn’t done under the game.  This would be the “house score” compared to an individual programmer’s score.</p>\n<p>The only thing we have left is some way of being able to account for productivity.  I mean, if I write no code, I’ll have no bugs, right?  And all things being equal, the more productive I am, the more bugs I’ll have.  So how do we measure this? Here is what we can’t do:</p>\n<ul>\n<li>Lines of code – you can’t measure based on lines of code because that has been shown to be an inaccurate measure of productivity.  More lines may just mean you are not very efficient.</li>\n<li>Hours worked – <a href=\"/rapidDevelopment\">Rapid Development</a> has statistics in it that show there is a factor of 10 difference between good programmers and bad programmers.</li>\n</ul>\n<h4 id=\"Just-a-suggestion\"><a href=\"#Just-a-suggestion\" class=\"headerlink\" title=\"Just a suggestion:\"></a>Just a suggestion:</h4><p>Since short methods are desirable, what if we measure number of test relative to number of methods relative to number of classes.  This would enforce the single responsibility principle.</p>\n<p>T &#x3D; Tests M &#x3D; Methods C &#x3D; Classes 1&#x2F;((T&#x2F;M)&#x2F;C) &#x3D; Productivity Score Therefore,</p>\n<ul>\n<li>If I worked on 3 classes each with 6 methods and each method has 2 tests, I end up with a productivity score of 1.5</li>\n<li>If I had one class with 18 methods each with 2 tests, I end up with a productivity score of .5</li>\n<li>If, on the other hand, I put everything in one method, and one class and had the same 36 tests, my productivity score would be .02</li>\n<li>If you write no code, your productivity score is 0.</li>\n</ul>\n<p>That’s just a simple way to calculate.  You may choose to use cyclomatic complexity in some way if you have that number easily available to you.</p>\n<p>Well, that’s my rough sketch of how we might be able to turn TDD into something of a game along with being able to prove to ourselves and management that it really does produce better code. How else might you embellish this or change it so it works better?  Let me know in the comments below.</p>\n<h4 id=\"Other-Test-Driven-Development-Resources\"><a href=\"#Other-Test-Driven-Development-Resources\" class=\"headerlink\" title=\"Other Test Driven Development Resources\"></a>Other Test Driven Development Resources</h4><ul>\n<li><a href=\"/testDrivenDevelopmentByExample\">Test Driven Development: by Example</a></li>\n<li><a href=\"/professionalTestDrivenDevelopmentWithCSharp\">Professional Test Driven Development w&#x2F; C#</a></li>\n</ul>\n",
            "tags": [
                "tdd",
                "agile",
                "extreme programming",
                "gamification",
                "paired programming"
            ]
        },
        {
            "id": "http://davembush.github.com/limiting-beliefs-of-programmers/",
            "url": "http://davembush.github.com/limiting-beliefs-of-programmers/",
            "title": "Limiting Beliefs of Programmers",
            "date_published": "2015-04-09T10:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/03/ppl-men-026.jpg\" alt=\"scream\" title=\"scream\"></p>\n<p>At the risk of making half of my audience think I’ve gone off the deep end, I’m going to address a topic that I’ve only recently REALLY begun to understand, in part thanks to <a href=\"/softSkills\">Soft Skills</a>.</p>\n<p>When I’ve heard the topic of “Limiting Beliefs” come up, it has almost always been in the context of something along the lines of “What the mind can conceive and believe, it can achieve.”  Which is easy to disprove.  At least it is out of context!  I mean really, if I can conceive and believe myself to be a butterfly, it just isn’t going to happen! However, the opposite is pretty easy to both accept and believe.  And that’s what I want to talk about today.  But even then, it probably isn’t what you are expecting.</p>\n<span id=\"more\"></span>\n\n<p>Typically, when people talk about “Limiting Beliefs”, they are talking about patterns and practices you picked up as a kid that are holding you back now.  And while those may be areas that you need to work on, what I want to talk about today is more micro than that, although they may have roots in our past for various reasons, the Limiting Beliefs I want to talk about today are common across nearly every programmer I talk to.  If you think “Limiting Beliefs” mean something along the lines of, “you are limited because you don’t believe enough,” that is NOT what I have in mind here at all.  In fact, “Limiting Beliefs” are beliefs that we believe TOO strongly and because we hold them too strongly, they limit us.  This is what I mean when I talk about “Limiting Beliefs” even if it is used in another way by someone else.</p>\n<p>Here are some examples specifically related to the craft of programming.</p>\n<h2 id=\"You-Can’t-Practice-TDD\"><a href=\"#You-Can’t-Practice-TDD\" class=\"headerlink\" title=\"You Can’t Practice TDD\"></a>You Can’t Practice TDD</h2><p>As I’ve mentioned in other articles, most programmers I know don’t practice Test Driven Development because they believe they don’t have permission.  And when they ask, they don’t get permission because you’ve transferred the belief that you don’t think it is important.</p>\n<p>If instead, you believed you had permission to do whatever it took to legitimately do your job well, you would learn how to do everything it took to practice TDD well.</p>\n<h2 id=\"Can’t-Create-Branches-in-Version-Control\"><a href=\"#Can’t-Create-Branches-in-Version-Control\" class=\"headerlink\" title=\"Can’t Create Branches in Version Control\"></a>Can’t Create Branches in Version Control</h2><p>I recently ran into a comment on a blog that mention this.  In fact I’ve run into this very issue where I am currently working.  But instead of thinking about what I can’t do, or when I am frustrated by what I can’t do, I first think 1) is this important enough to find a way around? And 2) what CAN I do? In this case, I found it critically important.  My productivity was being hampered because I am adding new features to existing code and, while that code is being tested, I’m converting the code to the last version of the library that we use.  Branching allows me to switch between the two projects easily and it allows me to migrate the current code into the upgrade code so that when the conversion is done, I can merge it down into the main branch and keep going.</p>\n<p>How did I do this?  We use TFS with the old TFVS version control system instead of the Git repository.  But there are at least two projects that exist that allow you to create a bridge between your local code that uses a local GIT repository and the remote TFS repository.  There is at least one project available for subversion that allows you to do the same sort of thing.</p>\n<p>I get my branches and yet I have not caused any disruption to the rest of my team.</p>\n<h2 id=\"Can’t-Use-X-Technology\"><a href=\"#Can’t-Use-X-Technology\" class=\"headerlink\" title=\"Can’t Use X Technology\"></a>Can’t Use X Technology</h2><p>OK.  So, again, ask yourself the same questions.  Is this hampering your productivity?  What CAN you do?</p>\n<h2 id=\"You-Have-to-be-Perfect\"><a href=\"#You-Have-to-be-Perfect\" class=\"headerlink\" title=\"You Have to be Perfect\"></a>You Have to be Perfect</h2><p>I think many of us realize that we can’t be perfect and yet, how do you react when someone finds a bug in your code? I saw a tweet last week that captures the essence of the bug fixing process.</p>\n<ol>\n<li>That can’t happen</li>\n<li>That doesn’t happen on my machine.</li>\n<li>That shouldn’t happen.</li>\n<li>Why does that happen?</li>\n<li>Oh, I see.</li>\n<li>How did that ever work?</li>\n</ol>\n<p>The question I need to ask is, why do we start with “That can’t happen” unless we feel that we need to be perfect.</p>\n<p>In the last year, I’ve finally gotten to the point where my first reaction is, “OK, well, put it in the issue tracker.” (Or if you are doing Agile, “put it in the backlog”).</p>\n<h2 id=\"Can’t-Practice-Agile-x2F-Scrum\"><a href=\"#Can’t-Practice-Agile-x2F-Scrum\" class=\"headerlink\" title=\"Can’t Practice Agile&#x2F;Scrum\"></a>Can’t Practice Agile&#x2F;Scrum</h2><p>Speaking of Agile&#x2F;Scrum.  Are you working at a place that doesn’t practice Agile or Scrum, but you think they should?  What parts of Agile&#x2F;Scrum can you implement in the sphere of influence you have?  So, you can’t form a Scrum team.  But, do you personally put people over processes?  Do you put people first at all?  Most of the <a href=\"//agilemanifesto.org/\">Agile Manifesto</a> can be implemented at a personal level once you understand what it is really about.  Don’t expect anyone to adopt agile in your organization if they don’t see it in you first.</p>\n<h2 id=\"You-Are-an-Introvert\"><a href=\"#You-Are-an-Introvert\" class=\"headerlink\" title=\"You Are an Introvert\"></a>You Are an Introvert</h2><p>How many of us hide behind this one?  We don’t want to deal with people.  We really don’t value people over much of anything.  In fact, we think, “programming would be a great job if it weren’t for the clients.”  I’m reading some books that talk about the impact of confusing behavior with who we are.  OK, so sure, your behavior is that you prefer to avoid loud noises.  You’d rather talk to one or two people at a time.  You process stuff in your head instead of with your mouth.  That’s behavior.  To say, “I am an Introvert” can have the effect of saying, “I hate people” and can become a limiting belief because it will isolate you from the very people you should be helping.  Sorry, you can’t get far as a programmer if you avoid the people part of it.</p>\n<h2 id=\"Restrictions\"><a href=\"#Restrictions\" class=\"headerlink\" title=\"Restrictions\"></a>Restrictions</h2><p>And then there is the general set of restrictions that come with being part of any organization.  We have a few where I work that, on the face of it, seem ridiculous.  I HAVE to take a lunch break even though my lunch consist of 5 sausage links that can be consumed in about 5 minutes.  I can’t start before 7am.  I can’t leave until 3:30.</p>\n<p>But what can I do?  Well, no one said WHEN I had to take the lunch break, so I come in and watch a half hour of <a href=\"/pluralSight\">PluralSight</a> courses every morning.</p>\n<p>I can’t start before 7am.  But I CAN enter the office before then.  I prefer to come earlier because the traffic is lighter if I come in at 6:45.  So, I come in and don’t start working until seven.</p>\n<p>To get my eight hours in, I can’t leave until 3:30 anyhow.  So that is not an issue.  And if I need to leave early occasionally, no one said I couldn’t do that.</p>\n<h2 id=\"The-Key-To-Eliminating-Limiting-Beliefs\"><a href=\"#The-Key-To-Eliminating-Limiting-Beliefs\" class=\"headerlink\" title=\"The Key To Eliminating Limiting Beliefs\"></a>The Key To Eliminating Limiting Beliefs</h2><p>Do you see what I’ve done here?  At every point where I’ve been told or believed I could not do something, I’ve change the question from “What can’t I do?” to “What can I do?”  Can’t locks you down.  It locks you out.  Can frees you. So, what limiting beliefs do you have and how can you overcome them?</p>\n",
            "tags": [
                "tdd",
                "programming",
                "agile",
                "scrum",
                "limiting beliefs"
            ]
        },
        {
            "id": "http://davembush.github.com/being-agile-is-about-the-journey%E2%80%A6/",
            "url": "http://davembush.github.com/being-agile-is-about-the-journey%E2%80%A6/",
            "title": "Being Agile Is About The Journey…",
            "date_published": "2015-02-12T12:00:00.000Z",
            "content_html": "<h1 id=\"…-Not-The-Destination\"><a href=\"#…-Not-The-Destination\" class=\"headerlink\" title=\"… Not The Destination\"></a>… Not The Destination</h1><p><img src=\"/uploads/2015/02/BeingAgile.png\" alt=\"BeingAgile\" title=\"BeingAgile\"></p>\n<p>This post first started as I was discussing my post “<a href=\"/you-arent-doing-scrum-if/\">You Aren’t Doing Scrum If …</a>” with a friend who had read the post and was worried that I might not fit in an organization that wasn’t doing all of Scrum.  I’ve since had other conversations and as I’ve reflected on the topic, I still stand by my original post, because there are some fundamental properties of Scrum that you have to implement in order to follow that methodology.  This is why I called the post “You Aren’t Doing <strong>Scrum</strong> If …” and not “You Aren’t Doing Agile If …”</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Agile-isn’t-Scrum\"><a href=\"#Agile-isn’t-Scrum\" class=\"headerlink\" title=\"Agile isn’t Scrum\"></a>Agile isn’t Scrum</h2><p>But Agile is different.  Agile isn’t a process. Agile is a mindset. So you can call yourself “Agile” without necessarily implementing any particular methodology because “Agile” isn’t about process.  Agile is about the collective state of mind of the team.  The organization as a whole.  Being Agile means that you are open to change.  That you embrace change.  Agile is about being flexible.  About knowing that you don’t know and that you don’t know what you don’t know.  Agile is about adapting.  Ultimately, it is about finding ways of being more productive. In fact, you could implement scrum precisely, which I doubt anyone really does, and not be Agile.</p>\n<h2 id=\"Sacred-Cows\"><a href=\"#Sacred-Cows\" class=\"headerlink\" title=\"Sacred Cows\"></a>Sacred Cows</h2><p>In fact, my experience has been that as I try to move an organization along the sliding scale of being more productive, I will, eventually, find a point of resistance.  The sacred cow of their process.  You can change whatever else you want, and yes, everything else you’ve suggested that we change has proven itself to be a better, more productive, less error prone way of doing what we do.  But, you can’t change our sacred cow. And so far every organization I’ve been in has some sacred cow that we either have to kill or we don’t progress further into being agile. And so we end up hearing comments from people in the industry like, “I don’t think I’ve been in any organization that has been TOTALLY ‘Agile.’” because every organization eventually runs up against some sacred cow on their road toward being agile.</p>\n<h2 id=\"Leadership-Needs-To-Be-Agile\"><a href=\"#Leadership-Needs-To-Be-Agile\" class=\"headerlink\" title=\"Leadership Needs To Be Agile\"></a>Leadership Needs To Be Agile</h2><p>I know of another guy in the industry that postulates that the reason organizations fail as they try to implement agile is because agile is being forced on the organization.  That we need to create an environment where people have opted in to agile.  And to a certain extent, I think he’s right.  But, and I think this is a HUGE but, I think the larger problem is that the leadership has not embraced being agile and so you end up with developers trying to BE agile while the leadership is trying to be predictive.  Funny thing I’ve noticed about most employees, they’ll pretty much do whatever they think will keep the paychecks flowing.  So I don’t think we need opt-in at the worker bee level so much as we need opt-in at the leadership level.  Although I have seen resistance at both levels.</p>\n<h2 id=\"Individuals-Need-To-Be-Agile\"><a href=\"#Individuals-Need-To-Be-Agile\" class=\"headerlink\" title=\"Individuals Need To Be Agile\"></a>Individuals Need To Be Agile</h2><p>Finally, while your organization may not be agile at all. It may not do Scrum, or Kanban.  It may resist all attempts to move in that direction.  This is not excuse for you to not be agile. You should ask yourself periodically, “What can I do that might be more productive than what I am currently doing?”  Because an organization can only be as agile as the people working in that organization and sometimes, all it really takes to move an organization closer to being agile is one individual who is willing to do what he or she does just a little more toward agile than they currently are. What sacred cows have you run into?  What are you doing to be more agile as an individual?  Leave a comment below.</p>\n",
            "tags": [
                "agile",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/technical-debt-is-inevitable/",
            "url": "http://davembush.github.com/technical-debt-is-inevitable/",
            "title": "Technical Debt Is Inevitable",
            "date_published": "2014-10-16T10:00:00.000Z",
            "content_html": "<p>Whoa there Dave.  What are you talking about?  Have you given up the fight? You who have preached the TDD religion.  You who’ve struggled to get organizations to adopt naming conventions, to use version control systems and to use project management software.  The same guy who has implemented continuous integration on his current project?  What’s this world coming to?</p>\n<span id=\"more\"></span>\n\n<p>No. Relax. I haven’t given up.  In fact it is precisely because technical debt is inevitable that we need to implement all of the above.</p>\n<h2 id=\"Danger\"><a href=\"#Danger\" class=\"headerlink\" title=\"Danger\"></a>Danger</h2><p>But there  is a danger in believing that if we were to implement all of the best practices in the book, or that could ever be devised, that technical debt would simply vanish.  And the sooner some of you realize this, the less stressed out you will be.</p>\n<p>You see, no matter how good of a programmer you are today, tomorrow you will be a better programmer.  That is true for all of us.  We are all doing as good of a job as we possibly can today.</p>\n<h2 id=\"A-Story\"><a href=\"#A-Story\" class=\"headerlink\" title=\"A Story\"></a>A Story</h2><p>This reminds me of a story I heard once.</p>\n<p>It seems there was this programmer who had to make a change to some code and, like we all do, the first thing he did was to try to wrap his head around the code he was looking at.  A few minutes into this common exercise, he starts exclaiming:</p>\n<ul>\n<li>Who wrote this code?</li>\n<li>This is the worst code I’ve ever seen.</li>\n<li>The guy who wrote this can’t even really call himself a programmer!</li>\n</ul>\n<p>And then, it got unusually quite in his cubicle.</p>\n<p>His friend in the next cube calls over the wall, “Hey John, you OK?”</p>\n<p>And John responds, “It’s my code.”</p>\n<p>Now, the reason this is a funny story… well, it is a funny story for me anyhow… is because this happens to us all of the time.</p>\n<p>I think I spent the first 5 years of my career looking at code I wrote six months ago and thinking, “What was I thinking when I wrote this?”</p>\n<p>Even today, 26 years in, I have code I wrote six months or more ago that I know I need to rewrite.  The only reason I haven’t yet is because I want to make sure I have a full test harness around it before I tweak it.</p>\n<h2 id=\"Here’s-the-point\"><a href=\"#Here’s-the-point\" class=\"headerlink\" title=\"Here’s the point.\"></a>Here’s the point.</h2><p>We are all getting better at what we do.  What we would do today isn’t what we would have done six months ago.  The person who wrote the code you are looking at was doing the best he could at the time.</p>\n<p>Therefore, we should just plan on code being “wrong.”</p>\n<p>This has two explicit implications to how you relate to your code and your co-workers.</p>\n<h3 id=\"Don’t-be-surprised-by-bad-code\"><a href=\"#Don’t-be-surprised-by-bad-code\" class=\"headerlink\" title=\"Don’t be surprised by bad code\"></a>Don’t be surprised by bad code</h3><p>First, you should not be surprised when you find bad code.  You should instead be shocked when you find well written code.  Since even you write bad code, you should be gracious when you find bad code that isn’t yours.  You don’t want to be the guy in the story  I just told.  You might have done the same thing today if you knew only what the person who wrote the code you are looking at knew at the time the code was written.</p>\n<h3 id=\"You-should-expect-that-your-code-will-be-broken-in-some-way\"><a href=\"#You-should-expect-that-your-code-will-be-broken-in-some-way\" class=\"headerlink\" title=\"You should expect that your code will be broken in some way.\"></a>You should expect that your code will be broken in some way.</h3><p>This has been probably the hardest thing for me to get control of.  I have, historically, been one to deny that my code has a bug.  I’ve taken it as a personal insult, or an assault on my character when someone finds a bug in my code. </p>\n<p>Until recently.</p>\n<p>Once I was able to internalize the fact that the person reporting the bug was not upset, that the only person who expected me to be perfect was me, and that being wrong was part of being human, I was able to calm down a bit.</p>\n<p>You see, none of us are all knowing.  Most of us program for what the code is supposed to do and don’t think about what it shouldn’t do (which is where most of the bugs occur).  The spoken&#x2F;written language is an imprecise communicator, even if you develop a dictionary for your project.  You’ll never get all of your terms defined.  You just don’t know what you don’t know.  And therefore there will be bugs.</p>\n<p>Maybe you’ll think, “I should have known that!”  Well, yes, maybe you SHOULD have.  But the fact is, you didn’t.</p>\n<p>When before I used to deny that the bug could even exist, my reaction now is, “Hmmm, wonder what’s going on there.  OK, well, put it in the issue tracker and I’ll get it fixed.”</p>\n<p>No drama.  No conflict.  No denial.  No blame.  Just deal with the issue.</p>\n<h2 id=\"This-is-what-it-means-to-be-Agile\"><a href=\"#This-is-what-it-means-to-be-Agile\" class=\"headerlink\" title=\"This is what it means to be Agile\"></a>This is what it means to be Agile</h2><p>And you see, this is the beauty of the Agile methodology.  Agile assumes we aren’t going to get it right the first time.  It assumes humans are poor communicators.  It assumes that programmers aren’t going to understand the problem the first time they try to come up with a solution.  It assumes technical debt is inevitable.</p>\n<p>Isn’t it time that you do too? Or am I the only one who has suffered with this problem?</p>\n",
            "tags": [
                "agile",
                "scrum",
                "technical debt"
            ]
        },
        {
            "id": "http://davembush.github.com/%E2%80%9Cdebbie-done%E2%80%9D/",
            "url": "http://davembush.github.com/%E2%80%9Cdebbie-done%E2%80%9D/",
            "title": "“Debbie-Done”",
            "date_published": "2014-03-04T10:38:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/02/88Tr.png\" alt=\"88Tr\" title=\"88Tr\"></p>\n<p>A long long time ago, in what seems now like another world, I worked for a company as a <a href=\"//en.wikipedia.org/wiki/Clipper_(programming_language)\">Clipper programmer</a>.  While I was there I heard this story about a lady named Debbie.</p>\n<p>I was told that Debbie was a programmer who used to work for this company.  Debbie was a lazy programmer.  She worked harder at avoiding work than if she just did the job she was supposed to do.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"The-ultimate-lazy-programmer\"><a href=\"#The-ultimate-lazy-programmer\" class=\"headerlink\" title=\"The ultimate lazy programmer\"></a>The ultimate lazy programmer</h2><p>For example.  Once my boss had stopped by her desk to see how she was progressing on a report she was supposed to be writing:</p>\n<p>Debbie: Oh, that’s done.  Here.  Take a look.</p>\n<p>The boss looked it over and found an error.  Some of the numbers didn’t match up.</p>\n<p>Debbie: Oh, I know what that is.  I can get that fixed right away.</p>\n<p>Which she did.  At least that’s what she made everyone believe.</p>\n<p>After she left (shortly after this) they found out that she hadn’t even connected to a database to create that report.  The whole report was hard coded.  Every time you ran it, it gave you the same numbers.</p>\n<h2 id=\"“Debbie-Done”\"><a href=\"#“Debbie-Done”\" class=\"headerlink\" title=\"“Debbie-Done”\"></a>“Debbie-Done”</h2><p>The one thing I was told that sticks in my mind the most is that Debbie considered a project “done” if it compiled in linked.  She almost never ran the code.  Or if she did, she certainly didn’t run enough of it, or run it more than to make sure it didn’t crash.  Anyhow, the perception she left is that she only compiled and linked the code.  Today, we’d say all she did was build the project or solution.</p>\n<p>But recently, I’ve discovered that many programmers work at the “Debbie-Done” level more than we’d like to admit.</p>\n<p>I’ve always thought that programmers wrote code like I do:</p>\n<ul>\n<li>Write a bit of code. </li>\n<li>Build the code.</li>\n<li>Run the code to see if that change works as expected. </li>\n<li>Write a bit more code. </li>\n<li>Build the code.</li>\n<li>Run the code to see if that change works as expected. </li>\n<li>Rinse, lather, repeat.</li>\n</ul>\n<p>But what I’m discovering is that MANY programmers do not program that way at all.  No, many of them look like some version of “Debbie-Done” programming:</p>\n<ul>\n<li>Write some code. </li>\n<li>Build the project to make sure it will build</li>\n<li>Write some more code</li>\n<li>Build the project</li>\n<li>Rinse, lather, repeat</li>\n<li>Run the code and “test” all of the changes at once.</li>\n</ul>\n<p>The problem with this method is that no one can remember all of the changes they make so, in the end, the code I write tends to be more completely tested than the code that was tested in bulk.  The only difference between this method of development and “Debbie-Done” is the degree of completeness with which each developer is able “test” their code.</p>\n<h2 id=\"Avoid-“Debbie-Done”-with-Test-First-Development\"><a href=\"#Avoid-“Debbie-Done”-with-Test-First-Development\" class=\"headerlink\" title=\"Avoid “Debbie-Done” with Test First Development\"></a>Avoid “Debbie-Done” with Test First Development</h2><p>It is no wonder that many programmers I talk to think that test driven development takes too much time.  Compared to how they are programming, it does.</p>\n<p>But think about this.  If you were to code like I do, suddenly writing test for every change you make suddenly makes sense because instead of you running the application and getting to the place that will trigger your code and observing if it will work or not, you can write a test for just the piece of code you are working on and run that each time you want to verify if it is working or not.  Yes, initially, this will take more time.  But over the life of the program, and I would say even over the time span that it takes to initially write the code, writing at least the Unit Test as you are writing the features will actually save you time.  Not only that, you will end up with test you can repeat every time the code is changed.</p>\n<p>Even my method of “code, build, test, code, build, test” is “Debbie-Done” compared to writing test for each change as you make the change.</p>\n",
            "tags": [
                "tdd",
                "programming",
                "agile",
                "testing"
            ]
        },
        {
            "id": "http://davembush.github.com/test-driven-specifications/",
            "url": "http://davembush.github.com/test-driven-specifications/",
            "title": "Test Driven Specifications",
            "date_published": "2014-02-25T08:44:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/02/spider.jpg\" alt=\"spider\" title=\"spider\">Several years ago, long before the community was actively talking about Test Driven Development, I worked for a short time at a company as a “bug fixer.”  That was my role.  They had hired me because they had some software that was “basically done” but “had some issues.”  It should only take a few weeks.</p>\n<p>The first thing they needed me to fix was that the website was supposed to send out email.  It turns out it was a configuration problem.  But they were so impressed (“the last guy we had in here spent two weeks on that problem and still hadn’t solved the problem.”) that they gave me more and more bugs.</p>\n<h2 id=\"This-Is-The-Job-That-Never-Ends\"><a href=\"#This-Is-The-Job-That-Never-Ends\" class=\"headerlink\" title=\"This Is The Job That Never Ends\"></a>This Is The Job That Never Ends</h2><span id=\"more\"></span>\n\n<p>The gig that was supposed to be a couple of weeks long was quickly turning into a perpetual job.  Soon I learned that what I was working with was a system that had a lot of bugs, but no one was willing to admit that.  Eventually, frustrated by the fact that this system seemed to have a new bug every day, I asked for the specs so that I could create a test plan.  That’s when I found out the worse news of all about this system.</p>\n<h2 id=\"Lost-Specifications\"><a href=\"#Lost-Specifications\" class=\"headerlink\" title=\"Lost Specifications\"></a>Lost Specifications</h2><p>They had lost the specs.  Not only had they lost the specs, but they were unwilling to admit this to the client and instead they were relying on the process of fixing the bugs to eventually squash all  the bugs so they could end up with a stable system.</p>\n<p>Since I was not yet familiar with the concepts of unit testing or Test Driven Development, I accepted this as the best we could do.  Hey!  At least I was getting paid well.</p>\n<p>Oh, but the story gets worse.</p>\n<h2 id=\"The-Plot-Thickens\"><a href=\"#The-Plot-Thickens\" class=\"headerlink\" title=\"The Plot Thickens\"></a>The Plot Thickens</h2><p>About three months into this gig, the manager of my project went on vacation which left the project in HIS manager’s hands.  That’s when the poop hit the fan.</p>\n<p>The Oracle consultant that was working with me and I were called into the office.</p>\n<p>“Why does this system still have bugs?!!”  Oh, he was angry.  That should be all bold and all caps and all underlined.</p>\n<p>Well sir, several weeks ago I asked for the requirements document so that I could write a test plan and I was told the requirements were lost.  If we can’t write a test plan, we never will be able to ensure that the system is working the way that it should.</p>\n<p>“I want you to write a test plan.”</p>\n<p>To which I repeated my need for a requirements document.</p>\n<p>We went back and forth with him insisting that I write a test plan and me stating that it could not be done until I finally said, “I think I’ve done all I can do here.”  Walked out of the office, packed up my stuff, went home, and immediately called my recruiter to make sure he got MY version of what happened first.</p>\n<p>But, it didn’t have to end like that.</p>\n<h2 id=\"A-Better-Way\"><a href=\"#A-Better-Way\" class=\"headerlink\" title=\"A Better Way\"></a>A Better Way</h2><p>Had I known about test driven development, every time a new bug came in, I could have written a new test, even if it was only unit test and not acceptance test, every time a new bug came in.  Eventually, I would have created not only the test plan, but I would have created the specification, or at least the parts that tended to break, and we would have ended up with a stable system like they thought they were going to get.</p>\n",
            "tags": [
                "tdd",
                "agile",
                "test driven development",
                "testing"
            ]
        }
    ]
}