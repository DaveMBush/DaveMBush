{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"scrum\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "url": "http://davembush.github.com/you-aren%E2%80%99t-doing-scrum-if%E2%80%A6/",
            "title": "You Aren’t Doing Scrum If…",
            "date_published": "2020-06-20T11:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/01/YouArentDoingScrumIf.png\" alt=\"You Aren&#39;t Doing Scrum If...\" title=\"YouArentDoingScrumIf\">I’ve been frustrated lately by the flippant use of the words “Scrum” and “Agile” in our industry. </p>\n<p>Actually, I’m STILL frustrated.  I originally wrote this article January 2015.  Not only is it still true.  It is <strong>more</strong> true.</p>\n<p>Our industry has been treating Scrum and Agile as “buzzwords that mean nothing.” These words get slapped onto job requirements like the typical requirements we’ve all seen.</p>\n<ul>\n<li>Must be able to communicate</li>\n<li>Must be able to work in a team environment</li>\n<li>Must be able to work under pressure</li>\n<li>Must be able to work in an Agile environment</li>\n</ul>\n<p>What’s really funny is when I see</p>\n<ul>\n<li>Meet tight deadline</li>\n<li>Expert in Agile</li>\n</ul>\n<p>together in the same job request.</p>\n<p>And even if it doesn’t show up in the job description.  Once you get into the organization, you find out they are no different than any other organization.  All those promises about running “Agile” or “Scrum” as a well of figuring out how long a project will take fly right out the window as soon as a manager wants something done by a specific date.</p>\n<p>If management ain’t Agile, ain’t no one Agile.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Really-Do-you-know-what-you’re-saying\"><a href=\"#Really-Do-you-know-what-you’re-saying\" class=\"headerlink\" title=\"Really?  Do you know what you’re saying?!\"></a>Really?  Do you know what you’re saying?!</h2><p>Many people even use the words “Agile” and “Scrum” interchangeably.  Most because they really do think they are the same thing.</p>\n<p>I’m finding that what most people mean when they use these words is, either, “we work really fast”, “we work iteratively”, or “we don’t really have a plan.”</p>\n<h2 id=\"So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\"><a href=\"#So-the-first-thing-we-need-to-clarify-is-what-is-Scrum-and-what-is-Agile\" class=\"headerlink\" title=\"So, the first thing we need to clarify is, what is Scrum and what is Agile.\"></a>So, the first thing we need to clarify is, what is Scrum and what is Agile.</h2><p>Agile is a set of values.  It is what we believe about software development specifically and, I would argue, also impacts how we view life.  You might have other beliefs that live on top of Agile, but these beliefs will have an impact on how you manage the software development process specifically and your organization in general. Check out the <a href=\"//www.agilemanifesto.org/\">Agile Manifesto</a>.  This is what it means to be Agile.</p>\n<p>In contrast to this, Scrum is a methodology that helps an organization BE agile.</p>\n<p>Now here is where things get tricky for some people.  They read in the manifesto that we should value “Individuals and interactions over processes and tools” and think that they can make Scrum be whatever they want it to be because, they would say, “we don’t value processes and tools”.</p>\n<p>But the Agile Manifesto never says that.  It says we value individuals and interactions MORE than, not INSTEAD of, processes and tools.</p>\n<p>So, yes, you can adapt and modify Scrum to fit your situation.  You may need to.  But there are some specific elements of Scrum that you simply can’t ignore because to do so would mean either that you are no longer Agile or you are not implementing Scrum.</p>\n<h2 id=\"And-so-you-aren’t-doing-Scrum-if\"><a href=\"#And-so-you-aren’t-doing-Scrum-if\" class=\"headerlink\" title=\"And so, you aren’t doing Scrum if:\"></a>And so, you aren’t doing Scrum if:</h2><h4 id=\"You-have-deadlines-especially-if-you-have-“tight-deadlines”\"><a href=\"#You-have-deadlines-especially-if-you-have-“tight-deadlines”\" class=\"headerlink\" title=\"You have deadlines, especially if you have “tight deadlines”\"></a>You have deadlines, especially if you have “tight deadlines”</h4><p>“Now wait a minute,” you say, “I heard that Scrum has these things called ‘Sprints’ that are a fixed length.  Don’t those qualify as ‘deadlines?’” Well, yes and no.  You see, I don’t think what Scrum treats as a “deadline” is what most managers mean by “deadline.” At the end of the day you’ll get to the end of the Sprint and you’ll show what you’ve got.  The GOAL is to have a complete set of code that you wouldn’t be embarrassed to show to another programmer.  You should have only selected what could reasonably get done in the timeframe of a sprint so that all that needs to be done to complete the task could get done.</p>\n<p>One of the confusions is that somewhere along the line we were told that at the end of each sprint we should have a “shippable unit of software” and we’ve confused that with “a viably marketable product”  All that shippable means is, “if the customer thinks what you’ve completed so far is something they can use, you would not respond with, ‘but it still needs…’” This ties in with the other way you know you aren’t doing Scrum</p>\n<h4 id=\"You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\"><a href=\"#You-aren’t-doing-scrum-if-you-don’t-have-a-“definition-of-done-”\" class=\"headerlink\" title=\"You aren’t doing scrum if you don’t have a “definition of done.”\"></a>You aren’t doing scrum if you don’t have a “definition of done.”</h4><p>And once again, there is confusion.  To most people, the “definition of done” is “I can ship this code.”  But that may not be appropriate.  You’re definition of done during your first sprint may be “a set of stories that begin to describe the application we are trying to build.”  As you are learning scrum, you’re definition of done may be as simple as, “all of the code we’ve written so far have Unit Test, appropriate documentation, and we’ve learned something of how long a story point will take our team.” Definition of done doesn’t always have to mean “I’ve written code I can ship.”</p>\n<h4 id=\"You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\"><a href=\"#You-aren’t-doing-Scrum-if-you-HAVE-to-work-more-than-40-hours-a-week\" class=\"headerlink\" title=\"You aren’t doing Scrum if you HAVE to work more than 40 hours a week.\"></a>You aren’t doing Scrum if you HAVE to work more than 40 hours a week.</h4><p>One of the benefits of Scrum is that it allows us to pace ourselves.  We no longer scramble to get stuff done.  We work consistently toward the goal.  But it isn’t a race.</p>\n<p>I have a rule.  If I tell you something will be done by a set time, I’ll bust my butt to make that happen.  If you tell me when it will be done, good luck with that.</p>\n<p>Of course, even when I tell someone when something will be done, I pad the estimate with enough hours that I never work more than 45 hours a week.  There is one day, in the 26 years I’ve been doing this where I worked longer than 12 hours.</p>\n<p>In fact, I had one manager who called me into his office and asked me to come in on Saturdays.  I was already working 10 hour days 5 days a week!  Talk about getting blood out of a turnip! I looked him straight in the eye and said, “I have 50 hours a week in me.  I’d prefer to give them to you Monday through Friday.  But if you want me to come in on Saturday, I can do that, but you are still only going to get 50 hours a week.” Needless to say, I never came in on Saturday.</p>\n<h2 id=\"I-could-go-on…\"><a href=\"#I-could-go-on…\" class=\"headerlink\" title=\"I could go on…\"></a>I could go on…</h2><p>But I won’t</p>\n",
            "tags": [
                "agile",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "url": "http://davembush.github.com/8-reasons-johnny-does-not-write-bug-free-code/",
            "title": "8 Reasons Johnny Does Not Write Bug Free Code",
            "date_published": "2016-09-20T10:30:00.000Z",
            "content_html": "<p>There have been a number of things that have occurred over the last week that have prompted this particular post.  And for anyone I work with, this is not an indictment of our work place so much as it is an indictment of our industry.  PLEASE don’t take this personally.</p>\n<p>Some of those reasons will show up in this article.  But the question we need to examine today is why is it so hard to write bug free code.  And I’m not even talking about perfection.  Why is it that we miss the simple stuff?  The stuff that once it is found, we think, “how could we have missed that?!”.  I’m perfectly aware that all code has bugs some just haven’t been found yet.  I’m also aware that no matter how hard I try, the stupid bugs always make their way past my desk.</p>\n<figure>![](/uploads/2016/09/image-1.png \"8 Reasons Johnny Does Not Write Bug Free Code\")<figcaption>Photo credit: [~Pawsitive~Candie_N](//www.flickr.com/photos/scjn/3450910519/) via [Visualhunt](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"No-Training\"><a href=\"#No-Training\" class=\"headerlink\" title=\"No Training\"></a>No Training</h2><p>Certainly not the only reason.  But at the same time I think this is a core reason.  Our industry really sucks when it comes to teaching computer science.  So much so, that I’ve written articles about how, for the most part, you don’t need a college education to become a programmer.  Maybe if we taught what programmers don’t already know how to do, a college education would be valuable.</p>\n<p>But what do we do instead?  We teach programmers how to program.</p>\n<p>Dumb! I think back to my education.  Here’s a basic summary of what I learned:</p>\n<ol>\n<li>COBOL, dBase III, JCS, CICS syntax.</li>\n<li>Break your code into functions</li>\n<li>A bit on how to do requirements analysis.</li>\n</ol>\n<p>Guess what?  I could have learned all of that on my own.  How do I know that?  Because I had already taught myself, Basic and C before.  I taught myself every language I’ve learned since.  I was already writing structured code, and still do.  And how we gather requirements has changed and somehow I managed to learn that on my own.  Programming is a learning profession.  It is one of the things that makes it attractive to me.</p>\n<p>But what didn’t I learn?  At no point did anyone ever teach me how to break my own code.  And while Test Driven Development wasn’t a thing when I was going to school.  I doubt they are teaching it today.  (Let me know if your school did or is.)</p>\n<h2 id=\"Happy-Path-Specs\"><a href=\"#Happy-Path-Specs\" class=\"headerlink\" title=\"Happy Path Specs\"></a>Happy Path Specs</h2><p>So, the programmers have no training.  But it isn’t just a programmer problem.</p>\n<p>When is the last time you got a specification from whoever creates them in your organization that had any more than a happy path set of requirements?  But, certainly there are things the system should not do.  I recently had to go asking for required fields and maximum field lengths in an application I was working on.  And that’s the simple stuff.</p>\n<h2 id=\"Not-My-Job\"><a href=\"#Not-My-Job\" class=\"headerlink\" title=\"Not My Job\"></a>Not My Job</h2><p>If you have a QA department, you might be tempted to leave testing to QA.  My personal goal is to make sure QA doesn’t find anything.  At least, not something really obvious.</p>\n<p>But I know that some programmers get sloppy about testing their code if they know the safety net of QA exist.</p>\n<p>There is also the problem of QA believing they are the only ones who test.  Strange, but true.  When QA found out I was writing unit test for a pretty complex piece of logic, I was asked, “Then what will be left for me to do?!”  Strange but true.</p>\n<p>But what if we started working as teams?  For example, what if I could get QA to help me develop my test plan?  What if developing software was a WE activity instead of several silo developers each doing their own thing?</p>\n<h2 id=\"Batch-Programming\"><a href=\"#Batch-Programming\" class=\"headerlink\" title=\"Batch Programming\"></a>Batch Programming</h2><p>This is one I really don’t understand.  But I know programmers who will write code for hours prior to running it.  Even if you did remember everything you coded, how can you possibly know where a bug is located if you wait that long?  You should be running your code every time you have something different that can be run so that you know what change caused a problem.  And don’t tell me you test every possible condition.  I know you don’t.</p>\n<p>Programmers who program like this are “Debbie Done” programmers.</p>\n<p>Why “Debbie Done”? There is this story about a programmer who used to work at one of the companies I worked at in the past.  She considered code done if it compiled and linked.</p>\n<p>I’m not as good at testing as I would like (yet) and I’m always embarrassed when someone finds a problem with my code.  So, I was shocked one day when I found out that a project manager wanted to give me some work because my code “always works.”  I knew that wasn’t true.  But when I reflected on what he was saying I realized that the difference in how I code and the other programmers he was comparing me to is that I write for a few minutes and then make sure that works before I continue on.</p>\n<h2 id=\"We-Don’t-Plan-to-Test\"><a href=\"#We-Don’t-Plan-to-Test\" class=\"headerlink\" title=\"We Don’t Plan to Test\"></a>We Don’t Plan to Test</h2><p>Ah.  And here we get a little closer to the truth.</p>\n<p>What do I mean by planning to test? For any spec you are working on, you should have, written out or coded, a repeatable set of steps that ensures that your code does what it should and doesn’t do what it shouldn’t.  This is what test driven development attempts to steer us toward.  I’m not going to go off on a rant about TDD again here.  But I will tell you that either having a written out test plan prior to coding enables me to ensure that my code does what the people who gave me the specification think it should.  It also forces me to think about ways I might break the code.  I know my code is delivered with less bugs because of this process.  Hopefully, I’ll get better at thinking of how to break my own code.</p>\n<p>Having a plan helps with the Debbie Done programmer as well as people who code more like me.</p>\n<p>Even though I code&#x2F;test incrementally, I still only test the code right after I’ve written it.  Once I think it is working, I don’t go back, even though something else I’ve written may have changed how the code is working.  Having repeatable tests has save me several times.</p>\n<h2 id=\"We-Don’t-Know-what-we-Don’t-Know\"><a href=\"#We-Don’t-Know-what-we-Don’t-Know\" class=\"headerlink\" title=\"We Don’t Know what we Don’t Know\"></a>We Don’t Know what we Don’t Know</h2><p>Even if we do everything right, we are still going to miss stuff.  One person can’t possibly figure out all that might go wrong.  It is how we deal with the problems once they are revealed that becomes the issue.  This is where we would, ideally, have the team come up with the test scenarios.</p>\n<h2 id=\"Shame-Driven-Development\"><a href=\"#Shame-Driven-Development\" class=\"headerlink\" title=\"Shame Driven Development\"></a>Shame Driven Development</h2><p>I actually heard a project manager say, “Shame on the developer if QA finds bugs.” Really?!  What about “Shame on the BA for not including that item in the requirements.”?  What about “Shame on the product owner for not mentioning it.”? Or what about no shame at all? While shame is a powerful motivator in the short term, it is a sure way to make sure your developers leave.</p>\n<p>That you only retain highly dysfunctional programmers.  Or that you can only retain programmers who can’t really code.</p>\n<p>Shame based development can only lead to even more bugs.  Not fewer.</p>\n<p>At some point I should probably write about the dangers of a shame based culture.   If your organization is using shame to manage personnel.  Get out!</p>\n<h2 id=\"Long-Hours\"><a href=\"#Long-Hours\" class=\"headerlink\" title=\"Long Hours\"></a>Long Hours</h2><p>Another way you can kill the overall effectiveness of your team is to make sure everyone works more than 45 hours a week for months or years at a time.  One of two things will happen, if not both.</p>\n<p>The code will suffer.  Want to introduce more bugs?  Keep everyone working overtime.  A week here or there is a different story.</p>\n<p>If the code doesn’t suffer, then you are likely to find a lot more socialization, social media activities, and just plain goofing off occurring.  People just can’t work that many hours.  Just because someone is at work for 10 hours doesn’t mean they are working 10 hours.  But hours are easy to measure, so this terrible practice continues.</p>\n<h2 id=\"We-Can’t-Fix-Everything\"><a href=\"#We-Can’t-Fix-Everything\" class=\"headerlink\" title=\"We Can’t Fix Everything\"></a>We Can’t Fix Everything</h2><p>I’m in a unique position in that I’m currently functioning as a Scrum coach.  This allows me to influence all the areas I’ve discussed.  As programmers, you can only influence your own stuff.  So, my recommendation to you is to concentrate on what you have control over.  Create a test plan prior to writing code.  Once you’ve learned how to do that, work on learning how to code those test so you don’t have to run them manually over and over again.  Do this slowly.  Maybe start with just one test.  Squeeze it into the cracks of your regular work.  Learning to test and learning to code test takes time, but it will make you a better programmer and will ultimately make you a more reliable and faster programmer.  Someday you might just hear that they want to give you an important job because “Johnny’s code always works.”</p>\n",
            "tags": [
                "tdd",
                "code",
                "agile",
                "scrum",
                "bug"
            ]
        },
        {
            "id": "http://davembush.github.com/3-reasons-agile-will-not-succeed/",
            "url": "http://davembush.github.com/3-reasons-agile-will-not-succeed/",
            "title": "3 Reasons Agile Will Not Succeed",
            "date_published": "2016-06-09T10:30:00.000Z",
            "content_html": "<p>I’ve written about <a href=\"/categories/Agile/\">Agile</a> and <a href=\"/tags/scrum/\">Scrum</a> before and most of my regular readers know that I am a huge fan.  But recently I am starting to believe the Agile movement is doomed.  In fact, the most common response to my enthusiasm for Agile and Scrum is, “Yeah, we tried that once and it was a complete failure.”  Which seems odd to me because in every instance where I’ve been able to implement it, it has worked beautifully.  </p>\n<p>So why would I say Agile Will Not Succeed?</p>\n<p>The buzz around Agile has become so loud that Agile has moved from strictly a software development thing, to all corners of the business world.  And yet, as much as I believe Agile is the right way to develop software, as a movement, it is doomed for failure. </p>\n<p>Why?</p>\n<figure>![](/uploads/2016/06/image.png \"3 Reasons Agile Will Not Succeed\")<figcaption>Photo credit: [Tim Evanson](//www.flickr.com/photos/timevanson/9325191852/) via [VisualHunt](//visualhunt.com) / [CC BY-SA](//creativecommons.org/licenses/by-sa/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Reminder-Agile-Isn’t-a-Method\"><a href=\"#Reminder-Agile-Isn’t-a-Method\" class=\"headerlink\" title=\"Reminder - Agile Isn’t a Method\"></a>Reminder - Agile Isn’t a Method</h2><p>This is the surest sign that a movement is struggling.  It has become so popular that people are using it without knowing anything of what they are doing.  The surest sign you’ve walked into an organization where Agile is doomed is if they say something along the lines of “We do Agile.”</p>\n<p>Why is this a clear sign? </p>\n<p>Because you can’t DO Agile.  You can only BE Agile.  <a href=\"//www.agilemanifesto.org/\">Read the Agile Manifesto</a>.  There is nothing there about how to implement Agile.  It simply isn’t a methodology.  So, when an organization says to me they are “Doing Agile” it tells me right away that they have no idea what it means to be Agile.</p>\n<h2 id=\"‘Doing-Agile’-for-the-Wrong-Reasons\"><a href=\"#‘Doing-Agile’-for-the-Wrong-Reasons\" class=\"headerlink\" title=\"‘Doing Agile’ for the Wrong Reasons\"></a>‘Doing Agile’ for the Wrong Reasons</h2><p>One of the outcomes of implementing an Agile process is that code tends to get developed faster.  Unfortunately, this has become the main selling point of moving toward Agile.  I get it, every shop I’ve worked in has been under some sort of development pressure to get stuff done.  So it is easy to look at faster delivery as the main reason why you would use an Agile method. </p>\n<p>But, speed is a side effect.  In fact, it is only a long term side effect.  Initially, as you move toward being Agile, you will probably end up being slower.  You might have to lay people off because they only know how to work on their own while true Agile requires teamwork.  The more mature your team, the harder it will be to switch.</p>\n<p>So, if you shouldn’t move toward Agile because of speed, why should you? Well, two of the main reasons for me are: visibility, flexibility, and predictability.</p>\n<p>I was once told the story of how plumbers plumb a new house.  The first day they come in and hang all the pipes in hangers.  By the time the owner comes by that evening, everything is hung and it looks like they are practically done.  They now have two weeks to get it all soldered together before the owner comes by again. This is why most Agile methods require short sprints.  The more you can show the customer the progress you are making, the less nervous they will get and the more likely you are to be left alone to do your job.  However, it will take time because the customer has been burned too often in the past, so it may be a while before they learn to wait for the sprint reviews.</p>\n<p>But there is an added advantage to being visible that is a huge win for everyone.  By letting the customer see the progress you are making, he is able to make tweaks along the way.  I’ve learned over the years that no one really knows what they want until they see it.  But letting them see it often and make tweaks along the way saves me from having to do a complete rewrite when I am “done.” And agile adds predictability that isn’t available using older methods.  It doesn’t let you say up front how long a project will take.  Estimates are still rather futile.  You’ll never know less about a project than the first day you try to provide an estimate.  But, as you progress, you will know roughly how much effort the remaining project will take and how much time that much effort will take on average.  The project becomes predictable using statistics generated by the project.</p>\n<h2 id=\"You-Aren’t-Fully-Committed\"><a href=\"#You-Aren’t-Fully-Committed\" class=\"headerlink\" title=\"You Aren’t Fully Committed\"></a>You Aren’t Fully Committed</h2><p>In my last interview, I was asked if I had any experience with “Agile.”  I really need to learn to qualify that question.  I answered, “<a href=\"//www.scrumalliance.org/community/profile/dbush2\">I have my Scrum Master certification</a>, but I’ve yet to work in a truly Agile environment.”  And yet, I have worked in environments that call themselves “Agile”  But these are all environments that Carl and Richard over at <a href=\"//dotnetrocks.com/\">DotNetRocks</a> call “Scrum But…”.  “Agile But…”?  And at another place, we called it “Scrummerfall”.  The idea is the same, rather than doing either Scrum or Kanban, they take the parts they’ve heard about that they like and merge them into what they are currently doing.</p>\n<p>Of course, they weren’t fully committed to the process they were using either, so it shouldn’t work any worse.  But it often does.</p>\n<p>One of the most obvious points of failure is with project management.  I’ve seen it all.  Scrum masters who are still trying to function as project managers and organizations that have skipped the scrum master role and left the project managers.  Stand ups that last an hour.</p>\n<p>Or how about this one.  Teams trying to estimate stories instead of task.</p>\n<p>I went on one interview that had the following bullets in the job request I was sent:</p>\n<ul>\n<li>Must be able to work in an Agile environment</li>\n</ul>\n<p>followed three points later by</p>\n<ul>\n<li>Must be able to work under tight deadlines.</li>\n</ul>\n<p>Talk about an oxymoron! When I asked what “Agile” meant to him (the owner of the company) he said, “Oh, that just means we do iterative development.” Here’s the deal.  If you are going to say you are going to implement Agile, at least learn enough about it to know what the word means!  You might decide it isn’t for you.  That’s fine.  Doing something simply because it is the “In” thing to do is never a good reason to do something.</p>\n<h2 id=\"Management-Has-No-Clue\"><a href=\"#Management-Has-No-Clue\" class=\"headerlink\" title=\"Management Has No Clue\"></a>Management Has No Clue</h2><p>In my current job, I was told that some boss several levels up who I’ve still not met has declared our project to be a “Waterfall project” because “we already know what this is supposed to do.” As soon as I heard that, I said, “Someone doesn’t know what Agile is.” Here is why this sounds right.  The project I am working on is a rewrite from a very old platform to a web application.  In principle, from that definition, it sounds like a known entity.  However, simply because the GUI has changed there are things that were done on the old platform that make no sense on the new platform.</p>\n<p>But it gets worse.  The application is being expanded to include other business units with additional requirements.  So, we only partially know all this is supposed to do.</p>\n<p>If we were using true Waterfall, we would have to design the whole thing up front.  This project is due in a little less than a year.  Tell me what on the web doesn’t change in a year?</p>\n<h2 id=\"Agile-Will-Not-Succeed\"><a href=\"#Agile-Will-Not-Succeed\" class=\"headerlink\" title=\"Agile Will Not Succeed\"></a>Agile Will Not Succeed</h2><p>So, what’s the point?  People love their perceptions.  Not reality.  What Agile set out to do was nobel, and for the most part, right.  But people are lazy.  They get a snippet of the truth here, a snippet of the truth there, ignore a snippet, paste in a snippet (here a snippet, there a snippet, everywhere a snip of snippet).  And that becomes their truth, while not being THE truth.  We do it with everything we believe.  Agile has reached that point of group think that it can now be classified as “religion.”  It now has so much group think weight that I’m not sure even those who started the movement can clearly articulate what it IS anymore.</p>\n",
            "tags": [
                "agile",
                "failure",
                "kanban",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/code-comments-agile-programming/",
            "url": "http://davembush.github.com/code-comments-agile-programming/",
            "title": "Code Comments & Agile Programming",
            "date_published": "2015-05-14T10:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/05/PEOP0067.png\" alt=\"PEOP0067\" title=\"PEOP0067\"></p>\n<p>A long time ago, in a galaxy far far away, we were forced to name variables and methods with very short names.  When I started my career, I was programming Clipper and C.  Clipper was a dBase compiler, so it only had 10 characters available for variable names.  You could write longer variable names if you wanted, but only the first 10 mattered.  I think at the time, C gave us 32 characters.  But now, we aren’t so limited.  And so the argument goes, if you use long variable names,  you shouldn’t need to comment your code.  I’ve argued as much.</p>\n<p>Of course every time you bring this subject up, you will inevitably find someone who will say, “But don’t we need comments to at least explain what the code was supposed to do?  After all, code is generally hard to read.”  Well, yes I guess it is if you are new to the language.  But should every foreign movie have subtitles?  Would you want native language movies to have subtitles because other people in the room might not understand it?  Must we dumb everything down to the lowest common denominator?  If so, where will it stop?</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Sometimes-Comments-Are-Needed\"><a href=\"#Sometimes-Comments-Are-Needed\" class=\"headerlink\" title=\"Sometimes Comments Are Needed\"></a>Sometimes Comments Are Needed</h2><p>And yet, I would argue that there are times when comments make sense.  Not so much for what you did, but for explaining why you decided to do it the way you did.  Again, you don’t always have to do this.  But there are times when I write my code that I look at it and think, “If I come back to this three months from now, I’m going to wonder what I was thinking.  I’d better add a comment to make this a bit more clear as to why this statement is here.”</p>\n<p>You see, it is the WHY that we comment.  Not the what.  The what would be described in the code itself.</p>\n<h2 id=\"A-Perfect-World\"><a href=\"#A-Perfect-World\" class=\"headerlink\" title=\"A Perfect World\"></a>A Perfect World</h2><p>But this all assumes a perfect world.  And judging from the comments and blog post I’ve seen on the subject, I believe this is where the real arguments for and against code comments, have their origin.</p>\n<p>First, let’s assume for a second that you are of the persuasion that you need to comment code to tell the reader what it is you are trying to accomplish.  Where else could we put that information?</p>\n<h2 id=\"Requirements-in-lieu-of-Comments\"><a href=\"#Requirements-in-lieu-of-Comments\" class=\"headerlink\" title=\"Requirements in lieu of Comments\"></a>Requirements in lieu of Comments</h2><p>Well, in a perfect world, there would be some kind of requirements document that would state that this feature was needed.  The problem is, of course, it is hard to associate the design document with the code you are writing because most design documents are really long.  Even for the most trivial of programs.  But in an Agile world, there would be some sort of back log.  A list of requirements that are broken down into small enough task that each one can be implemented as a discreet unit.  Even in an environment that is more Scrumerfall than truly Scrum, you could implement this by breaking the requirements down so they all ended up in a task list of some sort.</p>\n<p>But we still lack the ability to associate the code with the feature.</p>\n<p>Well, there are several systems available that allow you to associate task in your backlog with code you’ve checked in.   You just associate the code you are checking in with the backlog item it is associated with and the system established a two way link between the code that was changed and the backlog item that it is associated with.</p>\n<h2 id=\"Tests-as-Comments\"><a href=\"#Tests-as-Comments\" class=\"headerlink\" title=\"Tests as Comments\"></a>Tests as Comments</h2><p>The next place you might associate changes with what it is you are trying to do is by creating Unit Test for the code you are writing.  The way I write my Unit Test, I have one Unit Test class per method and Given&#x2F;Arrange I am testing.  Within that class I have a different test for each When&#x2F;Then or Act&#x2F;Assert the Given or Arrange I am trying to test.  This allows me to write my test in such a way that I know what class and method is being tested and what the test.</p>\n<p>So if I have a Class named Math that has an Add function:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Math</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Math</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>I might have a test class that looks like:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Math.Math.Add</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">TestFixture</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GivenTwoPositiveNumberAsParameters</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> _math;</span><br><span class=\"line\">        [<span class=\"meta\">SetUp</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _math = <span class=\"keyword\">new</span> Math();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"meta\">Test</span>]</span><br><span class=\"line\">        [<span class=\"meta\">TestCase(1,1)</span>]</span><br><span class=\"line\">        [<span class=\"meta\">TestCase(5,7)</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ThenTheResultShouldBePositive</span>(<span class=\"params\"><span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           Assert.That(_math.Add(a,b), Is.GreaterThan(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Yes, I know the test itself is a weak test.  The point is the structure of the test.  I can find the tests for any one class because the test that are associated with the class are structured in such a way as to find out what the original requirement was for the test.  And so, even if I don’t have any documentation from a backlog or even from a design document.  Because of the structure of the test, it would be relatively simple to write a tool that would let you view your code and the associated test in a hyperlinked fashion so that you could easily identify the tests associated with your code and the code associated with your tests.</p>\n<h2 id=\"TDD-as-Comments-–-A-Story\"><a href=\"#TDD-as-Comments-–-A-Story\" class=\"headerlink\" title=\"TDD as Comments – A Story\"></a>TDD as Comments – A Story</h2><p>Right after the dotCom crash, I ended up working for a company that had a system that they had lost the documentation for.  That is, there was no requirements document and they didn’t want to admit to the client we were working for that they had lost the document.  So, my job eventually became one of perpetual bug fixing.  And of course, since I had no idea what the system was supposed to do, I’m sure every time I fixed a bug, I introduced three more.  This was 15 years ago and I had not yet gotten TDD religion.  But looking back on it now, I see that what I could have been doing from day one is that I could have been writing unit test for each bug that came in.  Eventually, my test suite would be my documentation and there wouldn’t be any more bugs.</p>\n<p>Unlike code comments, if you are running your tests as part of a continuous integration system, you will be forced to keep your test up to date as the code changes.  Obviously, you should be updating the test, or creating new tests before you make changes, but even if you don’t, if you make a change that breaks the test, you will be forced to either fix the code so that the test succeeds or fix the test to match the new requirement.</p>\n<p>But this doesn’t really address the broader code quality issue.  At times we still need comments and they can’t be addressed by writing unit tests.  But this is why we need at least occasional paired programming and systematic code reviews.</p>\n<h2 id=\"Code-Reviews\"><a href=\"#Code-Reviews\" class=\"headerlink\" title=\"Code Reviews\"></a>Code Reviews</h2><p>Several questions should be raised during code reviews:</p>\n<ul>\n<li>Is this code too complex?</li>\n<li>Have we named things appropriately?</li>\n<li>Are there any dependencies that need to be removed?</li>\n<li>Are there any comments that we could add that would help a future developer maintain this code without possibly confusing him when the code changes?</li>\n</ul>\n<p>I’ve talked about a lot of these issues before so I’m not going to go into a lot of detail here other than to say that you should notice that I’ve placed the issue of code comments LAST on the list of things to consider.  This is because if you take care of the code quality, you will find that most of the time when you get to the issue of comments, no one will have anything to add.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>If you are working at an organization where you have no tests, you routinely deal with 1000 line methods, names of things seem arbitrary, you have no real backlog, and your code is not loosely coupled, I can see why you might think you need comments in your code.  But the problem isn’t the lack of comments.  The problem is, you are dealing with bad code.</p>\n",
            "tags": [
                "scrum",
                "comments",
                "tdd. agile"
            ]
        },
        {
            "id": "http://davembush.github.com/limiting-beliefs-of-programmers/",
            "url": "http://davembush.github.com/limiting-beliefs-of-programmers/",
            "title": "Limiting Beliefs of Programmers",
            "date_published": "2015-04-09T10:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2015/03/ppl-men-026.jpg\" alt=\"scream\" title=\"scream\"></p>\n<p>At the risk of making half of my audience think I’ve gone off the deep end, I’m going to address a topic that I’ve only recently REALLY begun to understand, in part thanks to <a href=\"/softSkills\">Soft Skills</a>.</p>\n<p>When I’ve heard the topic of “Limiting Beliefs” come up, it has almost always been in the context of something along the lines of “What the mind can conceive and believe, it can achieve.”  Which is easy to disprove.  At least it is out of context!  I mean really, if I can conceive and believe myself to be a butterfly, it just isn’t going to happen! However, the opposite is pretty easy to both accept and believe.  And that’s what I want to talk about today.  But even then, it probably isn’t what you are expecting.</p>\n<span id=\"more\"></span>\n\n<p>Typically, when people talk about “Limiting Beliefs”, they are talking about patterns and practices you picked up as a kid that are holding you back now.  And while those may be areas that you need to work on, what I want to talk about today is more micro than that, although they may have roots in our past for various reasons, the Limiting Beliefs I want to talk about today are common across nearly every programmer I talk to.  If you think “Limiting Beliefs” mean something along the lines of, “you are limited because you don’t believe enough,” that is NOT what I have in mind here at all.  In fact, “Limiting Beliefs” are beliefs that we believe TOO strongly and because we hold them too strongly, they limit us.  This is what I mean when I talk about “Limiting Beliefs” even if it is used in another way by someone else.</p>\n<p>Here are some examples specifically related to the craft of programming.</p>\n<h2 id=\"You-Can’t-Practice-TDD\"><a href=\"#You-Can’t-Practice-TDD\" class=\"headerlink\" title=\"You Can’t Practice TDD\"></a>You Can’t Practice TDD</h2><p>As I’ve mentioned in other articles, most programmers I know don’t practice Test Driven Development because they believe they don’t have permission.  And when they ask, they don’t get permission because you’ve transferred the belief that you don’t think it is important.</p>\n<p>If instead, you believed you had permission to do whatever it took to legitimately do your job well, you would learn how to do everything it took to practice TDD well.</p>\n<h2 id=\"Can’t-Create-Branches-in-Version-Control\"><a href=\"#Can’t-Create-Branches-in-Version-Control\" class=\"headerlink\" title=\"Can’t Create Branches in Version Control\"></a>Can’t Create Branches in Version Control</h2><p>I recently ran into a comment on a blog that mention this.  In fact I’ve run into this very issue where I am currently working.  But instead of thinking about what I can’t do, or when I am frustrated by what I can’t do, I first think 1) is this important enough to find a way around? And 2) what CAN I do? In this case, I found it critically important.  My productivity was being hampered because I am adding new features to existing code and, while that code is being tested, I’m converting the code to the last version of the library that we use.  Branching allows me to switch between the two projects easily and it allows me to migrate the current code into the upgrade code so that when the conversion is done, I can merge it down into the main branch and keep going.</p>\n<p>How did I do this?  We use TFS with the old TFVS version control system instead of the Git repository.  But there are at least two projects that exist that allow you to create a bridge between your local code that uses a local GIT repository and the remote TFS repository.  There is at least one project available for subversion that allows you to do the same sort of thing.</p>\n<p>I get my branches and yet I have not caused any disruption to the rest of my team.</p>\n<h2 id=\"Can’t-Use-X-Technology\"><a href=\"#Can’t-Use-X-Technology\" class=\"headerlink\" title=\"Can’t Use X Technology\"></a>Can’t Use X Technology</h2><p>OK.  So, again, ask yourself the same questions.  Is this hampering your productivity?  What CAN you do?</p>\n<h2 id=\"You-Have-to-be-Perfect\"><a href=\"#You-Have-to-be-Perfect\" class=\"headerlink\" title=\"You Have to be Perfect\"></a>You Have to be Perfect</h2><p>I think many of us realize that we can’t be perfect and yet, how do you react when someone finds a bug in your code? I saw a tweet last week that captures the essence of the bug fixing process.</p>\n<ol>\n<li>That can’t happen</li>\n<li>That doesn’t happen on my machine.</li>\n<li>That shouldn’t happen.</li>\n<li>Why does that happen?</li>\n<li>Oh, I see.</li>\n<li>How did that ever work?</li>\n</ol>\n<p>The question I need to ask is, why do we start with “That can’t happen” unless we feel that we need to be perfect.</p>\n<p>In the last year, I’ve finally gotten to the point where my first reaction is, “OK, well, put it in the issue tracker.” (Or if you are doing Agile, “put it in the backlog”).</p>\n<h2 id=\"Can’t-Practice-Agile-x2F-Scrum\"><a href=\"#Can’t-Practice-Agile-x2F-Scrum\" class=\"headerlink\" title=\"Can’t Practice Agile&#x2F;Scrum\"></a>Can’t Practice Agile&#x2F;Scrum</h2><p>Speaking of Agile&#x2F;Scrum.  Are you working at a place that doesn’t practice Agile or Scrum, but you think they should?  What parts of Agile&#x2F;Scrum can you implement in the sphere of influence you have?  So, you can’t form a Scrum team.  But, do you personally put people over processes?  Do you put people first at all?  Most of the <a href=\"//agilemanifesto.org/\">Agile Manifesto</a> can be implemented at a personal level once you understand what it is really about.  Don’t expect anyone to adopt agile in your organization if they don’t see it in you first.</p>\n<h2 id=\"You-Are-an-Introvert\"><a href=\"#You-Are-an-Introvert\" class=\"headerlink\" title=\"You Are an Introvert\"></a>You Are an Introvert</h2><p>How many of us hide behind this one?  We don’t want to deal with people.  We really don’t value people over much of anything.  In fact, we think, “programming would be a great job if it weren’t for the clients.”  I’m reading some books that talk about the impact of confusing behavior with who we are.  OK, so sure, your behavior is that you prefer to avoid loud noises.  You’d rather talk to one or two people at a time.  You process stuff in your head instead of with your mouth.  That’s behavior.  To say, “I am an Introvert” can have the effect of saying, “I hate people” and can become a limiting belief because it will isolate you from the very people you should be helping.  Sorry, you can’t get far as a programmer if you avoid the people part of it.</p>\n<h2 id=\"Restrictions\"><a href=\"#Restrictions\" class=\"headerlink\" title=\"Restrictions\"></a>Restrictions</h2><p>And then there is the general set of restrictions that come with being part of any organization.  We have a few where I work that, on the face of it, seem ridiculous.  I HAVE to take a lunch break even though my lunch consist of 5 sausage links that can be consumed in about 5 minutes.  I can’t start before 7am.  I can’t leave until 3:30.</p>\n<p>But what can I do?  Well, no one said WHEN I had to take the lunch break, so I come in and watch a half hour of <a href=\"/pluralSight\">PluralSight</a> courses every morning.</p>\n<p>I can’t start before 7am.  But I CAN enter the office before then.  I prefer to come earlier because the traffic is lighter if I come in at 6:45.  So, I come in and don’t start working until seven.</p>\n<p>To get my eight hours in, I can’t leave until 3:30 anyhow.  So that is not an issue.  And if I need to leave early occasionally, no one said I couldn’t do that.</p>\n<h2 id=\"The-Key-To-Eliminating-Limiting-Beliefs\"><a href=\"#The-Key-To-Eliminating-Limiting-Beliefs\" class=\"headerlink\" title=\"The Key To Eliminating Limiting Beliefs\"></a>The Key To Eliminating Limiting Beliefs</h2><p>Do you see what I’ve done here?  At every point where I’ve been told or believed I could not do something, I’ve change the question from “What can’t I do?” to “What can I do?”  Can’t locks you down.  It locks you out.  Can frees you. So, what limiting beliefs do you have and how can you overcome them?</p>\n",
            "tags": [
                "tdd",
                "programming",
                "agile",
                "scrum",
                "limiting beliefs"
            ]
        },
        {
            "id": "http://davembush.github.com/being-agile-is-about-the-journey%E2%80%A6/",
            "url": "http://davembush.github.com/being-agile-is-about-the-journey%E2%80%A6/",
            "title": "Being Agile Is About The Journey…",
            "date_published": "2015-02-12T12:00:00.000Z",
            "content_html": "<h1 id=\"…-Not-The-Destination\"><a href=\"#…-Not-The-Destination\" class=\"headerlink\" title=\"… Not The Destination\"></a>… Not The Destination</h1><p><img src=\"/uploads/2015/02/BeingAgile.png\" alt=\"BeingAgile\" title=\"BeingAgile\"></p>\n<p>This post first started as I was discussing my post “<a href=\"/you-arent-doing-scrum-if/\">You Aren’t Doing Scrum If …</a>” with a friend who had read the post and was worried that I might not fit in an organization that wasn’t doing all of Scrum.  I’ve since had other conversations and as I’ve reflected on the topic, I still stand by my original post, because there are some fundamental properties of Scrum that you have to implement in order to follow that methodology.  This is why I called the post “You Aren’t Doing <strong>Scrum</strong> If …” and not “You Aren’t Doing Agile If …”</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Agile-isn’t-Scrum\"><a href=\"#Agile-isn’t-Scrum\" class=\"headerlink\" title=\"Agile isn’t Scrum\"></a>Agile isn’t Scrum</h2><p>But Agile is different.  Agile isn’t a process. Agile is a mindset. So you can call yourself “Agile” without necessarily implementing any particular methodology because “Agile” isn’t about process.  Agile is about the collective state of mind of the team.  The organization as a whole.  Being Agile means that you are open to change.  That you embrace change.  Agile is about being flexible.  About knowing that you don’t know and that you don’t know what you don’t know.  Agile is about adapting.  Ultimately, it is about finding ways of being more productive. In fact, you could implement scrum precisely, which I doubt anyone really does, and not be Agile.</p>\n<h2 id=\"Sacred-Cows\"><a href=\"#Sacred-Cows\" class=\"headerlink\" title=\"Sacred Cows\"></a>Sacred Cows</h2><p>In fact, my experience has been that as I try to move an organization along the sliding scale of being more productive, I will, eventually, find a point of resistance.  The sacred cow of their process.  You can change whatever else you want, and yes, everything else you’ve suggested that we change has proven itself to be a better, more productive, less error prone way of doing what we do.  But, you can’t change our sacred cow. And so far every organization I’ve been in has some sacred cow that we either have to kill or we don’t progress further into being agile. And so we end up hearing comments from people in the industry like, “I don’t think I’ve been in any organization that has been TOTALLY ‘Agile.’” because every organization eventually runs up against some sacred cow on their road toward being agile.</p>\n<h2 id=\"Leadership-Needs-To-Be-Agile\"><a href=\"#Leadership-Needs-To-Be-Agile\" class=\"headerlink\" title=\"Leadership Needs To Be Agile\"></a>Leadership Needs To Be Agile</h2><p>I know of another guy in the industry that postulates that the reason organizations fail as they try to implement agile is because agile is being forced on the organization.  That we need to create an environment where people have opted in to agile.  And to a certain extent, I think he’s right.  But, and I think this is a HUGE but, I think the larger problem is that the leadership has not embraced being agile and so you end up with developers trying to BE agile while the leadership is trying to be predictive.  Funny thing I’ve noticed about most employees, they’ll pretty much do whatever they think will keep the paychecks flowing.  So I don’t think we need opt-in at the worker bee level so much as we need opt-in at the leadership level.  Although I have seen resistance at both levels.</p>\n<h2 id=\"Individuals-Need-To-Be-Agile\"><a href=\"#Individuals-Need-To-Be-Agile\" class=\"headerlink\" title=\"Individuals Need To Be Agile\"></a>Individuals Need To Be Agile</h2><p>Finally, while your organization may not be agile at all. It may not do Scrum, or Kanban.  It may resist all attempts to move in that direction.  This is not excuse for you to not be agile. You should ask yourself periodically, “What can I do that might be more productive than what I am currently doing?”  Because an organization can only be as agile as the people working in that organization and sometimes, all it really takes to move an organization closer to being agile is one individual who is willing to do what he or she does just a little more toward agile than they currently are. What sacred cows have you run into?  What are you doing to be more agile as an individual?  Leave a comment below.</p>\n",
            "tags": [
                "agile",
                "scrum"
            ]
        },
        {
            "id": "http://davembush.github.com/technical-debt-is-inevitable/",
            "url": "http://davembush.github.com/technical-debt-is-inevitable/",
            "title": "Technical Debt Is Inevitable",
            "date_published": "2014-10-16T10:00:00.000Z",
            "content_html": "<p>Whoa there Dave.  What are you talking about?  Have you given up the fight? You who have preached the TDD religion.  You who’ve struggled to get organizations to adopt naming conventions, to use version control systems and to use project management software.  The same guy who has implemented continuous integration on his current project?  What’s this world coming to?</p>\n<span id=\"more\"></span>\n\n<p>No. Relax. I haven’t given up.  In fact it is precisely because technical debt is inevitable that we need to implement all of the above.</p>\n<h2 id=\"Danger\"><a href=\"#Danger\" class=\"headerlink\" title=\"Danger\"></a>Danger</h2><p>But there  is a danger in believing that if we were to implement all of the best practices in the book, or that could ever be devised, that technical debt would simply vanish.  And the sooner some of you realize this, the less stressed out you will be.</p>\n<p>You see, no matter how good of a programmer you are today, tomorrow you will be a better programmer.  That is true for all of us.  We are all doing as good of a job as we possibly can today.</p>\n<h2 id=\"A-Story\"><a href=\"#A-Story\" class=\"headerlink\" title=\"A Story\"></a>A Story</h2><p>This reminds me of a story I heard once.</p>\n<p>It seems there was this programmer who had to make a change to some code and, like we all do, the first thing he did was to try to wrap his head around the code he was looking at.  A few minutes into this common exercise, he starts exclaiming:</p>\n<ul>\n<li>Who wrote this code?</li>\n<li>This is the worst code I’ve ever seen.</li>\n<li>The guy who wrote this can’t even really call himself a programmer!</li>\n</ul>\n<p>And then, it got unusually quite in his cubicle.</p>\n<p>His friend in the next cube calls over the wall, “Hey John, you OK?”</p>\n<p>And John responds, “It’s my code.”</p>\n<p>Now, the reason this is a funny story… well, it is a funny story for me anyhow… is because this happens to us all of the time.</p>\n<p>I think I spent the first 5 years of my career looking at code I wrote six months ago and thinking, “What was I thinking when I wrote this?”</p>\n<p>Even today, 26 years in, I have code I wrote six months or more ago that I know I need to rewrite.  The only reason I haven’t yet is because I want to make sure I have a full test harness around it before I tweak it.</p>\n<h2 id=\"Here’s-the-point\"><a href=\"#Here’s-the-point\" class=\"headerlink\" title=\"Here’s the point.\"></a>Here’s the point.</h2><p>We are all getting better at what we do.  What we would do today isn’t what we would have done six months ago.  The person who wrote the code you are looking at was doing the best he could at the time.</p>\n<p>Therefore, we should just plan on code being “wrong.”</p>\n<p>This has two explicit implications to how you relate to your code and your co-workers.</p>\n<h3 id=\"Don’t-be-surprised-by-bad-code\"><a href=\"#Don’t-be-surprised-by-bad-code\" class=\"headerlink\" title=\"Don’t be surprised by bad code\"></a>Don’t be surprised by bad code</h3><p>First, you should not be surprised when you find bad code.  You should instead be shocked when you find well written code.  Since even you write bad code, you should be gracious when you find bad code that isn’t yours.  You don’t want to be the guy in the story  I just told.  You might have done the same thing today if you knew only what the person who wrote the code you are looking at knew at the time the code was written.</p>\n<h3 id=\"You-should-expect-that-your-code-will-be-broken-in-some-way\"><a href=\"#You-should-expect-that-your-code-will-be-broken-in-some-way\" class=\"headerlink\" title=\"You should expect that your code will be broken in some way.\"></a>You should expect that your code will be broken in some way.</h3><p>This has been probably the hardest thing for me to get control of.  I have, historically, been one to deny that my code has a bug.  I’ve taken it as a personal insult, or an assault on my character when someone finds a bug in my code. </p>\n<p>Until recently.</p>\n<p>Once I was able to internalize the fact that the person reporting the bug was not upset, that the only person who expected me to be perfect was me, and that being wrong was part of being human, I was able to calm down a bit.</p>\n<p>You see, none of us are all knowing.  Most of us program for what the code is supposed to do and don’t think about what it shouldn’t do (which is where most of the bugs occur).  The spoken&#x2F;written language is an imprecise communicator, even if you develop a dictionary for your project.  You’ll never get all of your terms defined.  You just don’t know what you don’t know.  And therefore there will be bugs.</p>\n<p>Maybe you’ll think, “I should have known that!”  Well, yes, maybe you SHOULD have.  But the fact is, you didn’t.</p>\n<p>When before I used to deny that the bug could even exist, my reaction now is, “Hmmm, wonder what’s going on there.  OK, well, put it in the issue tracker and I’ll get it fixed.”</p>\n<p>No drama.  No conflict.  No denial.  No blame.  Just deal with the issue.</p>\n<h2 id=\"This-is-what-it-means-to-be-Agile\"><a href=\"#This-is-what-it-means-to-be-Agile\" class=\"headerlink\" title=\"This is what it means to be Agile\"></a>This is what it means to be Agile</h2><p>And you see, this is the beauty of the Agile methodology.  Agile assumes we aren’t going to get it right the first time.  It assumes humans are poor communicators.  It assumes that programmers aren’t going to understand the problem the first time they try to come up with a solution.  It assumes technical debt is inevitable.</p>\n<p>Isn’t it time that you do too? Or am I the only one who has suffered with this problem?</p>\n",
            "tags": [
                "agile",
                "scrum",
                "technical debt"
            ]
        },
        {
            "id": "http://davembush.github.com/are-we-there-yet/",
            "url": "http://davembush.github.com/are-we-there-yet/",
            "title": "Are We There Yet?",
            "date_published": "2014-06-26T17:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2014/06/StoryPoints.png\" alt=\"StoryPoints\" title=\"StoryPoints\">When my kids were young, my wife introduced a concept for this question that she got from her family that is so brilliant in its simplicity that I wonder that this isn’t common knowledge with all parents.  Something they should tell you during Lamaze class. When the kids asked, “Are we there yet?” Which they did very infrequently, we would answer, “Just a few more units.” If you think about it, it is just about as helpful as any other answer we could have given them, “Just a few more hours.”, “Just a few more miles.”, “Sure, get out of the car.” (While continuing to drive the car down the road.) Or “Does it look like we are there yet?” What does the child want to know?  Nothing, they are just expressing their displeasure at still being in the car.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Story-Points\"><a href=\"#Story-Points\" class=\"headerlink\" title=\"Story Points\"></a>Story Points</h2><p>Story Points remind me of “Just a few more units.”  While “Just a few more units,” had no real meaning, Story Points do have meaning, but they don’t answer the question, “how long until we are done?”  Story Points don’t represent time, they represent difficulty.  Given two stories, a story with 2 story points should be twice as difficult as a story with 1 story point assuming that everything is as it should be.  It does not take into account that the code might have technical debt that we need to deal with prior to actually implementing the story.  It doesn’t take into account which programmer is going to do the work.  It just says, “This story is this much easier or harder than that story.” How long will it take to complete the story?  “Just a few more units.” “But wait!”  You say, “How can anyone plan a project if they don’t know how long something is going to take? Well, I have two answers to that question.</p>\n<h2 id=\"How-Accurately-Do-You-Estimate\"><a href=\"#How-Accurately-Do-You-Estimate\" class=\"headerlink\" title=\"How Accurately Do You Estimate?\"></a>How Accurately Do You Estimate?</h2><p>First, if you look at how well you estimate projects now.  How’s that working for you? If you are a programmer, you might say, “Yeah, we hit the estimate every time.”  But do you?  I would be willing to bet that when you estimated a project, you had in mind that you would do a certain number of things.</p>\n<ul>\n<li>Collect the requirements</li>\n<li>Write a nice user interface</li>\n<li>Write clean backend code</li>\n<li>Have the application tested completely.</li>\n</ul>\n<p>What I suspect really happened is that you:</p>\n<ul>\n<li>Collect enough requirements to get going and made up a significant number of the rest.</li>\n<li>Wrote an adequate user interface</li>\n<li>Clean code?  No, you were just glad to get it all working.</li>\n<li>Testing?  We don’t have time for testing.</li>\n</ul>\n<p>So you didn’t meet your estimate, you adjusted you scope so you could meet a target date.</p>\n<h2 id=\"Estimates-Are-More-Accurate-Over-Time\"><a href=\"#Estimates-Are-More-Accurate-Over-Time\" class=\"headerlink\" title=\"Estimates Are More Accurate Over Time\"></a>Estimates Are More Accurate Over Time</h2><p>Now, if you use story points AND you concentrate on a well-established definition of done for each story.  The programmers can concentrate on writing quality code, and over time, management will learn how long a story point is on average. No, you’ll never know how long a story point will take for any one story.  But you will know that if you look at all of the stories we’ve done so far, a story point equals X amount of time. By doing this we achieve two major milestones.  First, we move the decisions about what to do or not do up to the management level.  Management will be able to see quickly that if we continue at the rate we are going, we will have a releasable product by such and such a date.  Second, the programmers can concentrate on writing good code rather than writing code that is simply adequate for today but ends up slowing them down in the future because they were too busy concentrating on delivering “on time.”</p>\n",
            "tags": [
                "scrum",
                "estimating",
                "story points"
            ]
        }
    ]
}