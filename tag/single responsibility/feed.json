{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"single responsibility\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/fixing-single-responsibility/",
            "url": "http://davembush.github.com/fixing-single-responsibility/",
            "title": "Fixing Single Responsibility",
            "date_published": "2020-10-04T17:58:05.000Z",
            "content_html": "<p>The Single Responsibility principle is a well-known, Object Oriented principle that states that we should narrow the scope of the code in our Module&#x2F;Class&#x2F;Function so that is it only responsible for one thing.</p>\n<p>By doing so, this reduces the size of our code that needs to be tested.</p>\n<p>Linting rules can generally help enforce this rule by making sure your Class file isn’t too long, and your functions are not too complex. But there are other ways of violating this principle that linting rules can not pick up.</p>\n<span id=\"more\"></span>\n\n<p>For example, in the world of Entity Framework, there has been a design pattern that has us putting our code in distinct layers.</p>\n<ul>\n<li>Controller</li>\n<li>Business Logic</li>\n<li>Repository</li>\n<li>Data Access</li>\n</ul>\n<p>In the world of Angular, you may be using NgRX and OnPush notification (if you aren’t you should). Here are the layers you should see in an Angular project:</p>\n<ul>\n<li>Component</li>\n<li>Component-Service</li>\n<li>NgRX<ul>\n<li>Actions</li>\n<li>Reducers</li>\n<li>Effects</li>\n<li>Selectors</li>\n</ul>\n</li>\n</ul>\n<p>In both of these architectures, you can completely jumble your code by putting it in the wrong place.</p>\n<p>You see, Single Responsibility is not only about “doing one thing” but it is also about understanding WHERE the code goes so that each layer of the code is only responsible for one thing.</p>\n<h2 id=\"A-Place-for-Everything-…\"><a href=\"#A-Place-for-Everything-…\" class=\"headerlink\" title=\"A Place for Everything …\"></a>A Place for Everything …</h2><p>Both of these architectures have a definition of where everything goes. I continue to see, in both cases, code going in the wrong location.</p>\n<h3 id=\"Entity-Framework-Example\"><a href=\"#Entity-Framework-Example\" class=\"headerlink\" title=\"Entity Framework Example\"></a>Entity Framework Example</h3><p>A couple of examples.  The Repository layer is where we retrieve our data. This might be from the database and often is, but it might also be from a service of some sort.</p>\n<p>The Business Logic layer is where we perform actions on that data to do some sort of meaningful work.</p>\n<p>Clear?</p>\n<h4 id=\"Repository-or-Business-Logic\"><a href=\"#Repository-or-Business-Logic\" class=\"headerlink\" title=\"Repository or Business Logic\"></a>Repository or Business Logic</h4><p>Well, I guess it isn’t because what I often see is the conflation of the two so that, most often, you end up with Business logic inside the Repository.</p>\n<p>Unfortunately, there is an easy rule to follow that eliminates most of this.</p>\n<p>The only thing your repository should return is an IQueryable of the type represented by the Repository name.  If your repository is for accessing a particular table, it should return an IQueryable of that table’s Model and ONLY IQueryables for that Model.  Not some of one Model and some of another.</p>\n<blockquote>\n<p>Yes, I know, technically speaking, the Repository is both dead and could also return IEnumerable, but I find that adds to the problem of putting Business Logic inside the Repository.  So, I’m going to assert that IF you are going to use the Repository pattern, it really should ONLY return IQueryable.</p>\n</blockquote>\n<p>In a typical Entity Framework application, your goal is to not actually retrieve data until you are in the Business Logic layer.  By returning IQueryable, you prevent any data retrieval from occurring and you also give yourself and your team the added benefit of being able to use multiple methods in your repository from the business logic layer by combining them all into one query.</p>\n<p>Code reuse and a possible performance gain.  What could be better?</p>\n<h4 id=\"Projects\"><a href=\"#Projects\" class=\"headerlink\" title=\"Projects\"></a>Projects</h4><p>The other place I see issues with the Single Responsibility principle while using Entity Framework is when try to cram multiple classes for a layer into one project.  A good dose of Domain Driven Design would go a long way to helping this but here again, we need to consider what we are trying to do and the impact we are having on future coding efforts.</p>\n<p>On really large projects, you can particularly end up with migration headaches because you’ve managed to combine everything into one Context.  If you were to break your models into multiple context, you could avoid many of these conflicts because they would each have their own migration history.</p>\n<p>Similarly, at the controller level, you should consider how much sense it makes to add yet another end point to an existing class.  Or maybe it makes more sense to start a new class.</p>\n<h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><h4 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a>Components</h4><p>Angular components are pretty easy to create and, most of the time use code that has already been tested.  It is the logic of our components that is hard to test.  To separate the two, I suggest using a Component-Service leaving the only logic that is in the component.ts file logic that is specific to the presentation.</p>\n<p>Think of it this way.  If you had to replace the presentation layer?  How much of the code would you have to duplicate or rewrite?  If you push that code down a layer, would that simplify things for you?</p>\n<h4 id=\"NgRX\"><a href=\"#NgRX\" class=\"headerlink\" title=\"NgRX\"></a>NgRX</h4><p>One of the more difficult concepts for most people to wrap their heads around fully is the concept of NgRX.  With in this, where do I message my data?</p>\n<p>The temptation is to message the data in the component or the component-service.  But a better location is in a function that a selector calls.  By doing this, you only end up messaging the data IF the underlying data changes and now your component and component service become ways of displaying what’s in your store.</p>\n<p>In fact, you may find that your component service has nothing to do because all the work has been done in the selector.</p>\n<h2 id=\"The-Real-Problem\"><a href=\"#The-Real-Problem\" class=\"headerlink\" title=\"The Real Problem\"></a>The Real Problem</h2><p>Given these examples, you’d expect me now to dive into how to really work these patterns.  But, I’ve been intentionally vague about the solutions because the problem isn’t really about where stuff lives or how closely we follow the Single Responsibility principle.</p>\n<p>The problem is that too many of us are hackers and not learners.</p>\n<p>I made the comment to a friend of mine recently that the reason I don’t believe a team should have options on architecture is because, largely the people on the team “learn” by copy and pasting existing code. Even if it is wrong.</p>\n<p>And so, the reason we have issues with Single Responsibility at all is because, as an industry, we believe we can just dump people into a new language or a framework and they’ll “pick it up.”  Managers need to get beyond, “well it works” to “can this be maintained?”</p>\n<p>To do this they need to do several things up front:</p>\n<p>First, make sure their developers understand the patterns and practices they are using. This may mean sending them to training. This may mean pairing them with someone who you know already knows.</p>\n<p>Second, you need a watchdog on your team to ensure that patterns are followed closely. In my experience, this is not something that comes naturally to programmers.</p>\n<p>I’ve frequently said that it takes most programmers 5 years just to get to a point where they’ve stopped learning how to program and see programming as more than just learning the syntax of a language.  It takes another 5 years before they begin to see the advantages of architecture, if they see it at all. It could take another 10 years past that before they are able to mentor and train others.</p>\n",
            "tags": [
                "Single Responsibility",
                "Architecture"
            ]
        },
        {
            "id": "http://davembush.github.com/4-reasons-to-write-loosely-coupled-code/",
            "url": "http://davembush.github.com/4-reasons-to-write-loosely-coupled-code/",
            "title": "4 Reasons to Write Loosely Coupled Code",
            "date_published": "2016-09-27T10:30:00.000Z",
            "content_html": "<p>This past week I got into a small discussion about the importance of loosely coupled code.  Specifically, I was looking at event handler code that did nothing more than change the size of another element on the screen.  But the event handler code was in the controller which in the particular implementation we are using was the event handler portion of our Model in a MVVM architecture.  The question becomes does this code belong in the view, or does it belong in the controller? The question of where code belongs leads eventually to arguments for loosely coupled code.  If I put code in my controller that is manipulating the view, then I either need to mock out my view in order to test my controller or I have to have an instance of my view available to test my controller.  Having coded enough systems to know that both of those choices are problematic, I opt for placing the view specific code in the view.  Another place where you might place this code would be in a View Specific event handler class.  But that would only be for the purposes of clean separation.  Something we might consider doing if the View were plain HTML.  But in our particular case, the view is generated from code, so placing the handlers in that same code seems to be the most appropriate location for it.</p>\n<p>But all of this leads to a larger question.  Why should your code be loosely coupled at all? <figure><img src=\"/uploads/2016/09/image-2.png\" title=\"4 Reasons to Write Loosely Coupled Code\"><figcaption>Photo credit: <a href=\"//www.flickr.com/photos/hernanpc/7115374283/\">Hernan Piñera</a> via <a href=\"//visualhunt.com\">VisualHunt.com</a> &#x2F; <a href=\"//creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA</a></figcaption></figure></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Refactoring\"><a href=\"#Refactoring\" class=\"headerlink\" title=\"Refactoring\"></a>Refactoring</h2><p>One of the main advantages of loosely coupled code is that this combined with granularity makes code refactoring easier.  Because my controller class only handles events that cause data to be manipulated and does not cause any changes to the view, I know that any changes I make to my controller will not cause any unexpected presentation layer changes.</p>\n<p>Similarly, and in this case, more importantly, any changes I make to the view will not force me to make changes to the controller class.  That is, all of the code that could be impacted by any one change happen in one and only one class.</p>\n<p>Loose coupling can also occur horizontally, and often does without us thinking too intensely about it.  Have you ever used a control from one vendor only to find another control works better?  The more easily those controls match each other’s programmable interface, the easier the job was to swap them out.  We can do the same type of thing in our own code.  The more granular the code is broken down; the easier any one part of the code can be replaced by something that works “better”.</p>\n<h2 id=\"More-Maintainable\"><a href=\"#More-Maintainable\" class=\"headerlink\" title=\"More Maintainable\"></a>More Maintainable</h2><p>But the argument might be make that this is a lot of work for something that isn’t very likely to happen.  But anyone who has been programming more than a few years on essentially the same system knows that it does.</p>\n<p>Here’s how it looks.  You start out writing a system and you care very little about coupling or not.  Hey, we’ve got code to write and very little time.  Full steam ahead and forget best practices.  And for now, let’s assume you have a small enough system that you actually pull it off.  You get the system delivered, and somehow it miraculously works.  Congratulations.</p>\n<p>A few months go by and you get a new requirement or a change request comes in for an existing requirement.  Either way, you manage to shoe horn the change in.</p>\n<p>More time goes by and a change to the last set of changes comes in.  And now you realize that what you have is a rather fragile architecture that can’t possibly sustain the new request.  A change that might have taken a month given a more loosely coupled architecture is now going to take three because of the amount of rework that is going to be required.</p>\n<p>Another way that loosely coupled code helps is when you are writing a very large system.  Let’s say the system is large.  You write this for a few months and everything seems to be going fine when you hit that first, “oops! we forgot” moment.  So you have to go back and retro fit the change into your tightly coupled code.  And then you progress some more and hit even more of those kind of changes.  Eventually, everyone learns to hate this system because it is so hard to work on and every change we make to existing code causes more and more bugs.</p>\n<h2 id=\"Cross-Platform\"><a href=\"#Cross-Platform\" class=\"headerlink\" title=\"Cross Platform\"></a>Cross Platform</h2><p>Refactoring and maintenance have some practical implications beyond just being able to work on your code.  In this world of multiple platforms, you may find yourself wanting to run some of what you’ve written on another platform.  There are multiple ways you might do this, but keeping your code isolated is going to make this easier.  Say you want to run your code on the web, as a desktop application, on the various mobile phones and tablets that are available.  Even if you do this all in the confines of HTML, JavaScript and CSS, you will most likely have different presentation layers.  If you have view specific code (to use our example again) that isn’t in the view, you’ll need to write code in the controller that detects which of the platforms you are running on.</p>\n<p>But if you’ve decided to use native components on each of the platforms, the view layer is actually going to change drastically.  And the view specific code you wrote might not even work on the new platform.  All the more reason to keep the view code isolated.</p>\n<h2 id=\"Cross-Framework\"><a href=\"#Cross-Framework\" class=\"headerlink\" title=\"Cross Framework\"></a>Cross Framework</h2><p>Or, maybe you are going to upgrade your framework.  Angular 2 just released and it is drastically different from Angular 1.  I can tell you right now, the organizations who wrote loosely coupled Angular 1 code are going to have a much easier time transitioning to Angular 2.  Or maybe you want to switch from Angular to React, or from any of the multitude of frameworks to another.  The more loosely coupled your code, the easier it will be to move.  And nowhere is this more obvious than in the fast moving JavaScript world.</p>\n<h2 id=\"Single-Responsibility\"><a href=\"#Single-Responsibility\" class=\"headerlink\" title=\"Single Responsibility\"></a>Single Responsibility</h2><p>Loosely coupled code is strongly related to the Single Responsibility principle.  You can’t have loosely coupled code unless the code follows the Single Responsibility principle.  And in the case above, putting view code in our controller actually violates both at the same time.  The controller is for manipulating view agnostic data.  The view is where your presentation layer code goes.  Of course, we could turn this around and remove the controller and put all of our code in the View.  Now that would definitely violate the single responsibility principle while giving the appearance of loose coupling.  But if we ever had to create multiple views we would quickly violate yet another principle.  Don’t Repeat Yourself.</p>\n<h2 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing?\"></a>Testing?</h2><p>Normally, I would lead off with testing.  But the argument could be made, “If I’m not going to write unit test, do I still need to do this?”  Actually, someone did make that argument.  And for now, ignoring that not writing unit test is a bad idea that I’ve written about before.  Writing unit test helps us think about these issues up front.  It isn’t that testing is the reason we write good code, although if that’s how you want to think about it I’m not going to stop you.  It is just that writing good test causes us to write good code.  Since it is the most visible benefit we tend to think of it first.  But testing isn’t at all why we do this.  We write test because it provides benefits much like loose coupling does.  Saying that we write loosely coupled code that follows the single responsibility principle so we can test would be like saying we don’t get lost so we can use our GPS.  It is the GPS that helps us to not get lost.  In the same way, it is the test that cause is to write good code.</p>\n<h2 id=\"Best-Practices\"><a href=\"#Best-Practices\" class=\"headerlink\" title=\"Best Practices\"></a>Best Practices</h2><p>I know I’ve been following best practices for so long that I often forget why I’m doing them.  They work.  I do them.  But every once in a while, I need to step back and take a look at what I’m doing and ask “Why?” once again.</p>\n",
            "tags": [
                "tdd",
                "DRY",
                "loose coupling",
                "single responsibility"
            ]
        }
    ]
}