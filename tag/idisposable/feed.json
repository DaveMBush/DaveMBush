{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"idisposable\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/csharp-idisposable-confusion/",
            "url": "http://davembush.github.com/csharp-idisposable-confusion/",
            "title": "CSharp IDisposable Confusion",
            "date_published": "2014-07-17T17:00:00.000Z",
            "content_html": "<p>I’m planning to get my MCSD certification next and the first exam I plan to take is the 70-483 which will test my knowledge of CSharp. To study, I got this free PDF: <a href=\"//www.it-ebooks.info/book/2564/\">MCSD Certification Toolkit (Exam 70-483)</a> (Which I wouldn’t recommend, but I haven’t found anything yet that I WOULD recommend, so this will have to do.) In this book (Chapter 5) and other places on the web, it makes this statement:</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>If a class contains no managed resources and no unmanaged resources, it doesn’t need to implement IDisposable or have a destructor.</li>\n<li>If the class has only managed resources, it should implement IDisposable but it doesn’t need a destructor. (When the destructor executes, you can’t be sure managed objects still exist, so you can’t call their Dispose methods anyway.)</li>\n<li>If the class has only unmanaged resources, it needs to implement IDisposable and needs a destructor in case the program doesn’t call Dispose.</li>\n<li>The Dispose method must be safe to run more than once.  You can achieve that by using a variable to keep track of whether it has been run before.</li>\n<li>The Dispose method should free both managed and unmanaged resources.</li>\n<li>The destructor should free only unmanaged resources.  (When the destructor executes, you can’t be sure managed objects still exist, so you can’t call their Dispose methods anyway.)</li>\n<li>After freeing resources, the destructor should call GC.SuppressFinalize, so the object can skip the finalization queue.</li>\n</ul>\n<h2 id=\"Managed-VS-Unmanaged\"><a href=\"#Managed-VS-Unmanaged\" class=\"headerlink\" title=\"Managed VS Unmanaged?\"></a>Managed VS Unmanaged?</h2><p>So what is the difference between a managed resource and an unmanaged resource?  An unmanaged resource is something that is not under the direct control of the .NET memory manager.  So, file handles, connections to the database, memory handles, and other OS items fall under the realm of “unmanaged.”  Managed code is everything else. So, if you read the points above and read the statements about managed resources, you would think, or should think, “That’s already under the control of the .NET memory manager, so I shouldn’t have to do ANYTHING!” But with one little tweak, this all becomes clear.  What this block of text is talking about specifically is managed code that is referencing other code that implements IDisposable.</p>\n<h2 id=\"Corrected-Version\"><a href=\"#Corrected-Version\" class=\"headerlink\" title=\"Corrected Version\"></a>Corrected Version</h2><p>So, let’s rephrase the block of text to the following:</p>\n<ul>\n<li>If a class contains no managed resources that implement IDisposable and no unmanaged resources, it doesn’t need to implement IDisposable or have a destructor.</li>\n<li>If the class has only managed resources that reference resources that implement IDisposable, it should implement IDisposable but it doesn’t need a destructor. (When the destructor executes, you can’t be sure managed objects still exist, so you can’t call their Dispose methods anyway.)</li>\n<li>If the class has only unmanaged resources, it needs to implement IDisposable and needs a destructor in case the program doesn’t call Dispose.</li>\n<li>The Dispose method must be safe to run more than once.  You can achieve that by using a variable to keep track of whether it has been run before.</li>\n<li>The Dispose method should free both managed resources that implement IDisposable and unmanaged resources.</li>\n<li>The destructor should free only unmanaged resources.  (When the destructor executes, you can’t be sure managed objects still exist, so you can’t call their Dispose methods anyway.)</li>\n<li>After freeing resources, the destructor should call GC.SuppressFinalize, so the object can skip the finalization queue.</li>\n</ul>\n<h2 id=\"One-Other-Circumstance\"><a href=\"#One-Other-Circumstance\" class=\"headerlink\" title=\"One Other Circumstance\"></a>One Other Circumstance</h2><p>There is one other situation where you might want to implement IDisposable on a class that doesn’t reference an object that implements IDisposable.  While this particular case is rare, I think it is probably good to list it here for completeness. If you have a class that will consume a lot of memory either directly or indirectly, you might want to consider implementing IDisposable and the Dispose method so that any class that is calling this method has a way of immediately releasing the memory the class is using by dereferencing the memory it is using, and then calling:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GC.Collect();</span><br><span class=\"line\">GC.WaitForPendingFinalizers();</span><br><span class=\"line\">GC.Collect();</span><br></pre></td></tr></table></figure>\n\n<p>I can already hear some of you saying, “but you shouldn’t have to ever need to do this!” And yes, 99% of the time, you shouldn’t.  But, if you have an issue with this, talk to <a href=\"//www.microsoftvirtualacademy.com/training-courses/developer-training-with-programming-in-c\">the guys over at the Microsoft Virtual Academy</a> where I learned this.</p>\n<h4 id=\"Other-Places-Talking-About-IDisposable-and-NET-Memory-Management\"><a href=\"#Other-Places-Talking-About-IDisposable-and-NET-Memory-Management\" class=\"headerlink\" title=\"Other Places Talking About IDisposable and .NET Memory Management\"></a>Other Places Talking About IDisposable and .NET Memory Management</h4><ul>\n<li><a href=\"//coding.abel.nu/2011/12/idisposable-and-using-in-c/\">IDisposable and Using in C#</a></li>\n<li><a href=\"//manski.net/2012/01/idisposable-finalizer-and-suppressfinalize/\">IDisposable, Finalizer, and SuppressFinalize in C# and C++</a></li>\n<li><a href=\"//manski.net/2012/01/idisposable-finalizer-and-suppressfinalize/\">Common Pitfalls with IDisposable and Using</a></li>\n<li><a href=\"//www.technofranchise.com/c-memory-management/\">CSharp Memory Management</a></li>\n<li><a href=\"//www.go4expert.com/articles/disposal-garbage-collection-c-sharp-t30059/\">Disposal and Garbage Collection in CSharp</a></li>\n</ul>\n",
            "tags": [
                "c#",
                "idisposable"
            ]
        },
        {
            "id": "http://davembush.github.com/dispose-finalize-and-suppressfinalize/",
            "url": "http://davembush.github.com/dispose-finalize-and-suppressfinalize/",
            "title": "Dispose, Finalize and SuppressFinalize",
            "date_published": "2013-06-12T08:04:38.000Z",
            "content_html": "<p><img src=\"/uploads/2009/07/fooddrk017.jpg\" alt=\"food-drk-017\" title=\"food-drk-017\"> I got the following question recently.</p>\n<blockquote>\n<p>What is the difference between Dispose and SupressFinalize in garbage collection?”</p>\n</blockquote>\n<p>The problem with this question is it assumes Dispose and SupressFinalize have similarities, which I’m sure is not what is being asked here.  So let’s rephrase it in terms that make sense.</p>\n<blockquote>\n<p>I see three methods available to me in .NET that all seem to have something to do with garbage collection.  Can you explain what Dispose, Finalize, and SupressFinalize do and why I could use or call each one in my code?”</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>Now, that’s something we can answer.</p>\n<h2 id=\"A-Brief-History-of-Memory-Management\"><a href=\"#A-Brief-History-of-Memory-Management\" class=\"headerlink\" title=\"A Brief History of Memory Management\"></a>A Brief History of Memory Management</h2><p>Before we answer the question, we need to review how memory management works in .NET compared to historical languages such as C&#x2F;C++.</p>\n<p>In the old days, if an application allocated memory on the heap (generally done with the “new” keyword in CSharp) the application was also responsible for releasing the memory.  In languages such as C++, this was done with the “delete” keyword which triggered a call to a special method called a destructor.  If the object was holding on to memory or other resources, it was the destructor’s job to release those resources.</p>\n<p>In .NET memory is deallocated for us using garbage collection.  We no longer call the destructor using anything like a delete keyword and the deallocation process happens at some point in time that is after the memory goes out of scope.  This might be immediately after the object goes out of scope or it could be hours or days.</p>\n<p>Generally, this is not a problem, but what about an object that is holding on to additional resources that need to be freed up right away? For that we have the Dispose() method.</p>\n<h2 id=\"Dispose-is-the-new-destructor\"><a href=\"#Dispose-is-the-new-destructor\" class=\"headerlink\" title=\"Dispose is the new destructor\"></a>Dispose is the new destructor</h2><p>While we don’t need a destructor to handle our memory, we do need something to release resources.</p>\n<p>This is why the IDisposable interface was created with one method that needs to be implemented called Dispose().</p>\n<p>If your class allocates resources that need to be freed up that aren’t memory, you should implement the IDisposable interface on that class and implement the Dispose() method.  Inside that method, you would release any resources that the class may have created and not freed.</p>\n<h2 id=\"Dispose-will-then-automatically-get-called-by-Finalize\"><a href=\"#Dispose-will-then-automatically-get-called-by-Finalize\" class=\"headerlink\" title=\"Dispose() will then automatically get called by Finalize()\"></a>Dispose() will then automatically get called by Finalize()</h2><p>When the garbage collector starts releasing memory, one of the things it will do is that it will go through your code and call Finalize() on each of the objects.  Finalize() will then call any dispose methods that are available.</p>\n<p>This is done to protect the programmer from himself, not because it is expected.  Remember I said the memory will get freed up at some indeterminate point in the future but the Dispose() method was created so we could free up the resources right away? What we really want to do is call Dispose() ourselves.  We call Dispose from our own code.  Finalize() only exists so that Dispose() will get called if we don’t.</p>\n<h2 id=\"And-that’s-where-SupressFinalize-fits-in\"><a href=\"#And-that’s-where-SupressFinalize-fits-in\" class=\"headerlink\" title=\"And that’s where SupressFinalize() fits in.\"></a>And that’s where SupressFinalize() fits in.</h2><p>If my code calls Dispose() then there is no reason for the Finalizer to run at all.  Without SupressFinalize() we would need to set a flag in our class indicating that Dispose() had already been called so that when Finalize() called it, we didn’t re-run the clean up code.</p>\n<p>With SupressFinalize() we can just call SuppressFinalize() from within Dispose() and that will tell .NET to not run the Finalize method when it gets to our object.</p>\n<p>Your call to SupressFinalize() should almost always look like</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GC.SuppressFinalize(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n<p>but you can pass in any object instead of “this.”</p>\n",
            "tags": [
                "c#",
                "idisposable",
                "dispose",
                "finalize",
                "suppressfinalize"
            ]
        }
    ]
}