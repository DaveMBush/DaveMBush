{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"archietcture\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/awesome-angular2-architecture-options-and-opinions/",
            "url": "http://davembush.github.com/awesome-angular2-architecture-options-and-opinions/",
            "title": "Awesome Angular2 Architecture Options and Opinions",
            "date_published": "2016-12-27T12:30:00.000Z",
            "content_html": "<p>On the subject of Angular2 Architecture, the perception is that Angular 2 is a highly-opinionated architecture. But even though there is a <a href=\"/angular.io/styleguide\">style guide for Angular 2</a>, there are a lot of decisions that still need to be made when working on any but the most trivial of applications. And even then, since most applications take on a life of their own, one could make the case that you need to make these decisions for any application you are building regardless of the initial size. Applications grow up. But, that’s another blog post</p>\n<p>I’ve identified, and have formed opinions about 5 areas that Angular 2 leaves open for decisions. Areas that if you don’t spend time considering the choices and making decisions could cost you in the future</p>\n<p>The five areas I’ve identified are:</p>\n<ol>\n<li>Handling Forms</li>\n<li>Page State Management</li>\n<li>Component State Management</li>\n<li>Data Flow</li>\n<li>Client Side Data</li>\n</ol>\n<figure>![](/uploads/2016/12/image-2.png \"Awesome Angular2 Architecture Options and Opinions\") Photo via [africaniscool](//pixabay.com/en/users/africaniscool-216435/) via [Visualhunt.com](//visualhunt.com/photos/business/)</figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Handling-Forms\"><a href=\"#Handling-Forms\" class=\"headerlink\" title=\"Handling Forms\"></a>Handling Forms</h2><p>There are, at this point, two ways of dealing with forms in Angular 2. The first looks a lot like Angular 1 in that it is “Template Driven.” That is, everything you would describe about the form goes in the template. Using declarative syntax, the bulk of your form logic is declared in “HTML” like syntax and bound to your TypeScript code in a “code behind” kind of way. In a lot of ways, this will be very familiar to people who have coded ASP.NET or Angular 1</p>\n<p>But, the problem with using this method is that at some point, you won’t be able to do something you need to do using just a declarative syntax. The option is to use a “Model Driven” approach. These leaves the HTML parts in the template with a few tags to wire the template to the TypeScript code it is associated with, but the bulk of the processing is all in the TypeScript file. On the surface, you might think, “but Template Driven is much easier to think about.” But I assure you, using a predominately model driven approach has several advantages that the serious programmer will enjoy.</p>\n<h3 id=\"More-control-over-your-forms\"><a href=\"#More-control-over-your-forms\" class=\"headerlink\" title=\"More control over your forms.\"></a>More control over your forms.</h3><p>The first advantage you will notice is that you’ll have more control over your form. One place you will notice this is with form validation. But, you’ll also notice greater control because you will have direct control on how the data moves in and out of your form instead of the “magic happens here” of data binding that can, with complex forms, become entirely too complex to reason about.</p>\n<h3 id=\"Easier-to-test-the-forms\"><a href=\"#Easier-to-test-the-forms\" class=\"headerlink\" title=\"Easier to test the forms.\"></a>Easier to test the forms.</h3><p>Another huge advantage to using Model Driven forms is that you end up with forms that are MUCH easier to test. You can assume that the HTML is doing what it should and just test the TypeScript code. With a more template driven approach you’ll need to work out how to actually test your HTML. It can be done, and it isn’t really all that hard. But using a model driven approach is easier.</p>\n<h3 id=\"Easier-to-reason-about-how-the-code-is-being-processed\"><a href=\"#Easier-to-reason-about-how-the-code-is-being-processed\" class=\"headerlink\" title=\"Easier to reason about how the code is being processed.\"></a>Easier to reason about how the code is being processed.</h3><p>Related to the two previous points, using Model Driven forms makes your cod much easier to reason about. Once again, that whole “magic happens here” approach of data-binding can get in the way, while using the model driven approach will allow you to be very direct about what gets updated when more directly.</p>\n<h2 id=\"Page-and-Component-State-Management\"><a href=\"#Page-and-Component-State-Management\" class=\"headerlink\" title=\"Page and Component State Management\"></a>Page and Component State Management</h2><p>The temptation is to try to architect an Angular 2 project so that it looks something like how we used to write Angular 1 applications. That is, using an MV* architecture. Where this gets messed up is that the HTML template, the TypeScript and the CSS are really all part of the same class. Once you start thinking of them as one, MV* stops making as much sense</p>\n<p>The pattern I prefer here is one that uses the top-level View as a Controller View. That is, it is the one component that is responsible for being the traffic data cop. All the components under it are responsible for either rendering the state information they have been passed by the Controller View, updating that state information or firing event out when they’ve done something the outside world should know about</p>\n<p>The View Controller, on the other hand, is responsible for getting the data to and from where ever it needs to go</p>\n<p>By doing this, you end up with very testable, modular code and it becomes very clear that all your logic for a page, or sub-page, exist in one very well-defined section of your code. In fact, you can eliminate the need for most dependency injection by following this pattern. Any dependency injection you do need will probably end up in your Controller View.</p>\n<h2 id=\"Data-Flow\"><a href=\"#Data-Flow\" class=\"headerlink\" title=\"Data Flow\"></a>Data Flow</h2><p>So far, the three main methods of data management that have emerged for Angular 2 seem to be:</p>\n<ol>\n<li>Direct Access</li>\n<li>Flux&#x2F;Redux</li>\n<li>NgRX&#x2F;Store</li>\n</ol>\n<h3 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h3><h4 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h4><p>While MVVM was possible in Angular 1, and it works at the View level in Angular 2, the preferred model is what has come to be known as “One way data binding” which sounds odd, and really doesn’t describe what it does</p>\n<p>In short, while all the code you write may act like it is using two-way data-binding, the reality is that the code is only ever flowing in one direction</p>\n<p>The problem with true MVVM data binding is that when it is done correctly, data changes because other data changed</p>\n<p>This makes it very difficult to reason about the data in your application in all but the smallest of applications</p>\n<p>Further, to get this to work correctly, the resulting system is almost always slower than it needs to be. I’ve written before about <a href=\"/4-reasons-to-drop-mvvm/\">why I think MVVM is a poor choice for design patterns</a>.</p>\n<h4 id=\"Direct\"><a href=\"#Direct\" class=\"headerlink\" title=\"Direct\"></a>Direct</h4><p>It is possible to write an application that kind of looks like old style three layer architectures that some might try to call MVC, but it is a poor man’s implementation at best, and only because Angular 2 implements its own Dependency Injection Container mechanism does the result end up being anything close to loosely coupled</p>\n<p>This implementation generally has the top-level component managing the state of the application, or at least the state of that particular page, and calling out directly to services that retrieve data from the server and manipulate data</p>\n<p>While it works, in larger applications it can be difficult to manage and respond to state changes throughout your application. Imagine if that could happen for “free”.</p>\n<h4 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h4><p>The React community introduced a new pattern called Flux. There are multiple implementations of Flux, but the one that has become the defacto standard is called Redux. In general, Flux is made up of a series of publish subscribe mechanisms and ends up looking a lot like what the Gang of Four originally defined MVC to be while not actually being MVC.</p>\n<p>In very simple terms, the View fires an event to a “Dispatcher” which is a singleton. Each repository, or data store, or model (just depends on what you want to call it) registers a listener with the “Dispatcher” that lets the dispatcher know that it wants to know whenever something significant happens. These repositories are also singletons.</p>\n<p>When the Dispatcher receives a notification from a View, it notifies all the listeners in turn. The listeners look at the message they receive from the dispatcher to see if it is something they care about. If it is, they process the message accordingly.</p>\n<p>Once they are done, they fire an event to each Controller View that has registered a listener with them. The Controller View then updates the view based on the information it was passed in the event. I don’t want this to get too far down the road of “How” but to make the above paragraph just a bit clearer…</p>\n<p>There is a top-level View item that does no rendering. It is only responsible for responding to event notifications and passing the data down into the child views. You may hear this referred to as a View Controller, but it is more accurately a Controller View.</p>\n<p>Hopefully, you can see how this solves the problem up needing to force an update on a View because some other View changed the state of something. Because everyone who cares about the state is listening for a notification that something changes, the screen update “just works” and is much more reliable than a more MVVM style of updating the view and data.</p>\n<h4 id=\"NgRX-x2F-Store\"><a href=\"#NgRX-x2F-Store\" class=\"headerlink\" title=\"NgRX&#x2F;Store\"></a>NgRX&#x2F;Store</h4><p>Reactive Extensions are available for multiple platforms, including JavaScript. You can read more about them at <a href=\"//reactivex.io/\">http://reactivex.io/</a> and I’ve written about <a href=\"/reasons-to-use-rxjs-today/\">the reasons you want to use them</a> before. But for purposes of this article, one of the problems that Reactive programming solves is cleanly dealing with the asynchronous nature of JavaScript</p>\n<p>Nowhere is this more obvious than with Ajax request.</p>\n<p>If you’ve ever needed to deal with having to wait for multiple Ajax request to complete before you do something meaningful with the data, you are going to love Reactive programming.</p>\n<p>Another thing that Reactive programming gives you is it makes everything a “stream”.</p>\n<p>In simple terms imagine working with an array that never ends and being able to respond appropriately to each element that come through that stream of arrays and you’ll have a good conceptual idea of what it means that everything is a stream. This is how Reactive programming deals with asynchronous calls and events. Add to this the concept that streams can be combined and you’ll start to understand why this cleans up the asynchronous nature of JavaScript.</p>\n<p>The result is that we can write code that fills the stream and other code that says, “when a particular item comes in on the stream, let me know about it.” Basically, an embellished publish&#x2F;subscribe design pattern.</p>\n<p>From the description above, you should be able to see that Reactive programming can be used to implement Flux.</p>\n<p>This is exactly what NgRx&#x2F;Store does. It allows us to concentrate on writing Reducers while it focuses on managing the dispatcher, event handling, and the various repositories, or stores, our application might need.</p>\n<p>As I’ve used NgRX&#x2F;Store in my own applications, I’ve found that it further reduces the need for dependency injection and increases the testability of my code. The tradeoff is that there is a learning curve. But the time learning this new design pattern is well worth the effort.</p>\n<h2 id=\"Client-Side-Data\"><a href=\"#Client-Side-Data\" class=\"headerlink\" title=\"Client Side Data\"></a>Client Side Data</h2><p>At some point, you are going to need to manage the data on the client side. There are several issue you might want to consider. But at the most fundamental layer, you will end up with data on the client side that looks like a relational data in a database. The only difference is that your data will be primarily JSON data. Eventually, you’ll want to join that data or filter it. How will you do that? One product you might consider is <a href=\"//www.getbreezenow.com/\">Breeze</a>. It does a lot of stuff that makes your client side data look more like a database. It is worth a look</p>\n<p>If you end up using NgRX&#x2F;Store and RxJS, you may find that does everything you need. So that is another option. The advantage to using this method is you are no longer constrained by trying to make everything look like a relational database table even when it isn’t</p>\n<p>The other option, of course, is to use both for what they are good at.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>Angular 2 brings a lot of new concepts. While it might be tempting to use coding patterns that seem more comfortable, I believe that the path that Angular 2 has chosen is the future of JavaScript specifically and the programming world in general.</p>\n<p>Just about everything that is new falls into the general category of “Functional Programming” and much like the switch from procedural programming to object oriented programming, there are going to be people who are not able to wrap their heads around the concepts. How many guys ended up using C++ syntax to write C code? However, the productivity gains once we make the jump to this new way of thinking about our code will be well worth both the learning curve and the possible loss of some older programmers who can’t or won’t be retrained.</p>\n<p>There is also a danger of not being able to retain good programmers because we are still stuck using design patterns that were popular in the past but have been superseded by ways the developer community at large considers “better.”</p>\n",
            "tags": [
                "angular",
                "javascript",
                "archietcture"
            ]
        },
        {
            "id": "http://davembush.github.com/is-your-architecture-crippling-your-unit-testing/",
            "url": "http://davembush.github.com/is-your-architecture-crippling-your-unit-testing/",
            "title": "Is Your Architecture Crippling Your Unit Testing?",
            "date_published": "2014-09-04T10:00:00.000Z",
            "content_html": "<p>Last week I wrote a post that talked about Unit Testing and the need to make sure you are only testing one particular unit of code at a time.  The post was well received.  But I am surprised that no one commented on the glaring hole I left in the post.</p>\n<p>In that post, I said:</p>\n<blockquote>\n<p>So, one way you might go about separating your code from the data is by using dependency injection.  What I’m talking about here is simple injection.  No frameworks.</p>\n<p>So, let’s say you have a class you may have called user role.  Given a user id, it will return a role.  How could we code this so that it doesn’t matter where the code comes from?</p>\n<p>By declaring an interface to a user role object maybe and then passing an object of that type to the constructor.</p>\n<p>By doing this, you can use a fake object when you are testing and a real object when you are using the system in production, but your code won’t really care which one is being used.</p>\n<p>At some point we will need to retrieve data.  But the data is always just a side effect.  If you have a way of getting at the data, and you are confident it works, because that standard mechanism has been tested, then you don’t need to write test for the data access piece, you only need to write test for “given I have good data, this method will do this.”</p>\n</blockquote>\n<p>As I reflected on the post, I realized that this may make sense to you if you are already implementing this in your code.  But, if you are new to dependency injection and the concepts of loose coupling in general, this might be a foreign concept for you.</p>\n<p>At the very least, I realize now that it could be flushed out a bit more.</p>\n<p>So, here we go.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"N-Tiered-Architectures\"><a href=\"#N-Tiered-Architectures\" class=\"headerlink\" title=\"N-Tiered Architectures\"></a>N-Tiered Architectures</h2><p>There are two primary architectural patterns in the coding ecosystem that I live in.  The first, which has been around for a very long time is the N-Tiered, or 3 Tiered architecture.  The main point of this is to separate the Presentation from the Business rules from the retrieval of the data.</p>\n<p>Code written using this model normally has the view code dependent on the business logic code which is dependent on the data retrieval code.  And, even though we can use interfaces and dependency injection code to swap out each layer, most of the code written using this architecture that I’ve seen ends up being far too dependent on the code under it than it should be.</p>\n<h2 id=\"MVC-or-MVP\"><a href=\"#MVC-or-MVP\" class=\"headerlink\" title=\"MVC or MVP\"></a>MVC or MVP</h2><p>The second architectural pattern I see a lot of is the Model View Controller(MVC) pattern and it’s close cousin, Model View Presenter(MVP).  This pattern also attempts to separate the presentation, and the data and uses the controller as the way of moving the data between the two.  In this pattern, you will often see the controller or presenter layer used as the location of the business logic.  But strictly speaking that’s not the intended purpose.  When the controller or presenter is used for business logic you end up with a similar problem here that we end up with in a strict 3 tiered architecture.  The code ends up being far too dependent on either the architecture or the specific implementation of the architecture.</p>\n<h2 id=\"The-Problem\"><a href=\"#The-Problem\" class=\"headerlink\" title=\"The Problem\"></a>The Problem</h2><p>Now here’s the deal.  And I think this is where many people go astray with architectural patterns.  Just because you are using 3 Tier, MVC, or MVP (or whatever) doesn’t mean that all of your code HAS to fit into the mold of being one of the following:</p>\n<ul>\n<li>a View,</li>\n<li>a Controller, Presenter or Business layer, or</li>\n<li>a Data Access Layer or Model.</li>\n</ul>\n<p>Think about this.  How much of the code you’ve written, were you to really switch out the view, would have to be rewritten?  How much of your code could withstand the jarring effect of changing how you accessed the data.</p>\n<p>And I’m not talking a simple change.  From the data side we have multiple ways of accessing data in .NET.  We can use LINQ, we can use typed DataSets, we can use some ORM tool.  Say you decided to switch from whatever it is you are using now to one of the others.  Could you do that easily?</p>\n<p>And all of this points out the main issue I see with these frameworks.  The frameworks are only there as a way of moving data around.  With each of these it is expected that we will implement the actual presentation, business logic, and data access in an architectural agnostic way.</p>\n<p>Which finally brings us back to the comment I made last week.</p>\n<h2 id=\"The-Fix\"><a href=\"#The-Fix\" class=\"headerlink\" title=\"The Fix\"></a>The Fix</h2><p>All of your business logic shouldn’t really care where it got its data from.  It should not know where the data came from.  It should not request its own data.  It should be handed data in a form that can be used regardless of what the presentation layer looks like or what the data access layer looks like.</p>\n<p>In a three tiered model, the middle layer should work like the controller or the presenter.  It should retrieve the data from either the data layer or the presentation layer and then hand that data off to some other class that will do whatever processing needs to be done, get the return value from it and then pass it on to either the view or the data access layer.  In order to make the actual processing of the data from the view or the data access layer testable, the code we write must be architecturally, and framework agnostic.</p>\n<p>Similarly, in the presentation layer, if you have validations that you need to run on the screen, those validations need to be written in such a way that it won’t matter if or how the presentation layer changes.</p>\n<p>And here, once again, we point out, you won’t even know this is an issue if you aren’t trying to UNIT test your code.</p>\n",
            "tags": [
                "tdd",
                "unit test",
                "archietcture"
            ]
        },
        {
            "id": "http://davembush.github.com/asp-net-mvc-model-bll-or-dal/",
            "url": "http://davembush.github.com/asp-net-mvc-model-bll-or-dal/",
            "title": "ASP.NET MVC - Model != BLL or DAL",
            "date_published": "2009-02-11T10:36:37.000Z",
            "content_html": "<p>Last week I introduced the ASP.NET MVC framework by talking a bit about what the model, view and controller are. In the comments, John Meyer said,</p>\n<blockquote>\n<p>I respectfully disagree with your claim that the model is your BLL. MVC is a UI layer pattern, and as such all models, views, and controllers are strictly in the UI level.</p>\n</blockquote>\n<p>While historically, MVC has been described in the way I stated–while the ASP.NET MVC guys have also portrayed the Model as BLL or below–I have to agree with John.  Here’s why: At least as far as ASP.NET is concerned, the model is inherited from a specific class.  This means that any implementation code you place in the class will be forever tied to the class it inherits from.</p>\n<span id=\"more\"></span>\n\n<p>So if in some point in the future you decide that a WebForms implementation would work out better for you, or you wanted to put a Windows Forms implementation on top of it, you’d have to do quite a bit of refactoring of your code just so you could.</p>\n<p>If instead you treat the Model as a “View Model” as John suggests, and have the View Model call the Business Logic Layer, you end up with two major benefits.</p>\n<p>First, your Business Logic Layer is completely decoupled from the View implementation.  You are no longer forever tied to MVC as an architecture or ASP.NET MVC as the primary architecture.  You can use whatever view implementation you want.</p>\n<p>Second, you are not forced to put View specific data code in your Business Logic Layer.  Doing so would cloud the actual implementation of your BLL and actually further couple your view layer to your BLL, something that third tier is specifically designed to avoid.</p>\n<p>Based on the feedback from John and my own thinking on the subject, I recommend a three-tiered approach that places the MVC as the view entity calling the BLL from the Model of the MVC set, which would in turn call the Data Access layer.</p>\n",
            "tags": [
                "MVC",
                "view",
                "archietcture",
                "bll",
                "dal",
                "Three Tiered"
            ]
        }
    ]
}