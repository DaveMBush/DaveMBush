{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"intern\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/net-string-pool-%E2%80%93-not-just-for-the-compiler/",
            "url": "http://davembush.github.com/net-string-pool-%E2%80%93-not-just-for-the-compiler/",
            "title": ".Net String Pool – Not Just For The Compiler",
            "date_published": "2009-04-22T08:34:00.000Z",
            "content_html": "<p><img src=\"/uploads/2009/04/b03b0055.jpg\" alt=\"B03B0055\" title=\"B03B0055\"> On Monday, I was corrected in my assertion that creating multiple empty strings would create multiple objects.  Turns out the compiler automatically puts all of the strings that are exactly the same in a “string pool” so that there is only ever one empty string in the entire application you’ve created.</p>\n<span id=\"more\"></span>\n\n<p>Duh! I should have known this, or at least I should have expected that this was so since it has been true with every other compiled language I’ve worked with.</p>\n<p>But what I didn’t know and couldn’t expect is that we can make use of this string pool programmatically as well.</p>\n<p><strong>Why would you want to do this yourself?</strong></p>\n<p>Keep in mind that string concatenation in .NET requires the creation of a new object.  So, code such as this,</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">&quot;abcd&quot;</span>;</span><br><span class=\"line\">String b = <span class=\"string\">&quot;efgh&quot;</span>;</span><br><span class=\"line\">a += b;</span><br></pre></td></tr></table></figure>\n\n<p>creates a new object at line 3 every time it is executed.</p>\n<p>So that if we add the following line:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"string\">&quot;abcdefgh&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>we would not be pointing to the same object.  That is, a and b would contain the same content but would be pointing to two entirely different objects.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a == b)</span><br><span class=\"line\">    Trace.Write(<span class=\"string\">&quot;A and B contain the same data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (String.ReferenceEquals(a,b))</span><br><span class=\"line\">    Trace.Write(<span class=\"string\">&quot;A and B are the same object&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>String.Intern Consolidates The Data</strong></p>\n<p>By using String.Intern() we can get both evaluations to be true.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">&quot;abcd&quot;</span>;</span><br><span class=\"line\">String b = <span class=\"string\">&quot;efgh&quot;</span>;</span><br><span class=\"line\">a = String.Intern(a + b);</span><br><span class=\"line\">b = <span class=\"string\">&quot;abcdefgh&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Now both evaluations above will be true because line 3 places the string “abcdefgh” in the pool and line 4 uses that same string from the pool to assign to b.  Where we might have created two objects, we are now only creating one and referring to it both times.</p>\n<p>You could also use String.IsInterned(string) to determine if a string has already been placed in the string pool and execute optional code based on that.</p>\n<p><strong>When Would You Use This?</strong></p>\n<p>I still stand by my statement that optimizations should be saved for last.  You would not do this if this was the only place where you were doing the concatenation.  But you might consider doing this if your concatenations were in a loop that was taking a significant amount of processing time.</p>\n<p>Other things you might also want to consider would be to consolidate concatenations on the same line and&#x2F;or using the StringBuilder class for concatenations.  Keep in mind that StringBuilder is only really useful once you get past three concatenations due to the overhead of creating the StringBuilder object vs. creating new objects during the normal concatenation process.</p>\n",
            "tags": [
                "c#",
                "vb.net",
                ".net",
                "string",
                "intern"
            ]
        }
    ]
}