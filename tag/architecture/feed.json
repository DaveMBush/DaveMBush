{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"architecture\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/fixing-single-responsibility/",
            "url": "http://davembush.github.com/fixing-single-responsibility/",
            "title": "Fixing Single Responsibility",
            "date_published": "2020-10-04T17:58:05.000Z",
            "content_html": "<p>The Single Responsibility principle is a well-known, Object Oriented principle that states that we should narrow the scope of the code in our Module&#x2F;Class&#x2F;Function so that is it only responsible for one thing.</p>\n<p>By doing so, this reduces the size of our code that needs to be tested.</p>\n<p>Linting rules can generally help enforce this rule by making sure your Class file isn’t too long, and your functions are not too complex. But there are other ways of violating this principle that linting rules can not pick up.</p>\n<span id=\"more\"></span>\n\n<p>For example, in the world of Entity Framework, there has been a design pattern that has us putting our code in distinct layers.</p>\n<ul>\n<li>Controller</li>\n<li>Business Logic</li>\n<li>Repository</li>\n<li>Data Access</li>\n</ul>\n<p>In the world of Angular, you may be using NgRX and OnPush notification (if you aren’t you should). Here are the layers you should see in an Angular project:</p>\n<ul>\n<li>Component</li>\n<li>Component-Service</li>\n<li>NgRX<ul>\n<li>Actions</li>\n<li>Reducers</li>\n<li>Effects</li>\n<li>Selectors</li>\n</ul>\n</li>\n</ul>\n<p>In both of these architectures, you can completely jumble your code by putting it in the wrong place.</p>\n<p>You see, Single Responsibility is not only about “doing one thing” but it is also about understanding WHERE the code goes so that each layer of the code is only responsible for one thing.</p>\n<h2 id=\"A-Place-for-Everything-…\"><a href=\"#A-Place-for-Everything-…\" class=\"headerlink\" title=\"A Place for Everything …\"></a>A Place for Everything …</h2><p>Both of these architectures have a definition of where everything goes. I continue to see, in both cases, code going in the wrong location.</p>\n<h3 id=\"Entity-Framework-Example\"><a href=\"#Entity-Framework-Example\" class=\"headerlink\" title=\"Entity Framework Example\"></a>Entity Framework Example</h3><p>A couple of examples.  The Repository layer is where we retrieve our data. This might be from the database and often is, but it might also be from a service of some sort.</p>\n<p>The Business Logic layer is where we perform actions on that data to do some sort of meaningful work.</p>\n<p>Clear?</p>\n<h4 id=\"Repository-or-Business-Logic\"><a href=\"#Repository-or-Business-Logic\" class=\"headerlink\" title=\"Repository or Business Logic\"></a>Repository or Business Logic</h4><p>Well, I guess it isn’t because what I often see is the conflation of the two so that, most often, you end up with Business logic inside the Repository.</p>\n<p>Unfortunately, there is an easy rule to follow that eliminates most of this.</p>\n<p>The only thing your repository should return is an IQueryable of the type represented by the Repository name.  If your repository is for accessing a particular table, it should return an IQueryable of that table’s Model and ONLY IQueryables for that Model.  Not some of one Model and some of another.</p>\n<blockquote>\n<p>Yes, I know, technically speaking, the Repository is both dead and could also return IEnumerable, but I find that adds to the problem of putting Business Logic inside the Repository.  So, I’m going to assert that IF you are going to use the Repository pattern, it really should ONLY return IQueryable.</p>\n</blockquote>\n<p>In a typical Entity Framework application, your goal is to not actually retrieve data until you are in the Business Logic layer.  By returning IQueryable, you prevent any data retrieval from occurring and you also give yourself and your team the added benefit of being able to use multiple methods in your repository from the business logic layer by combining them all into one query.</p>\n<p>Code reuse and a possible performance gain.  What could be better?</p>\n<h4 id=\"Projects\"><a href=\"#Projects\" class=\"headerlink\" title=\"Projects\"></a>Projects</h4><p>The other place I see issues with the Single Responsibility principle while using Entity Framework is when try to cram multiple classes for a layer into one project.  A good dose of Domain Driven Design would go a long way to helping this but here again, we need to consider what we are trying to do and the impact we are having on future coding efforts.</p>\n<p>On really large projects, you can particularly end up with migration headaches because you’ve managed to combine everything into one Context.  If you were to break your models into multiple context, you could avoid many of these conflicts because they would each have their own migration history.</p>\n<p>Similarly, at the controller level, you should consider how much sense it makes to add yet another end point to an existing class.  Or maybe it makes more sense to start a new class.</p>\n<h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><h4 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a>Components</h4><p>Angular components are pretty easy to create and, most of the time use code that has already been tested.  It is the logic of our components that is hard to test.  To separate the two, I suggest using a Component-Service leaving the only logic that is in the component.ts file logic that is specific to the presentation.</p>\n<p>Think of it this way.  If you had to replace the presentation layer?  How much of the code would you have to duplicate or rewrite?  If you push that code down a layer, would that simplify things for you?</p>\n<h4 id=\"NgRX\"><a href=\"#NgRX\" class=\"headerlink\" title=\"NgRX\"></a>NgRX</h4><p>One of the more difficult concepts for most people to wrap their heads around fully is the concept of NgRX.  With in this, where do I message my data?</p>\n<p>The temptation is to message the data in the component or the component-service.  But a better location is in a function that a selector calls.  By doing this, you only end up messaging the data IF the underlying data changes and now your component and component service become ways of displaying what’s in your store.</p>\n<p>In fact, you may find that your component service has nothing to do because all the work has been done in the selector.</p>\n<h2 id=\"The-Real-Problem\"><a href=\"#The-Real-Problem\" class=\"headerlink\" title=\"The Real Problem\"></a>The Real Problem</h2><p>Given these examples, you’d expect me now to dive into how to really work these patterns.  But, I’ve been intentionally vague about the solutions because the problem isn’t really about where stuff lives or how closely we follow the Single Responsibility principle.</p>\n<p>The problem is that too many of us are hackers and not learners.</p>\n<p>I made the comment to a friend of mine recently that the reason I don’t believe a team should have options on architecture is because, largely the people on the team “learn” by copy and pasting existing code. Even if it is wrong.</p>\n<p>And so, the reason we have issues with Single Responsibility at all is because, as an industry, we believe we can just dump people into a new language or a framework and they’ll “pick it up.”  Managers need to get beyond, “well it works” to “can this be maintained?”</p>\n<p>To do this they need to do several things up front:</p>\n<p>First, make sure their developers understand the patterns and practices they are using. This may mean sending them to training. This may mean pairing them with someone who you know already knows.</p>\n<p>Second, you need a watchdog on your team to ensure that patterns are followed closely. In my experience, this is not something that comes naturally to programmers.</p>\n<p>I’ve frequently said that it takes most programmers 5 years just to get to a point where they’ve stopped learning how to program and see programming as more than just learning the syntax of a language.  It takes another 5 years before they begin to see the advantages of architecture, if they see it at all. It could take another 10 years past that before they are able to mentor and train others.</p>\n",
            "tags": [
                "Single Responsibility",
                "Architecture"
            ]
        },
        {
            "id": "http://davembush.github.com/are-you-thinking-clearly-about-your-architectural-choices/",
            "url": "http://davembush.github.com/are-you-thinking-clearly-about-your-architectural-choices/",
            "title": "Are You Thinking Clearly About Your Architectural Choices?",
            "date_published": "2015-09-17T11:30:00.000Z",
            "content_html": "<p>Recently someone asked me where the business rules should go in an MVC framework.  The Model or the Controller? This reminded me of a post I wrote when ASP.NET MVC was first released.</p>\n<ul>\n<li><a href=\"/aspnet-mvc-model-bll-or-dal/\">ASP.NET MVC – Model !&#x3D; BLL or DAL</a></li>\n</ul>\n<p>But today I want to cover a broader topic common to everyone, not just programmers.  Not being able to think outside the box.</p>\n<p><img src=\"/uploads/2015/09/image2.png\" alt=\"image\" title=\"image\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Here’s-the-deal\"><a href=\"#Here’s-the-deal\" class=\"headerlink\" title=\"Here’s the deal.\"></a>Here’s the deal.</h2><p>Good salesmen have known for years that the best way to close the sale is to ask the customer to pick between two buying decisions.  You never ask, “So, did you want to buy that today?”  Because almost invariably the customer will say, “No” because the implication is, “Did you want to buy that today, or some other day?”  And “some other day” is always a better option to the customer.  No, the proper way to frame the question is, “So, how did you want to pay for that?  Cash or Credit?” or “Did you want the blue one or the green one?”  By doing this, the customer is no longer even thinking “later” is an option.  The only options he is thinking about are the options he’s been presented with.  This isn’t to say that there isn’t a customer who can fight past this and respond, “No, I was just looking today.”  But the chance of the customer leaving without buying have just been reduced dramatically because two buying choices have been presented.</p>\n<p>So, what does this have to do with programming?  Well, that’s exactly what happens when we’ve been given an architectural framework to program with.</p>\n<p>Someone shows you the MVC pattern and you immediately think that the only places code can live in our application are in the Model, the View, or the Controller.</p>\n<p>Someone shows you the MVP pattern and you think code can only live in the Model, the View or the Presenter.</p>\n<p>Someone shows you the MVVM pattern and we think code only lives in the Model, the View or the ViewModel.</p>\n<p>And so, I ask you. Given any of those three patterns, where do you put your business logic?  And while we are at it, where does your data access logic go?</p>\n<h2 id=\"Do-we-place-it-in-the-model\"><a href=\"#Do-we-place-it-in-the-model\" class=\"headerlink\" title=\"Do we place it in the model?\"></a>Do we place it in the model?</h2><p>Well, what is the model for?  A model is for storing data.  For most of us the data is a record that is displayed on the screen as a series of fields.  But how it gets displayed and what it actually contains doesn’t matter as much as the fact that the model <strong>stores data</strong>.  Nothing there even hints at executing code.  In fact, I would argue that for most of our applications, the model should be so simple that it doesn’t need to be tested.</p>\n<h2 id=\"How-about-the-Controller-or-the-Presenter\"><a href=\"#How-about-the-Controller-or-the-Presenter\" class=\"headerlink\" title=\"How about the Controller or the Presenter?\"></a>How about the Controller or the Presenter?</h2><p>A controller or presenter sends commands to the model to change its state and sends commands to the view to update the presentation.  Here things get a little confusing.  It sounds like, because the controller is sending commands the the model and the view that it is where the business rules live.</p>\n<p>In fact, when I was first introduced to MVC, this is what I thought was true.  But notice there is nothing in the statement about what a controller does that would indicate that it is anything more than a traffic cop.</p>\n<h2 id=\"View-Model\"><a href=\"#View-Model\" class=\"headerlink\" title=\"View Model?\"></a>View Model?</h2><p>In the MVVM pattern, it becomes even clearer that there is no clear place for business logic because the ViewModel holds the state of the view.  The presenter or controller part is handled by a binder that is typically part of the framework you are using, as with KnockOut.</p>\n<h2 id=\"Thinking-outside-the-box\"><a href=\"#Thinking-outside-the-box\" class=\"headerlink\" title=\"Thinking outside the box\"></a>Thinking outside the box</h2><p>Now that we’ve demonstrated that none of these frameworks explicitly state where the business logic should go, where should we put it? In my case, what I’ve started doing is that I’ve created a service layer, or a business rules layer.  It handles the processing of the logic to get the rest of the code working.  The classes in this layer can either be passed the model or viewmodel in which they can change the state directly, or they can return data that the controller can distribute as needed.  In my most recent application I selected the pass the model in approach.  The result was code that was much more testable than what I had started with, which is the whole point of placing the business rules outside of the pattern to begin with.  </p>\n<h3 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h3><ul>\n<li><a href=\"//en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">Model View Controller</a></li>\n<li><a href=\"//en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter\">Model View Presenter</a></li>\n<li><a href=\"//en.wikipedia.org/wiki/Model_View_ViewModel\">Model View ViewModel</a></li>\n</ul>\n",
            "tags": [
                "programming",
                "testing",
                "architecture"
            ]
        }
    ]
}