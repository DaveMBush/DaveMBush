{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"dispose\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/dispose-finalize-and-suppressfinalize/",
            "url": "http://davembush.github.com/dispose-finalize-and-suppressfinalize/",
            "title": "Dispose, Finalize and SuppressFinalize",
            "date_published": "2013-06-12T08:04:38.000Z",
            "content_html": "<p><img src=\"/uploads/2009/07/fooddrk017.jpg\" alt=\"food-drk-017\" title=\"food-drk-017\"> I got the following question recently.</p>\n<blockquote>\n<p>What is the difference between Dispose and SupressFinalize in garbage collection?”</p>\n</blockquote>\n<p>The problem with this question is it assumes Dispose and SupressFinalize have similarities, which I’m sure is not what is being asked here.  So let’s rephrase it in terms that make sense.</p>\n<blockquote>\n<p>I see three methods available to me in .NET that all seem to have something to do with garbage collection.  Can you explain what Dispose, Finalize, and SupressFinalize do and why I could use or call each one in my code?”</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>Now, that’s something we can answer.</p>\n<h2 id=\"A-Brief-History-of-Memory-Management\"><a href=\"#A-Brief-History-of-Memory-Management\" class=\"headerlink\" title=\"A Brief History of Memory Management\"></a>A Brief History of Memory Management</h2><p>Before we answer the question, we need to review how memory management works in .NET compared to historical languages such as C&#x2F;C++.</p>\n<p>In the old days, if an application allocated memory on the heap (generally done with the “new” keyword in CSharp) the application was also responsible for releasing the memory.  In languages such as C++, this was done with the “delete” keyword which triggered a call to a special method called a destructor.  If the object was holding on to memory or other resources, it was the destructor’s job to release those resources.</p>\n<p>In .NET memory is deallocated for us using garbage collection.  We no longer call the destructor using anything like a delete keyword and the deallocation process happens at some point in time that is after the memory goes out of scope.  This might be immediately after the object goes out of scope or it could be hours or days.</p>\n<p>Generally, this is not a problem, but what about an object that is holding on to additional resources that need to be freed up right away? For that we have the Dispose() method.</p>\n<h2 id=\"Dispose-is-the-new-destructor\"><a href=\"#Dispose-is-the-new-destructor\" class=\"headerlink\" title=\"Dispose is the new destructor\"></a>Dispose is the new destructor</h2><p>While we don’t need a destructor to handle our memory, we do need something to release resources.</p>\n<p>This is why the IDisposable interface was created with one method that needs to be implemented called Dispose().</p>\n<p>If your class allocates resources that need to be freed up that aren’t memory, you should implement the IDisposable interface on that class and implement the Dispose() method.  Inside that method, you would release any resources that the class may have created and not freed.</p>\n<h2 id=\"Dispose-will-then-automatically-get-called-by-Finalize\"><a href=\"#Dispose-will-then-automatically-get-called-by-Finalize\" class=\"headerlink\" title=\"Dispose() will then automatically get called by Finalize()\"></a>Dispose() will then automatically get called by Finalize()</h2><p>When the garbage collector starts releasing memory, one of the things it will do is that it will go through your code and call Finalize() on each of the objects.  Finalize() will then call any dispose methods that are available.</p>\n<p>This is done to protect the programmer from himself, not because it is expected.  Remember I said the memory will get freed up at some indeterminate point in the future but the Dispose() method was created so we could free up the resources right away? What we really want to do is call Dispose() ourselves.  We call Dispose from our own code.  Finalize() only exists so that Dispose() will get called if we don’t.</p>\n<h2 id=\"And-that’s-where-SupressFinalize-fits-in\"><a href=\"#And-that’s-where-SupressFinalize-fits-in\" class=\"headerlink\" title=\"And that’s where SupressFinalize() fits in.\"></a>And that’s where SupressFinalize() fits in.</h2><p>If my code calls Dispose() then there is no reason for the Finalizer to run at all.  Without SupressFinalize() we would need to set a flag in our class indicating that Dispose() had already been called so that when Finalize() called it, we didn’t re-run the clean up code.</p>\n<p>With SupressFinalize() we can just call SuppressFinalize() from within Dispose() and that will tell .NET to not run the Finalize method when it gets to our object.</p>\n<p>Your call to SupressFinalize() should almost always look like</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GC.SuppressFinalize(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n<p>but you can pass in any object instead of “this.”</p>\n",
            "tags": [
                "c#",
                "idisposable",
                "dispose",
                "finalize",
                "suppressfinalize"
            ]
        }
    ]
}