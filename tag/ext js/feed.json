{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"ext js\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/7-reasons-to-evade-ext-js/",
            "url": "http://davembush.github.com/7-reasons-to-evade-ext-js/",
            "title": "7 Reasons To Evade Ext JS",
            "date_published": "2016-07-13T10:30:00.000Z",
            "content_html": "<p>I’ve worked with Ext JS now for a total of 2.5 years.  First with Ext 4.2 and now with Ext 6.x.</p>\n<p>Here’s my experience, and warning, of why you should avoid this disaster of a framework.</p>\n<p><img src=\"/uploads/2016/07/image-1.png\" alt=\"7 Reasons To Evade Ext JS\" title=\"7 Reasons To Evade Ext JS\"></p>\n<h2 id=\"Jack-of-All-Trades\"><a href=\"#Jack-of-All-Trades\" class=\"headerlink\" title=\"Jack of All Trades\"></a>Jack of All Trades</h2><p>Master of none! One of the great selling points of using Ext JS is the fact that it comes with “Everything you need” to build a web application.  That would be great if it were true.  But the fact of the matter is, it comes with all of the features you need but the features are all only partially implemented.  I’ve complained publicly several times that Sencha can’t possibly be testing the code they release because it only works in their demos.  If you try to use a feature they have documented as being available, you are likely to find that the feature doesn’t actually work.  How is it possible that you’ve written documentation for how something is supposed to work and yet you can release it without it working properly?  I can understand fringe stuff getting by.  We can’t think of every test.  But when this happens over and over again, you start to wonder what exactly they are testing.</p>\n<h2 id=\"A-Wolf-in-Sheep’s-Clothing\"><a href=\"#A-Wolf-in-Sheep’s-Clothing\" class=\"headerlink\" title=\"A Wolf in Sheep’s Clothing\"></a>A Wolf in Sheep’s Clothing</h2><p>When I first started with Ext, the only design pattern they had available was what they referred to as MVC.  It took me two months of playing with the framework before I finally realized that what they were calling MVC wasn’t anything the <a href=\"/designPatterns\">Gang of Four</a> would recognize as MVC.  I guess if you have a View, a Model and a Controller, you can call it MVC?  It doesn’t matter that the Models define records in a table or that the Controller is tightly coupled to your view.</p>\n<h2 id=\"Sheep-Without-Legs\"><a href=\"#Sheep-Without-Legs\" class=\"headerlink\" title=\"Sheep Without Legs\"></a>Sheep Without Legs</h2><p>OK.  So when they introduced the MVVM architecture I actually started to have just a bit of hope.  Yes, there were still some fundamental issues I have, but MVVM would make this tolerable.  But here is the issue.  Their idea of MVVM is that you would only need to implement it on a per page basis.</p>\n<p>Let me try to explain.</p>\n<h3 id=\"Broken-Data-Binding\"><a href=\"#Broken-Data-Binding\" class=\"headerlink\" title=\"Broken Data Binding\"></a>Broken Data Binding</h3><p>In my ideal world, when I build a new component, I would build that component using the framework the rest of my application is using.  So my component uses MVVM.  Sencha’s implementation gives you a View, ViewController, and ViewModel.  Mostly this looks more like MVC if you ask me but whatever, it has two-way databinding, so we’ll call it MVVM for now.  If you build a component that lives inside another component, the first thing you’ll discover is that binding only works from the top down.  That is, I can bind data at the outer layer and it will get reflected all of the way in to the inner most component that uses it.  But, if you change the data in the inner most component, it doesn’t reflect back up to the outer most component.  I’ve written a hack for this, and there is no promise from Sencha that this will ever get fixed properly, so I guess my hack is safe.</p>\n<h3 id=\"Broken-Controllers\"><a href=\"#Broken-Controllers\" class=\"headerlink\" title=\"Broken Controllers\"></a>Broken Controllers</h3><p>But it gets worse.  While child components can find data in models that are in parent components properly, they can’t find references to functions in controllers in the same way.  This is particularly problematic if you write a component that is a container of other components.  You would naturally want the child components to use the controller from the component that they were declared in.  But if you have an outer component that has your container component as a child and then other components inside of that.  The only way you can control what controller the child most components are going to notify of events is by wrapping the inner most components in their own component with their own controller.  This gets to be awkward when all you want to do is provide an event handler for one control in a column of a grid control.  Again, I have a monkey patch that fixes this, but why did I have to write it? This is just one specific example of my “Jack of All Trades” point that I started with.</p>\n<p>We won’t even address the question of if this is really MVVM or not!</p>\n<h2 id=\"Never-Use-the-0-release\"><a href=\"#Never-Use-the-0-release\" class=\"headerlink\" title=\"Never Use the .0 release\"></a>Never Use the .0 release</h2><p>I think most of us now are generally conditioned to be wary of the .0 release of anything that hasn’t been developed using Open Source methods.  There just haven’t been enough eyes on the project to ensure that everything works as it should.</p>\n<p>But with Sencha, this extends to all of the patch releases at the very least and even into some minor releases.</p>\n<p>While the 4.0, 5.0, and 6.0 releases were unacceptably broken, we find that every new patch or minor release that comes out afterward breaks something that was working.  We always have to ask, “Can we live with this?”</p>\n<h2 id=\"All-or-Nothing\"><a href=\"#All-or-Nothing\" class=\"headerlink\" title=\"All or Nothing\"></a>All or Nothing</h2><p>As I said at the beginning, Sencha gives you everything.  That sounds good.  You won’t have to go looking for a grid control, or many other common controls you might want to use.</p>\n<p>But the bad news is, you can only use controls that were written to be used with Ext.  Which other than what Sencha provides in the framework, doesn’t give you a lot of choices.  Don’t go thinking you’ll supplement Ext with a selection of third party controls.  It’s not going to happen.</p>\n<h2 id=\"Fences-Protect-AND-Isolate\"><a href=\"#Fences-Protect-AND-Isolate\" class=\"headerlink\" title=\"Fences Protect AND Isolate\"></a>Fences Protect AND Isolate</h2><p>Up until this point in my post, no one can reasonably argue that anything I’ve said is actually a benefit.  At this point we switch to points that may vary based on how well you know JavaScript, HTML, and CSS.</p>\n<p>You see, the good news, and actually a major selling point to many people, is that you can write a web application using Ext without having to know much, if anything about HTML or CSS.  And for that matter even the amount of JavaScript you need to know is relatively limited.</p>\n<p>That’s the good news.  The bad news is, if you know anything about any of these, you’ll probably end up frustrated by EXT.  This is because Ext’s JavaScript controls most of the layout.  So if you are used to going into developer tools to tweak the CSS and then applying that to your style sheet, you are going to be very disappointed.  Pretty much nothing you do in developer tools is going to work as you would expect.  And figuring out how to apply those to your code is going to be a lot harder than you are used to.</p>\n<h2 id=\"Their-Way-or-the-Highway\"><a href=\"#Their-Way-or-the-Highway\" class=\"headerlink\" title=\"Their Way or the Highway\"></a>Their Way or the Highway</h2><p>Once again, many people see this as an advantage.  And once again if you aren’t familiar with how the rest of the JavaScript world does things, this is going to sound fine.</p>\n<h3 id=\"Sencha-CMD\"><a href=\"#Sencha-CMD\" class=\"headerlink\" title=\"Sencha CMD\"></a>Sencha CMD</h3><p>Everything runs through Sencha CMD.  A tool for building all things Ext.  If you want to bundle and minify your code, the standard way of doing this is by using “requires” statements in your code and then running Sencha CMD and have it figure out what you are using and put it all in one bundle.</p>\n<p>The problem with this is that there are several much better ways of doing this that are available using Node and various NPM packages.  Again, if you are a JavaScript developer, you are going to wonder what Sencha is thinking.</p>\n<h3 id=\"Ext-define\"><a href=\"#Ext-define\" class=\"headerlink\" title=\"Ext.define()\"></a>Ext.define()</h3><p>Another place where proprietary shows up is in how Ext defines “Classes”.  When it was first introduced, TypeScript was new.  But now, we not only have TypeScript, which does much of what Ext does and some things it doesn’t, but we have an evolving JavaScript standard that I’m afraid Sencha won’t be able to keep up with.  They already discourage the use of ‘use strict’;.  Once again, there is only one place where this will get you in trouble, and the work around actually produces more efficient code.  But still, the point is, Sencha is relying on ECMA Script 3 standards while the world has largely moved on to ECMA 2015 and beyond.</p>\n<p>Anyhow, my point here is that Ext is not just a framework but also functions, largely, as its own language.  Not quite as much a fork from the standard as Coffee Script, but also not nearly as close to the JavaScript spec as TypeScript.  So while it is still JavaScript, if you are a JavaScript programmer, it isn’t going to feel quite like JavaScript to you.</p>\n<h3 id=\"Themes\"><a href=\"#Themes\" class=\"headerlink\" title=\"Themes\"></a>Themes</h3><p>The final place you will find “Proprietary” lurking is with the Themes.  There are several really good CSS frameworks out there.  Sencha uses none of them.  And while the syntax they use for creating themes has been SASS up until Ext 6, now they even have their own proprietary SASS compiler.  Watch out here because they are still using the SASS extensions so you are likely to make some assumptions here that aren’t true because, once again, they’ve only implemented enough of the SASS engine to do what THEY need to do.</p>\n<h2 id=\"VB-All-Over-Again\"><a href=\"#VB-All-Over-Again\" class=\"headerlink\" title=\"VB All Over Again\"></a>VB All Over Again</h2><p>Every time I hear someone praise how great Ext is, it is normally because it has everything you need out of the box and allows you to get stuff done quickly.  </p>\n<p>Basically the same argument for using Visual Basic back in the day.  And yet I learned to never take a VB job because it almost every instance, while it was possible to write well structured code in Visual Basic, it was generally so difficult to do that the code I would be maintaining would need to be rewritten in order to make any sense of it. Ext suffers the same issue.  There is nothing in Ext to force you to write well structured code.  The code I have had to maintain has almost always followed every anti-pattern known to man.  In this case, this isn’t Sencha’s fault directly other than the fact that the only reason my code tends to be cleaner than most is because I’m more likely to code a fix to an Ext bug than I am to work around the problem with an anti-pattern.</p>\n<p>In comparison to other frameworks that are available, if all you want is a tool that will get you a semi working application quickly, and you don’t care so much about having to rewrite it when you need to change it in some way, Ext is your tool.  If on the other hand, you care about design and you want to be able to maintain what you’ve written, you should look elsewhere.</p>\n<p>Remember, if it sounds too good to be true, it probably is.</p>\n",
            "tags": [
                "javascript",
                "ext js",
                "sencha"
            ]
        },
        {
            "id": "http://davembush.github.com/how-not-to-choose-a-framework/",
            "url": "http://davembush.github.com/how-not-to-choose-a-framework/",
            "title": "How Not to Choose a Framework",
            "date_published": "2016-06-02T10:30:00.000Z",
            "content_html": "<p>In my job as a JavaScript architect, trainer and mentor, I’m often asked, “What’s your favorite framework?”  Or “What is the best framework?” And it surprises people when I give them two answers to that question.</p>\n<p>Right now, of the frameworks I’ve looked at, my favorite framework is <a href=\"/tags/react-js/\">React JS</a>.  But if I were picking a corporate framework, at this point I’d probably land on <a href=\"/angular-2-first-impressions-compared-to-angular-1/\">Angular 2.0</a>.</p>\n<p>But the question you are probably asking is , “Why two different selections?”  And, I think a more interesting question would be, “How did you select which one to use?” In fact, when I was thinking about writing this post, I was going to title it “How to Choose a JavaScript Framework” but as I considered what I would actually say, I realized that the factors I would use really apply to any language and any time.</p>\n<p>But an even more interesting question is this.  What factors are essential when picking out a framework.  If I ignored these questions, what are the cost? So, I give you…</p>\n<figure>![](/uploads/2016/05/image-3.png \"How Not to Choose a Framework\")<figcaption>Photo credit: [Tony Webster](//www.flickr.com/photos/diversey/980101167/) via [Visual hunt](//visualhunt.com) / [CC BY](//creativecommons.org/licenses/by/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"How-Not-to-Choose-a-Framework\"><a href=\"#How-Not-to-Choose-a-Framework\" class=\"headerlink\" title=\"How Not to Choose a Framework\"></a>How Not to Choose a Framework</h2><p>As we progress, I’ll mention frameworks I have experience with.  To be fair, I will let you know my preferences.</p>\n<p>In order, the frameworks I would prefer to use would be:</p>\n<ul>\n<li>React JS</li>\n<li>Angular 2</li>\n<li>Angular 1</li>\n<li>Ext JS 5 or 6</li>\n<li>Ext JS 4</li>\n</ul>\n<p>If I were going to recommend a framework for a large enterprise organization, the order would be slightly different:</p>\n<ul>\n<li>Angular 2</li>\n<li>Angular 1</li>\n<li>Ext JS 5 or 6</li>\n<li>React</li>\n<li>Ext JS 4</li>\n</ul>\n<p>With this in mind, here’s what you should pay attention to.</p>\n<h2 id=\"Who-Will-Use-The-Framework\"><a href=\"#Who-Will-Use-The-Framework\" class=\"headerlink\" title=\"Who Will Use The Framework?\"></a>Who Will Use The Framework?</h2><p>At the organization I am working at now, most of the people there are Java programmers.  This means that programming in JavaScript, of any flavor, is going to be as much as a mind-shift as moving from C to C++ or C++ to Java or C#.  Yes, there are similarities to what they are used to, but there are enough differences to consider that you’ll probably gravitate toward a framework that allows them to not have to worry about those differences.  On this point Ext or Angular 2 are probably going to rise to the surface because they, more than any other framework, allow you to work with JavaScript more like it was like Java or C# than any other framework I know about.</p>\n<h2 id=\"How-Steep-is-The-Learning-Curve\"><a href=\"#How-Steep-is-The-Learning-Curve\" class=\"headerlink\" title=\"How Steep is The Learning Curve?\"></a>How Steep is The Learning Curve?</h2><p>Related to who will use the framework is how long will it take them to learn the framework?  For this, you are going to want to look at things like:</p>\n<ul>\n<li>Can I buy support so I can get my questions answered?</li>\n<li>How clear is the documentation?</li>\n<li>How popular is the framework?</li>\n<li>Do I already have an expert on my team?</li>\n<li>Is there a public Slack channel for this framework?</li>\n<li>Do the people behind the framework care about the Enterprise?</li>\n</ul>\n<p>On this point, depending on the experience of your developers, Ext JS and Angular 2 are probably going to surface as the clear winners while React is going to end up at the very bottom.  As much as I love it personally, I have to admit that learning it has taken me the most amount of time.</p>\n<h2 id=\"How-Opinionated-is-the-Framework\"><a href=\"#How-Opinionated-is-the-Framework\" class=\"headerlink\" title=\"How Opinionated is the Framework?\"></a>How Opinionated is the Framework?</h2><p>I remember when VB 1.0 was first introduced.  The reason everyone gave me for why I should love this new development environment was, “Look how fast I can get something up and running.” Well, yes, but… VB let you write code any way that got the job done.  And coming from C++ and MFC and prior to that, OWL from Borland, I recognized that even though you could still write crappy code using a framework that provided some structure, the amount of crappy code you wrote was inversely proportional to the amount of structure the framework provides.</p>\n<p>When you are working with a large team of developers, something needs to be in place to ensure they are writing code in a highly structured way rather than just getting the job done.</p>\n<p>Once again, this places Angular 2 at the top of the pile of the ones I’ve actually worked with.  Ext sinks to the bottom of the pile.  While Ext does implement something they call MVC and MVVM, they don’t protect the developer from coding outside of what those design patterns are supposed to look like.  In the case of MVC, I’m not even sure the people who wrote it know what MVC is.</p>\n<h2 id=\"Industry-Standards\"><a href=\"#Industry-Standards\" class=\"headerlink\" title=\"Industry Standards\"></a>Industry Standards</h2><p>The easiest way for me to illustrate what I mean here is to point out a few ways this gets violated with the existing frameworks.</p>\n<p>In order to make Ext work more like a desktop development environment, they generate the HTML for you and use their own layout mechanism to control where the various elements appear on the screen.  Every other framework I’ve mentioned lets you control the layout using CSS.  The advantage to Ext is that I don’t have to know HTML or CSS in order to get a screen up that looks nice.  The down side is that if I want to do anything just a bit out of the Ext box, I quickly become frustrated.  It also takes more time to render a screen than if I were using HTML and CSS.  This is particularly true if your components are nested more than 3 deep.</p>\n<p>Further, Ext has enabled JavaScript to look more like Java and C# than JavaScript by implementing a proprietary mechanism for defining a class.  What continually worries me is how well this will continue to work as the ECMAScript standards evolve and provide there own mechanisms for achieving the same results.</p>\n<p>Ext also (sorry, but Ext is the primary violator of this point) uses its own proprietary build process.  It is possible to circumvent their build process for most things.  But the question one has to ask is, “why can’t you just use standards like gulp, grunt or npm scripts?” Even though Angular 2 primarily uses TypeScript, the difference between Angular 2 and Ext is that 1) you don’t HAVE to use TypeScript even though it is highly encourages and 2) TypeScript only implements features that look like they are going to eventually end up in the ECMAScript standards.  So, it is a lot more future proof while adding a lot of the same features that Ext implements in a more proprietary fashion.</p>\n<p>Another framework where this kind of shows up is with React JS.  While everything about building the app is built using industry standards, the unit testing framework doesn’t allow you to use Karma as your test running.  There is another more proprietary implentation called Jest.  However, I also don’t have to use PhantomJS to gets my components.  I wish I could have both.</p>\n<h2 id=\"How-Testable-Is-It\"><a href=\"#How-Testable-Is-It\" class=\"headerlink\" title=\"How Testable Is It?\"></a>How Testable Is It?</h2><p>Anyone who is familiar with my history of posts, who know me personally, know <a href=\"/tags/tdd\">I am a huge proponent of TDD</a>. So, any framework I use has to allow me to unit test. This is why Ext JS 4 ends up dead last on my list. You would think that a framework that says they implement MVC would allow you to test the controller without have the view attached. That’s one of the points of MVC. But Ext doesn’t allow this.</p>\n<p>On the other end of the spectrum, React is testable all the way down. This is why I love it. The only reason I don’t consider it the right choice for the enterprise is because it takes so long to learn and the documentation isn’t very well done.</p>\n<h2 id=\"Doing-The-Research\"><a href=\"#Doing-The-Research\" class=\"headerlink\" title=\"Doing The Research\"></a>Doing The Research</h2><p>OK.  So, this is what you should look for, but when you are looking at the frameworks, how would you know?  Most of this information is only stuff you would find out after your programmers started using the framework.</p>\n<p>One way you can find out is to find people who have used the various frameworks you have under consideration.  One of my first test would be, “How much information can I find on the Internet about this framework?”My second question would be, “How popular is this framework?” and then finally I would look for people who don’t like the framework and try to determine if their points are valid.</p>\n<h2 id=\"How-Not-to-Pick-a-Framework\"><a href=\"#How-Not-to-Pick-a-Framework\" class=\"headerlink\" title=\"How Not to Pick a Framework\"></a>How Not to Pick a Framework</h2><p>If you want to pick the wrong framework, trust the sales literature.  Don’t ask any question.  Ignore the points above.</p>\n<p>Ultimately regret your decision.</p>\n",
            "tags": [
                "javascript",
                "react.js",
                "ext js",
                "angular.js"
            ]
        },
        {
            "id": "http://davembush.github.com/ext-js-6-by-sencha-the-good-the-bad-the-ugly/",
            "url": "http://davembush.github.com/ext-js-6-by-sencha-the-good-the-bad-the-ugly/",
            "title": "Ext JS 6 by Sencha - The Good, The Bad, The Ugly",
            "date_published": "2016-04-07T11:30:00.000Z",
            "content_html": "<p>Long time readers may remember that I started using Ext JS about 3 years ago.  At the time, I was using version 4.2.2.  I recently started a new contract where they are using Ext JS 6.0.1.  I have to say, this version solves a lot of the architectural issues I had with the 4.x series.  But, there are still problems.</p>\n<p>Since I’ve provided an evaluation of <a href=\"/angular-2-first-impressions-compared-to-angular-1/\">Angular 2</a> and <a href=\"/react-js-and-associated-bits/\">React JS</a>, I thought providing an evaluation of the current version of Ext JS would be appropriate since these three seem to be the main players in the corporate world.</p>\n<figure>![](/uploads/2016/04/image.png \"Ext JS by Sencha - The Good, The Bad, The Ugly\")<figcaption>Photo credit: [sanbeiji](//www.flickr.com/photos/sanbeiji/5606497634/) via [Visual Hunt](//visualhunt.com) / [CC BY-SA](//creativecommons.org/licenses/by-sa/2.0/)</figcaption></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"Ext-JS-The-Good\"><a href=\"#Ext-JS-The-Good\" class=\"headerlink\" title=\"Ext JS - The Good\"></a>Ext JS - The Good</h2><h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>I’ve always had three major complaints about Ext JS.  Of the three, the fact that Ext JS is nearly impossible to test is the one that drove me away.  In fact, I almost didn’t interview for the contract I have now because they are using Ext JS.  This is because the 4.2 version that I was using implemented what they called the MVC framework.  The problem is, the MVC framework they implemented was not anything <a href=\"/designPatterns\">the Gang of Four</a> would recognize.  Once I realized that what they were calling MVC wasn’t really MVC, I was able to learn how to use the product much better.</p>\n<p>But being the TDD guy that I am, I was always frustrated by their implementation of MVC because in order to test anything in the Controller, I had to have the view available.  And while I tried several ways of mitigating this problem, I was never completely satisfied with the solution.  I ought to be able to test my controller without a view, or if I have to have a view, it should be some sort of fake view, or be able to render into a fake DOM like React JS does.</p>\n<p>But, in Ext JS 6, they’ve provided an alternate framework.  This time it is also more accurately named.  They have provided an MVVM implementation.  In the View, you provide your layout, declarative syntax to access the View’s state from the ViewModel and to specify the event handlers using listener blocks that tell the view what methods to call in the associated ViewController class.</p>\n<p>In the ViewController, your methods can access the ViewModel by calling getModel() and can set the state of the view by calling the ViewModel’s set() method.  Once this is done, the View can update using the ViewModel’s new state.</p>\n<p>What this means for testing is that I can test without the View by overriding the ViewContoller.getModel() method to return the ViewModel.  Run my test for a method and check the state of the ViewModel.  Look Ma, no View!</p>\n<h3 id=\"Everything-You-Need\"><a href=\"#Everything-You-Need\" class=\"headerlink\" title=\"Everything You Need\"></a>Everything You Need</h3><p>One of the biggest selling points for using Ext JS is that just about everything you could need is provided for you in once product.  Unlike Angular or React JS where one project provides the framework and another project or projects provide components, nearly everything you are going to need for your application is provided out of the box.  This is not to say that there aren’t third party providers for Ext JS, but the need for them is very limited.</p>\n<h3 id=\"Consistent-Rendering\"><a href=\"#Consistent-Rendering\" class=\"headerlink\" title=\"Consistent Rendering\"></a>Consistent Rendering</h3><p>One of the major attractions Ext has offered is that you don’t need to worry about cross browser rendering issues.  If you still need to support REALLY old browsers, this may still be a big selling point for you.  I think this will matter less in the future as the browsers continue to stabilize around standards.</p>\n<h3 id=\"Responsive-x2F-Adaptive\"><a href=\"#Responsive-x2F-Adaptive\" class=\"headerlink\" title=\"Responsive&#x2F;Adaptive\"></a>Responsive&#x2F;Adaptive</h3><p>Even though Ext JS uses a none standard way of rendering controls (see below) they do manage to achieve Adaptive and Responsive designs.</p>\n<h3 id=\"Ability-to-Control-DOM-Manipulation\"><a href=\"#Ability-to-Control-DOM-Manipulation\" class=\"headerlink\" title=\"Ability to Control DOM Manipulation\"></a>Ability to Control DOM Manipulation</h3><p>Finally, if you are having trouble achieving performance with the current way you are rending DOM changes, you will be happy to know that Ext JS does provide a way of turning of rendering to the DOM while you make all the changes and then turning it back on to do the final rendering.  But, at least my last usage of this, indicates that it doesn’t really turn off ALL DOM manipulation.  If you are inserting new DOM elements, those go out to the screen.  All Ext JS really does is to turn off their layout code.</p>\n<h3 id=\"Who-Ya-Gonna-Call\"><a href=\"#Who-Ya-Gonna-Call\" class=\"headerlink\" title=\"Who Ya Gonna Call?\"></a>Who Ya Gonna Call?</h3><p>One of the strongest reasons many organizations choose Ext JS is because the price of the license gives you access to Sencha support.  Companies I’ve worked for have used this for everything from “My code doesn’t work, what am I doing wrong?” and actually getting an answer to “I think you have a bug here.” and getting the bug fixed.  Kind of a private StackOverflow with direct access to the programmers who wrote the framework.</p>\n<h2 id=\"Ext-JS-The-Bad\"><a href=\"#Ext-JS-The-Bad\" class=\"headerlink\" title=\"Ext JS - The Bad\"></a>Ext JS - The Bad</h2><h3 id=\"Lock-In\"><a href=\"#Lock-In\" class=\"headerlink\" title=\"Lock In\"></a>Lock In</h3><p>If you decide to use Ext JS, you are really making a much more significant commitment than if you were choosing to use either Angular or React.  With either of those two, I can write standard JavaScript and I can mix and match several different existing frameworks.  Since just about everything in Ext JS is proprietary, mixing and matching is not only frowned upon, but they warn against it.  If you are using Ext JS, you are going to use ALL of Ext JS for everything.</p>\n<h3 id=\"Use-Strict\"><a href=\"#Use-Strict\" class=\"headerlink\" title=\"Use Strict\"></a>Use Strict</h3><p>Standard JS best practice recommends placing “use strict”; at the top of you IIFE block to protect you from making stupid mistakes.  Unfortunately, you can’t do this in your Ext JS code without having to work around the problems it produces.</p>\n<h3 id=\"String-Based\"><a href=\"#String-Based\" class=\"headerlink\" title=\"String Based\"></a>String Based</h3><p>Ext JS is probably the most string based language I’ve ever seen.  While they now have plugins for some of the more popular IDEs that mitigate against the risk this imposes on your code, in terms of good solid JavaScript, there are much better ways of writing code than what Ext JS forces you into.</p>\n<h3 id=\"Nesting-Issues\"><a href=\"#Nesting-Issues\" class=\"headerlink\" title=\"Nesting Issues\"></a>Nesting Issues</h3><p>As I mentioned above, Ext JS does their own layouts in order to achieve a presentation that will look the same regardless of what browser it is running on.  However, the cost of this is that if you nest components too deeply, rendering your view or changes to your view, will take significantly longer than anyone is willing to wait around for.  So, to get around this, you end up writing sub optimal code from just about every coding principle in existence.  Specifically, DRY and SRP are difficult to achieve using Ext JS views.</p>\n<h3 id=\"Version-X-0-0-is-Always-Broken\"><a href=\"#Version-X-0-0-is-Always-Broken\" class=\"headerlink\" title=\"Version X.0.0 is Always Broken\"></a>Version X.0.0 is Always Broken</h3><p>I’ve complained about this publicly before.  But it seems to me, and everyone else I talk with that has used Ext JS that every .0.0 version is buggy.  Things that used to work in the previous version no longer work.  Despite the assertion from Sencha that they have thousands of tests.  I always wonder what kind of code coverage they have and if they have a test that covers every feature for every component they have documented.</p>\n<h2 id=\"Ext-JS-The-Ugly\"><a href=\"#Ext-JS-The-Ugly\" class=\"headerlink\" title=\"Ext JS - The Ugly\"></a>Ext JS - The Ugly</h2><h3 id=\"Ugly-HTML\"><a href=\"#Ugly-HTML\" class=\"headerlink\" title=\"Ugly HTML\"></a>Ugly HTML</h3><p>There is a lot that is ugly about Ext JS, but nothing is more visibly ugly than the HTML it produces.  This is because, in order to produces a view that will render on any browser, they’ve resorted to using HTML tables to wrap just about every standard control.  This is getting better.  There is less HTML generated in Ext JS 6 than there was in Ext JS 4, but it is still relatively ugly.</p>\n<p>And that whole nesting issue could go away tomorrow if they would give up on trying to control the rendering of the view through JavaScript.  Why do with JavaScript what CSS was designed to do and does MUCH better?!</p>\n<h3 id=\"SASS-isn’t-SASS\"><a href=\"#SASS-isn’t-SASS\" class=\"headerlink\" title=\"SASS isn’t SASS\"></a>SASS isn’t SASS</h3><p>Up until version 6, Sencha’s theming engine used standard SASS.  With version 6, they’ve dumped standard SASS for their own implementation that mostly does what SASS does but has a few embellishments that aren’t all bad, except for the fact that they still kept the SASS extensions for the files and the syntax is mostly the same.</p>\n<h3 id=\"None-Standard-JavaScript\"><a href=\"#None-Standard-JavaScript\" class=\"headerlink\" title=\"None Standard JavaScript\"></a>None Standard JavaScript</h3><p>But of all the issues I have with Ext JS 6, the one that bugs me the most is that their framework provides something that runs on JavaScript but really isn’t JavaScript.  They have their own way of declaring a class.  Their own way of instantiating a class.  Their own requires engine.  Their own bundling and minification engine.</p>\n<p>And since I can’t even use “use strict”; in what they have now – something that has been around long enough that it should be supported by every seriously used framework in existence – it makes me wonder what future embellishments to the JavaScript language we won’t be able to use because Sencha thinks they have a better idea.</p>\n<p>Will I be able to use the “class” keyword in the future instead of Ext.define()?</p>\n<h3 id=\"None-Standard-Build-Tools\"><a href=\"#None-Standard-Build-Tools\" class=\"headerlink\" title=\"None Standard Build Tools\"></a>None Standard Build Tools</h3><p>Not only does Ext JS use none standard JavaScript, but they are using their own proprietary build tools to deploy the final applications.  Along with using their own version of SASS, they also have their own implementation of bundling and minification.  Why not use gulp or grunt and allow us to bundle our apps our way?  Oh, right, they have their own implementation of requires too.  And now they want to sell us proprietary testing tools.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>So, is Ext JS for you?  That’s a good question.  You’ll need to evaluate if the good parts outweigh the bad parts.  It isn’t like either Angular or React have everything.  There is no perfect choice.  There is the best choice for you and your organization.</p>\n",
            "tags": [
                "javascript",
                "ext js"
            ]
        }
    ]
}