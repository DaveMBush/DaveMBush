{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook • All posts by \"acrofields\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/itextsharp-%E2%80%93-the-easy-way/",
            "url": "http://davembush.github.com/itextsharp-%E2%80%93-the-easy-way/",
            "title": "iTextSharp – The easy way",
            "date_published": "2009-06-24T11:00:00.000Z",
            "content_html": "<p><img src=\"/uploads/2009/06/ka_vol1_038Copy.jpg\" alt=\"iTextSharp The Easy Way\" title=\"iTextSharp The Easy Way\"> When I first started generating PDFs dynamically, I was overwhelmed by the complexity of the API.  Not just with iTextSharp, but it seemed that all of the APIs were complex. In looking through the API and comparing it to what I was actually trying to accomplish, I found there was a very small subset of classes and methods that I needed to use to accomplish the task at hand.  Now that I’ve learned more, I still use this same subset of commands for 90% of what I need to do in iTextSharp.  The reason we produce PDFs programmatically at all is because we need to dynamically generate some information on the page.  Most of the time, this information comes out of a database and gets placed on the same location of the page each time the page is generated.  The rest of the information is static. So what I normally do is have my designer or project manager create a PDF for me with form fields located where he wants the information to go.  Using the form fields, he can define the font, size, color, and position he wants to display the text with.  All I have to worry about is getting the text into the field. This works out nicely because once I’ve filled in the forms, he can move them around until he’s happy with them without asking for my help. We’ve already covered <a href=\"/2009/06/17/pdfs-using-itextsharp/\">setting the MIME type information</a> in our first post, so the rest of this discussion will assume you’ve already done that. The next thing you’ll want to do is load the PDF document that has the form fields in it and create a stamper object.  The stamper is what we use to grab the form fields object which we will use to set the form field values.</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PdfReader pdfReader = <span class=\"keyword\">new</span> PdfReader(fileSpecifier);</span><br><span class=\"line\">PdfStamper stamp =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> PdfStamper(pdfReader, Response.OutputStream);</span><br><span class=\"line\">AcroFields fields = stamp.AcroFields;</span><br></pre></td></tr></table></figure>\n\n<p>You’ll notice that the PdfStamper constructor takes two parameters.  The first is the PdfReader object we created above it.  The second is the Response.OutputStream.  This is how we can stream binary data back to the browser.  Make sure you use OutputStream and not Output.  Otherwise you’ll get a compiler error. Now, filling the form fields is just a matter of calling SetField().  The first parameter is the name of the field we want to set and the second parameter is the content we want to set it to.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fields.SetField(<span class=\"string\">&quot;fieldName&quot;</span>, <span class=\"string\">&quot;Field Content Goes Here&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>The cool thing about this is that you can have multiple fields in your PDF with the same name and one SetField() call will set them both. Once you’ve filled all your fields, you “flatten” the form and send the information back to the browser.  If you choose to not flatten the form, you’ll end up with the form fields showing in the results.  Most of the time this is not what we had in mind.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stamp.FormFlattening = (<span class=\"literal\">true</span>);</span><br><span class=\"line\">stamp.Close();</span><br><span class=\"line\">Response.End();</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "iTextSharp",
                "PDF",
                "acrofields",
                "form fields",
                "outputstream",
                "pdfreader",
                "pdfstamper"
            ]
        }
    ]
}